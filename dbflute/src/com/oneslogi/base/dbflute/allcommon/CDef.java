package com.oneslogi.base.dbflute.allcommon;

import java.util.*;

import org.dbflute.exception.ClassificationNotFoundException;
import org.dbflute.jdbc.Classification;
import org.dbflute.jdbc.ClassificationCodeType;
import org.dbflute.jdbc.ClassificationMeta;
import org.dbflute.jdbc.ClassificationUndefinedHandlingType;
import org.dbflute.optional.OptionalThing;
import static org.dbflute.util.DfTypeUtil.emptyStrings;

/**
 * The definition of classification.
 * @author DBFlute(AutoGenerator)
 */
public interface CDef extends Classification {

    /**
     * 処理区分マスタの処理区分CD
     */
    public enum ProcessTypeCd implements CDef {
        /** $01: 通常入荷 */
        $01("01", "$01", emptyStrings())
        ,
        /** $21: 移動 */
        $21("21", "$21", emptyStrings())
        ,
        /** $23: 調整- */
        $23("23", "$23", emptyStrings())
        ,
        /** $24: 調整+ */
        $24("24", "$24", emptyStrings())
        ,
        /** $25: 入庫格納 */
        $25("25", "$25", emptyStrings())
        ,
        /** $27: 入庫No分割 */
        $27("27", "$27", emptyStrings())
        ,
        /** $29: 強制移動 */
        $29("29", "$29", emptyStrings())
        ,
        /** $30: セット組指示 */
        $30("30", "$30", emptyStrings())
        ,
        /** $31: セット解除指示 */
        $31("31", "$31", emptyStrings())
        ,
        /** $32: 定期補充 */
        $32("32", "$32", emptyStrings())
        ,
        /** $33: 緊急補充 */
        $33("33", "$33", emptyStrings())
        ;
        private static final Map<String, ProcessTypeCd> _codeClsMap = new HashMap<String, ProcessTypeCd>();
        private static final Map<String, ProcessTypeCd> _nameClsMap = new HashMap<String, ProcessTypeCd>();
        static {
            for (ProcessTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProcessTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProcessTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProcessTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProcessTypeCd) { return OptionalThing.of((ProcessTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProcessTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProcessTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProcessTypeCd) { return (ProcessTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProcessTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProcessTypeCd> listAll() {
            return new ArrayList<ProcessTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProcessTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProcessTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProcessTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProcessTypeCd> clsList = new ArrayList<ProcessTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProcessTypeCd> groupOf(String groupName) {
            return new ArrayList<ProcessTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検品後納品明細出力対象
     */
    public enum AfterDelivSlipOutTgt implements CDef {
        /** $1: ECお買上明細 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 納品明細 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, AfterDelivSlipOutTgt> _codeClsMap = new HashMap<String, AfterDelivSlipOutTgt>();
        private static final Map<String, AfterDelivSlipOutTgt> _nameClsMap = new HashMap<String, AfterDelivSlipOutTgt>();
        static {
            for (AfterDelivSlipOutTgt value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AfterDelivSlipOutTgt(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AfterDelivSlipOutTgt; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AfterDelivSlipOutTgt> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AfterDelivSlipOutTgt) { return OptionalThing.of((AfterDelivSlipOutTgt)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AfterDelivSlipOutTgt> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AfterDelivSlipOutTgt codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AfterDelivSlipOutTgt) { return (AfterDelivSlipOutTgt)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AfterDelivSlipOutTgt nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AfterDelivSlipOutTgt> listAll() {
            return new ArrayList<AfterDelivSlipOutTgt>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AfterDelivSlipOutTgt> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AfterDelivSlipOutTgt." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AfterDelivSlipOutTgt> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AfterDelivSlipOutTgt> clsList = new ArrayList<AfterDelivSlipOutTgt>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AfterDelivSlipOutTgt> groupOf(String groupName) {
            return new ArrayList<AfterDelivSlipOutTgt>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検品後荷札出力フラグ
     */
    public enum AfterTagOutFlg implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: バラ出荷検品後に出力 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ケース出荷検品後に出力 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: バラ・ケース出荷検品後に出力 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, AfterTagOutFlg> _codeClsMap = new HashMap<String, AfterTagOutFlg>();
        private static final Map<String, AfterTagOutFlg> _nameClsMap = new HashMap<String, AfterTagOutFlg>();
        static {
            for (AfterTagOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AfterTagOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AfterTagOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AfterTagOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AfterTagOutFlg) { return OptionalThing.of((AfterTagOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AfterTagOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AfterTagOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AfterTagOutFlg) { return (AfterTagOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AfterTagOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AfterTagOutFlg> listAll() {
            return new ArrayList<AfterTagOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AfterTagOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AfterTagOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AfterTagOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AfterTagOutFlg> clsList = new ArrayList<AfterTagOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AfterTagOutFlg> groupOf(String groupName) {
            return new ArrayList<AfterTagOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当不可フラグ表示
     */
    public enum AllcNgDisplay implements CDef {
        /** $0: 表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AllcNgDisplay> _codeClsMap = new HashMap<String, AllcNgDisplay>();
        private static final Map<String, AllcNgDisplay> _nameClsMap = new HashMap<String, AllcNgDisplay>();
        static {
            for (AllcNgDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AllcNgDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AllcNgDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllcNgDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AllcNgDisplay) { return OptionalThing.of((AllcNgDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllcNgDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AllcNgDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AllcNgDisplay) { return (AllcNgDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AllcNgDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AllcNgDisplay> listAll() {
            return new ArrayList<AllcNgDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AllcNgDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AllcNgDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AllcNgDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AllcNgDisplay> clsList = new ArrayList<AllcNgDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AllcNgDisplay> groupOf(String groupName) {
            return new ArrayList<AllcNgDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当禁止フラグ
     */
    public enum AllcNgFlg implements CDef {
        /** $0: 引当可能 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 引当禁止 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AllcNgFlg> _codeClsMap = new HashMap<String, AllcNgFlg>();
        private static final Map<String, AllcNgFlg> _nameClsMap = new HashMap<String, AllcNgFlg>();
        static {
            for (AllcNgFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AllcNgFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AllcNgFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllcNgFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AllcNgFlg) { return OptionalThing.of((AllcNgFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllcNgFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AllcNgFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AllcNgFlg) { return (AllcNgFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AllcNgFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AllcNgFlg> listAll() {
            return new ArrayList<AllcNgFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AllcNgFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AllcNgFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AllcNgFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AllcNgFlg> clsList = new ArrayList<AllcNgFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AllcNgFlg> groupOf(String groupName) {
            return new ArrayList<AllcNgFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当ソートキー
     */
    public enum AllocSortKey implements CDef {
        /** $limitDt: 期限日 */
        $limitDt("limitDt", "$limitDt", emptyStrings())
        ,
        /** $locationCd: ロケーションCD */
        $locationCd("locationCd", "$locationCd", emptyStrings())
        ,
        /** $locationOrder: ロケーション引当順序 */
        $locationOrder("locationOrder", "$locationOrder", emptyStrings())
        ,
        /** $lot: ロット */
        $lot("lot", "$lot", emptyStrings())
        ,
        /** $lotOrder: ロットソート順 */
        $lotOrder("lotOrder", "$lotOrder", emptyStrings())
        ,
        /** $storeDt: 入庫日 */
        $storeDt("storeDt", "$storeDt", emptyStrings())
        ,
        /** $storeLabelNo: 入庫ラベルNo. */
        $storeLabelNo("storeLabelNo", "$storeLabelNo", emptyStrings())
        ,
        /** $zoneCd: ゾーンCD */
        $zoneCd("zoneCd", "$zoneCd", emptyStrings())
        ;
        private static final Map<String, AllocSortKey> _codeClsMap = new HashMap<String, AllocSortKey>();
        private static final Map<String, AllocSortKey> _nameClsMap = new HashMap<String, AllocSortKey>();
        static {
            for (AllocSortKey value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AllocSortKey(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AllocSortKey; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllocSortKey> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AllocSortKey) { return OptionalThing.of((AllocSortKey)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllocSortKey> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AllocSortKey codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AllocSortKey) { return (AllocSortKey)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AllocSortKey nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AllocSortKey> listAll() {
            return new ArrayList<AllocSortKey>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AllocSortKey> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AllocSortKey." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AllocSortKey> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AllocSortKey> clsList = new ArrayList<AllocSortKey>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AllocSortKey> groupOf(String groupName) {
            return new ArrayList<AllocSortKey>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 全数出庫フラグ
     */
    public enum AllShippingFlg implements CDef {
        /** $0: 部分出庫 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全数出庫 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AllShippingFlg> _codeClsMap = new HashMap<String, AllShippingFlg>();
        private static final Map<String, AllShippingFlg> _nameClsMap = new HashMap<String, AllShippingFlg>();
        static {
            for (AllShippingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AllShippingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AllShippingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllShippingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AllShippingFlg) { return OptionalThing.of((AllShippingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllShippingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AllShippingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AllShippingFlg) { return (AllShippingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AllShippingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AllShippingFlg> listAll() {
            return new ArrayList<AllShippingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AllShippingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AllShippingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AllShippingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AllShippingFlg> clsList = new ArrayList<AllShippingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AllShippingFlg> groupOf(String groupName) {
            return new ArrayList<AllShippingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 着店CDフォーマット
     */
    public enum ArrivalStoreFormat implements CDef {
        /** $YMTFMT: ヤマト用変換フォーマット */
        $YMTFMT("YMTFMT", "$YMTFMT", emptyStrings())
        ,
        /** $YUPKFMT: ゆうパック用変換フォーマット */
        $YUPKFMT("YUPKFMT", "$YUPKFMT", emptyStrings())
        ;
        private static final Map<String, ArrivalStoreFormat> _codeClsMap = new HashMap<String, ArrivalStoreFormat>();
        private static final Map<String, ArrivalStoreFormat> _nameClsMap = new HashMap<String, ArrivalStoreFormat>();
        static {
            for (ArrivalStoreFormat value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ArrivalStoreFormat(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ArrivalStoreFormat; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ArrivalStoreFormat> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ArrivalStoreFormat) { return OptionalThing.of((ArrivalStoreFormat)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ArrivalStoreFormat> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ArrivalStoreFormat codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ArrivalStoreFormat) { return (ArrivalStoreFormat)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ArrivalStoreFormat nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ArrivalStoreFormat> listAll() {
            return new ArrayList<ArrivalStoreFormat>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ArrivalStoreFormat> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ArrivalStoreFormat." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ArrivalStoreFormat> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ArrivalStoreFormat> clsList = new ArrayList<ArrivalStoreFormat>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ArrivalStoreFormat> groupOf(String groupName) {
            return new ArrayList<ArrivalStoreFormat>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 自動緊急フラグ設定フラグ
     */
    public enum AutoEmgSetFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AutoEmgSetFlg> _codeClsMap = new HashMap<String, AutoEmgSetFlg>();
        private static final Map<String, AutoEmgSetFlg> _nameClsMap = new HashMap<String, AutoEmgSetFlg>();
        static {
            for (AutoEmgSetFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AutoEmgSetFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AutoEmgSetFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoEmgSetFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AutoEmgSetFlg) { return OptionalThing.of((AutoEmgSetFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoEmgSetFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AutoEmgSetFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AutoEmgSetFlg) { return (AutoEmgSetFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AutoEmgSetFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AutoEmgSetFlg> listAll() {
            return new ArrayList<AutoEmgSetFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AutoEmgSetFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AutoEmgSetFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AutoEmgSetFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AutoEmgSetFlg> clsList = new ArrayList<AutoEmgSetFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AutoEmgSetFlg> groupOf(String groupName) {
            return new ArrayList<AutoEmgSetFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 自動緊急フラグ判断対象
     */
    public enum AutoEmgSetTgt implements CDef {
        /** $1: 積込予定時刻 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 出荷予定時刻 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, AutoEmgSetTgt> _codeClsMap = new HashMap<String, AutoEmgSetTgt>();
        private static final Map<String, AutoEmgSetTgt> _nameClsMap = new HashMap<String, AutoEmgSetTgt>();
        static {
            for (AutoEmgSetTgt value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AutoEmgSetTgt(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AutoEmgSetTgt; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoEmgSetTgt> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AutoEmgSetTgt) { return OptionalThing.of((AutoEmgSetTgt)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoEmgSetTgt> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AutoEmgSetTgt codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AutoEmgSetTgt) { return (AutoEmgSetTgt)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AutoEmgSetTgt nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AutoEmgSetTgt> listAll() {
            return new ArrayList<AutoEmgSetTgt>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AutoEmgSetTgt> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AutoEmgSetTgt." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AutoEmgSetTgt> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AutoEmgSetTgt> clsList = new ArrayList<AutoEmgSetTgt>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AutoEmgSetTgt> groupOf(String groupName) {
            return new ArrayList<AutoEmgSetTgt>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 自動印刷対象フラグ
     */
    public enum AutoPrintTargetFlg implements CDef {
        /** $0: 自動印刷対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 自動印刷対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AutoPrintTargetFlg> _codeClsMap = new HashMap<String, AutoPrintTargetFlg>();
        private static final Map<String, AutoPrintTargetFlg> _nameClsMap = new HashMap<String, AutoPrintTargetFlg>();
        static {
            for (AutoPrintTargetFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AutoPrintTargetFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AutoPrintTargetFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoPrintTargetFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AutoPrintTargetFlg) { return OptionalThing.of((AutoPrintTargetFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoPrintTargetFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AutoPrintTargetFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AutoPrintTargetFlg) { return (AutoPrintTargetFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AutoPrintTargetFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AutoPrintTargetFlg> listAll() {
            return new ArrayList<AutoPrintTargetFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AutoPrintTargetFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AutoPrintTargetFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AutoPrintTargetFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AutoPrintTargetFlg> clsList = new ArrayList<AutoPrintTargetFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AutoPrintTargetFlg> groupOf(String groupName) {
            return new ArrayList<AutoPrintTargetFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 自動出庫指示フラグ
     */
    public enum AutoShipInstFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AutoShipInstFlg> _codeClsMap = new HashMap<String, AutoShipInstFlg>();
        private static final Map<String, AutoShipInstFlg> _nameClsMap = new HashMap<String, AutoShipInstFlg>();
        static {
            for (AutoShipInstFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AutoShipInstFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AutoShipInstFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoShipInstFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AutoShipInstFlg) { return OptionalThing.of((AutoShipInstFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoShipInstFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AutoShipInstFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AutoShipInstFlg) { return (AutoShipInstFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AutoShipInstFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AutoShipInstFlg> listAll() {
            return new ArrayList<AutoShipInstFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AutoShipInstFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AutoShipInstFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AutoShipInstFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AutoShipInstFlg> clsList = new ArrayList<AutoShipInstFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AutoShipInstFlg> groupOf(String groupName) {
            return new ArrayList<AutoShipInstFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * バーコード種別
     */
    public enum BarcodeType implements CDef {
        /** $CODABAR: CODABAR(NW-7) */
        $CODABAR("CODABAR", "$CODABAR", emptyStrings())
        ,
        /** $CODE128: CODE128 */
        $CODE128("CODE128", "$CODE128", emptyStrings())
        ,
        /** $CODE39: CODE39 */
        $CODE39("CODE39", "$CODE39", emptyStrings())
        ,
        /** $ITF: ITF */
        $ITF("ITF", "$ITF", emptyStrings())
        ,
        /** $JAN: JAN(8or13) */
        $JAN("JAN", "$JAN", emptyStrings())
        ;
        private static final Map<String, BarcodeType> _codeClsMap = new HashMap<String, BarcodeType>();
        private static final Map<String, BarcodeType> _nameClsMap = new HashMap<String, BarcodeType>();
        static {
            for (BarcodeType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BarcodeType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BarcodeType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BarcodeType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BarcodeType) { return OptionalThing.of((BarcodeType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BarcodeType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BarcodeType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BarcodeType) { return (BarcodeType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BarcodeType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BarcodeType> listAll() {
            return new ArrayList<BarcodeType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BarcodeType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BarcodeType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BarcodeType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BarcodeType> clsList = new ArrayList<BarcodeType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BarcodeType> groupOf(String groupName) {
            return new ArrayList<BarcodeType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * バッチ処理中フラグ
     */
    public enum BatchProgressFlg implements CDef {
        /** $0: 非処理中 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 処理中 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, BatchProgressFlg> _codeClsMap = new HashMap<String, BatchProgressFlg>();
        private static final Map<String, BatchProgressFlg> _nameClsMap = new HashMap<String, BatchProgressFlg>();
        static {
            for (BatchProgressFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BatchProgressFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BatchProgressFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BatchProgressFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BatchProgressFlg) { return OptionalThing.of((BatchProgressFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BatchProgressFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BatchProgressFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BatchProgressFlg) { return (BatchProgressFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BatchProgressFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BatchProgressFlg> listAll() {
            return new ArrayList<BatchProgressFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BatchProgressFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BatchProgressFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BatchProgressFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BatchProgressFlg> clsList = new ArrayList<BatchProgressFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BatchProgressFlg> groupOf(String groupName) {
            return new ArrayList<BatchProgressFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷材選択スキップ
     */
    public enum BoxSelectSkip implements CDef {
        /** $0: スキップしない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: スキップする */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, BoxSelectSkip> _codeClsMap = new HashMap<String, BoxSelectSkip>();
        private static final Map<String, BoxSelectSkip> _nameClsMap = new HashMap<String, BoxSelectSkip>();
        static {
            for (BoxSelectSkip value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BoxSelectSkip(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BoxSelectSkip; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BoxSelectSkip> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BoxSelectSkip) { return OptionalThing.of((BoxSelectSkip)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BoxSelectSkip> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BoxSelectSkip codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BoxSelectSkip) { return (BoxSelectSkip)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BoxSelectSkip nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BoxSelectSkip> listAll() {
            return new ArrayList<BoxSelectSkip>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BoxSelectSkip> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BoxSelectSkip." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BoxSelectSkip> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BoxSelectSkip> clsList = new ArrayList<BoxSelectSkip>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BoxSelectSkip> groupOf(String groupName) {
            return new ArrayList<BoxSelectSkip>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * キャンセルデータ表示
     */
    public enum CancelDataDisplay implements CDef {
        /** $0: 表示しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全件表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CancelDataDisplay> _codeClsMap = new HashMap<String, CancelDataDisplay>();
        private static final Map<String, CancelDataDisplay> _nameClsMap = new HashMap<String, CancelDataDisplay>();
        static {
            for (CancelDataDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CancelDataDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CancelDataDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CancelDataDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CancelDataDisplay) { return OptionalThing.of((CancelDataDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CancelDataDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CancelDataDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CancelDataDisplay) { return (CancelDataDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CancelDataDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CancelDataDisplay> listAll() {
            return new ArrayList<CancelDataDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CancelDataDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CancelDataDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CancelDataDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CancelDataDisplay> clsList = new ArrayList<CancelDataDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CancelDataDisplay> groupOf(String groupName) {
            return new ArrayList<CancelDataDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケースピッキングフラグ
     */
    public enum CasePicFlg implements CDef {
        /** $0: ケースピック無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ケースピック有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CasePicFlg> _codeClsMap = new HashMap<String, CasePicFlg>();
        private static final Map<String, CasePicFlg> _nameClsMap = new HashMap<String, CasePicFlg>();
        static {
            for (CasePicFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CasePicFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CasePicFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePicFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CasePicFlg) { return OptionalThing.of((CasePicFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePicFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CasePicFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CasePicFlg) { return (CasePicFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CasePicFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CasePicFlg> listAll() {
            return new ArrayList<CasePicFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CasePicFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CasePicFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CasePicFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CasePicFlg> clsList = new ArrayList<CasePicFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CasePicFlg> groupOf(String groupName) {
            return new ArrayList<CasePicFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * センタ・荷主区分
     */
    public enum CenterClientCls implements CDef {
        /** $1: センタ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 荷主 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CenterClientCls> _codeClsMap = new HashMap<String, CenterClientCls>();
        private static final Map<String, CenterClientCls> _nameClsMap = new HashMap<String, CenterClientCls>();
        static {
            for (CenterClientCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterClientCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterClientCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterClientCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterClientCls) { return OptionalThing.of((CenterClientCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterClientCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterClientCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterClientCls) { return (CenterClientCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterClientCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterClientCls> listAll() {
            return new ArrayList<CenterClientCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterClientCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterClientCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterClientCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterClientCls> clsList = new ArrayList<CenterClientCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterClientCls> groupOf(String groupName) {
            return new ArrayList<CenterClientCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * センタ間移動フラグ
     */
    public enum CenterTransitFlg implements CDef {
        /** $0: 通常 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: センタ間移動 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterTransitFlg> _codeClsMap = new HashMap<String, CenterTransitFlg>();
        private static final Map<String, CenterTransitFlg> _nameClsMap = new HashMap<String, CenterTransitFlg>();
        static {
            for (CenterTransitFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTransitFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTransitFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransitFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTransitFlg) { return OptionalThing.of((CenterTransitFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransitFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTransitFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTransitFlg) { return (CenterTransitFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTransitFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTransitFlg> listAll() {
            return new ArrayList<CenterTransitFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTransitFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTransitFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTransitFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTransitFlg> clsList = new ArrayList<CenterTransitFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTransitFlg> groupOf(String groupName) {
            return new ArrayList<CenterTransitFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 文字コード
     */
    public enum CharacterCd implements CDef {
        /** $MS932: MS932 */
        $MS932("MS932", "$MS932", emptyStrings())
        ,
        /** $UTF8: UTF8 */
        $UTF8("UTF8", "$UTF8", emptyStrings())
        ;
        private static final Map<String, CharacterCd> _codeClsMap = new HashMap<String, CharacterCd>();
        private static final Map<String, CharacterCd> _nameClsMap = new HashMap<String, CharacterCd>();
        static {
            for (CharacterCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CharacterCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CharacterCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CharacterCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CharacterCd) { return OptionalThing.of((CharacterCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CharacterCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CharacterCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CharacterCd) { return (CharacterCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CharacterCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CharacterCd> listAll() {
            return new ArrayList<CharacterCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CharacterCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CharacterCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CharacterCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CharacterCd> clsList = new ArrayList<CharacterCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CharacterCd> groupOf(String groupName) {
            return new ArrayList<CharacterCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当可能数0非表示
     */
    public enum ChargeQty0Display implements CDef {
        /** $0: 0表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 0非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ChargeQty0Display> _codeClsMap = new HashMap<String, ChargeQty0Display>();
        private static final Map<String, ChargeQty0Display> _nameClsMap = new HashMap<String, ChargeQty0Display>();
        static {
            for (ChargeQty0Display value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ChargeQty0Display(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ChargeQty0Display; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ChargeQty0Display> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ChargeQty0Display) { return OptionalThing.of((ChargeQty0Display)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ChargeQty0Display> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ChargeQty0Display codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ChargeQty0Display) { return (ChargeQty0Display)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ChargeQty0Display nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ChargeQty0Display> listAll() {
            return new ArrayList<ChargeQty0Display>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ChargeQty0Display> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ChargeQty0Display." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ChargeQty0Display> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ChargeQty0Display> clsList = new ArrayList<ChargeQty0Display>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ChargeQty0Display> groupOf(String groupName) {
            return new ArrayList<ChargeQty0Display>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * チェックディジット
     */
    public enum CheckDigit implements CDef {
        /** $0: チェックディジット無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $7: 7DR方式 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, CheckDigit> _codeClsMap = new HashMap<String, CheckDigit>();
        private static final Map<String, CheckDigit> _nameClsMap = new HashMap<String, CheckDigit>();
        static {
            for (CheckDigit value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CheckDigit(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CheckDigit; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CheckDigit> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CheckDigit) { return OptionalThing.of((CheckDigit)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CheckDigit> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CheckDigit codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CheckDigit) { return (CheckDigit)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CheckDigit nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CheckDigit> listAll() {
            return new ArrayList<CheckDigit>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CheckDigit> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CheckDigit." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CheckDigit> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CheckDigit> clsList = new ArrayList<CheckDigit>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CheckDigit> groupOf(String groupName) {
            return new ArrayList<CheckDigit>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 複数番号の有無
     */
    public enum CodeFlg implements CDef {
        /** $0: 複数番号無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 複数番号有(個別番号の1) */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 複数番号有(個別番号の2) */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 複数番号有(個別番号の3) */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, CodeFlg> _codeClsMap = new HashMap<String, CodeFlg>();
        private static final Map<String, CodeFlg> _nameClsMap = new HashMap<String, CodeFlg>();
        static {
            for (CodeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodeFlg) { return OptionalThing.of((CodeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodeFlg) { return (CodeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodeFlg> listAll() {
            return new ArrayList<CodeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodeFlg> clsList = new ArrayList<CodeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodeFlg> groupOf(String groupName) {
            return new ArrayList<CodeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 個別番号の種別
     */
    public enum CodeType implements CDef {
        /** $0: 大口事業所 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 私書箱 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CodeType> _codeClsMap = new HashMap<String, CodeType>();
        private static final Map<String, CodeType> _nameClsMap = new HashMap<String, CodeType>();
        static {
            for (CodeType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodeType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodeType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodeType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodeType) { return OptionalThing.of((CodeType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodeType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodeType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodeType) { return (CodeType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodeType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodeType> listAll() {
            return new ArrayList<CodeType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodeType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodeType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodeType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodeType> clsList = new ArrayList<CodeType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodeType> groupOf(String groupName) {
            return new ArrayList<CodeType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 元着区分
     */
    public enum CodCls implements CDef {
        /** $1: 元払 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 着払 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CodCls> _codeClsMap = new HashMap<String, CodCls>();
        private static final Map<String, CodCls> _nameClsMap = new HashMap<String, CodCls>();
        static {
            for (CodCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodCls) { return OptionalThing.of((CodCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodCls) { return (CodCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodCls> listAll() {
            return new ArrayList<CodCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodCls> clsList = new ArrayList<CodCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodCls> groupOf(String groupName) {
            return new ArrayList<CodCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 元／着払／代引文字
     */
    public enum CodType implements CDef {
        /** $0: 元払 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 着払 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 代引 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CodType> _codeClsMap = new HashMap<String, CodType>();
        private static final Map<String, CodType> _nameClsMap = new HashMap<String, CodType>();
        static {
            for (CodType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodType) { return OptionalThing.of((CodType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodType) { return (CodType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodType> listAll() {
            return new ArrayList<CodType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodType> clsList = new ArrayList<CodType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodType> groupOf(String groupName) {
            return new ArrayList<CodType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 列型
     */
    public enum ColType implements CDef {
        /** $calcnumber: 計算数値 */
        $calcnumber("calcnumber", "$calcnumber", emptyStrings())
        ,
        /** $checkbox: チェックボックス */
        $checkbox("checkbox", "$checkbox", emptyStrings())
        ,
        /** $date: 日付 */
        $date("date", "$date", emptyStrings())
        ,
        /** $datetime: 日時 */
        $datetime("datetime", "$datetime", emptyStrings())
        ,
        /** $dropdown: コンボボックス */
        $dropdown("dropdown", "$dropdown", emptyStrings())
        ,
        /** $number: 数値 */
        $number("number", "$number", emptyStrings())
        ,
        /** $text: テキスト */
        $text("text", "$text", emptyStrings())
        ;
        private static final Map<String, ColType> _codeClsMap = new HashMap<String, ColType>();
        private static final Map<String, ColType> _nameClsMap = new HashMap<String, ColType>();
        static {
            for (ColType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ColType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ColType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ColType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ColType) { return OptionalThing.of((ColType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ColType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ColType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ColType) { return (ColType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ColType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ColType> listAll() {
            return new ArrayList<ColType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ColType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ColType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ColType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ColType> clsList = new ArrayList<ColType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ColType> groupOf(String groupName) {
            return new ArrayList<ColType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * コメント1有無
     */
    public enum CommentFlg implements CDef {
        /** $0: コメント1無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: コメント1有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CommentFlg> _codeClsMap = new HashMap<String, CommentFlg>();
        private static final Map<String, CommentFlg> _nameClsMap = new HashMap<String, CommentFlg>();
        static {
            for (CommentFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CommentFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CommentFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CommentFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CommentFlg) { return OptionalThing.of((CommentFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CommentFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CommentFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CommentFlg) { return (CommentFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CommentFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CommentFlg> listAll() {
            return new ArrayList<CommentFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CommentFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CommentFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CommentFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CommentFlg> clsList = new ArrayList<CommentFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CommentFlg> groupOf(String groupName) {
            return new ArrayList<CommentFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 大口事業所フラグ
     */
    public enum CompanyFlg implements CDef {
        /** $0: 通常郵便番号 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 大口事業所 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CompanyFlg> _codeClsMap = new HashMap<String, CompanyFlg>();
        private static final Map<String, CompanyFlg> _nameClsMap = new HashMap<String, CompanyFlg>();
        static {
            for (CompanyFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CompanyFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CompanyFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CompanyFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CompanyFlg) { return OptionalThing.of((CompanyFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CompanyFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CompanyFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CompanyFlg) { return (CompanyFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CompanyFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CompanyFlg> listAll() {
            return new ArrayList<CompanyFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CompanyFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CompanyFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CompanyFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CompanyFlg> clsList = new ArrayList<CompanyFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CompanyFlg> groupOf(String groupName) {
            return new ArrayList<CompanyFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * クール区分
     */
    public enum CoolCls implements CDef {
        /** $0: 通常 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: クール冷凍 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: クール冷蔵 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CoolCls> _codeClsMap = new HashMap<String, CoolCls>();
        private static final Map<String, CoolCls> _nameClsMap = new HashMap<String, CoolCls>();
        static {
            for (CoolCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CoolCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CoolCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoolCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CoolCls) { return OptionalThing.of((CoolCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoolCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CoolCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CoolCls) { return (CoolCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CoolCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CoolCls> listAll() {
            return new ArrayList<CoolCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CoolCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CoolCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CoolCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CoolCls> clsList = new ArrayList<CoolCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CoolCls> groupOf(String groupName) {
            return new ArrayList<CoolCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保冷種別
     */
    public enum CoolType implements CDef {
        /** $0: 保冷なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: チルド */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 冷凍 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CoolType> _codeClsMap = new HashMap<String, CoolType>();
        private static final Map<String, CoolType> _nameClsMap = new HashMap<String, CoolType>();
        static {
            for (CoolType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CoolType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CoolType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoolType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CoolType) { return OptionalThing.of((CoolType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoolType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CoolType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CoolType) { return (CoolType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CoolType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CoolType> listAll() {
            return new ArrayList<CoolType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CoolType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CoolType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CoolType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CoolType> clsList = new ArrayList<CoolType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CoolType> groupOf(String groupName) {
            return new ArrayList<CoolType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * コピー対象テーブル
     */
    public enum CopyTargetTable implements CDef {
        /** $MCarrierSlipSgw: 佐川送り状マスタ */
        $MCarrierSlipSgw("MCarrierSlipSgw", "$MCarrierSlipSgw", emptyStrings())
        ,
        /** $MCarrierSlipYmt: ヤマト送り状マスタ */
        $MCarrierSlipYmt("MCarrierSlipYmt", "$MCarrierSlipYmt", emptyStrings())
        ,
        /** $MCarrierSlipYupk: ゆうパック送り状マスタ */
        $MCarrierSlipYupk("MCarrierSlipYupk", "$MCarrierSlipYupk", emptyStrings())
        ,
        /** $MCenterCol: センタ列マスタ */
        $MCenterCol("MCenterCol", "$MCenterCol", emptyStrings())
        ,
        /** $MCenterItem: センタ項目マスタ */
        $MCenterItem("MCenterItem", "$MCenterItem", emptyStrings())
        ,
        /** $MCenterScreen: センタ画面マスタ */
        $MCenterScreen("MCenterScreen", "$MCenterScreen", emptyStrings())
        ;
        private static final Map<String, CopyTargetTable> _codeClsMap = new HashMap<String, CopyTargetTable>();
        private static final Map<String, CopyTargetTable> _nameClsMap = new HashMap<String, CopyTargetTable>();
        static {
            for (CopyTargetTable value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CopyTargetTable(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CopyTargetTable; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CopyTargetTable> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CopyTargetTable) { return OptionalThing.of((CopyTargetTable)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CopyTargetTable> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CopyTargetTable codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CopyTargetTable) { return (CopyTargetTable)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CopyTargetTable nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CopyTargetTable> listAll() {
            return new ArrayList<CopyTargetTable>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CopyTargetTable> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CopyTargetTable." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CopyTargetTable> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CopyTargetTable> clsList = new ArrayList<CopyTargetTable>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CopyTargetTable> groupOf(String groupName) {
            return new ArrayList<CopyTargetTable>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 赤黒区分
     */
    public enum CorrectType implements CDef {
        /** $0: 黒 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 赤 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CorrectType> _codeClsMap = new HashMap<String, CorrectType>();
        private static final Map<String, CorrectType> _nameClsMap = new HashMap<String, CorrectType>();
        static {
            for (CorrectType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CorrectType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CorrectType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CorrectType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CorrectType) { return OptionalThing.of((CorrectType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CorrectType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CorrectType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CorrectType) { return (CorrectType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CorrectType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CorrectType> listAll() {
            return new ArrayList<CorrectType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CorrectType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CorrectType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CorrectType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CorrectType> clsList = new ArrayList<CorrectType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CorrectType> groupOf(String groupName) {
            return new ArrayList<CorrectType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * コミット区分
     */
    public enum DataInputCommitType implements CDef {
        /** $0: 一括コミット */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 随時コミット */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DataInputCommitType> _codeClsMap = new HashMap<String, DataInputCommitType>();
        private static final Map<String, DataInputCommitType> _nameClsMap = new HashMap<String, DataInputCommitType>();
        static {
            for (DataInputCommitType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputCommitType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputCommitType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputCommitType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputCommitType) { return OptionalThing.of((DataInputCommitType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputCommitType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputCommitType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputCommitType) { return (DataInputCommitType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputCommitType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputCommitType> listAll() {
            return new ArrayList<DataInputCommitType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputCommitType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputCommitType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputCommitType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputCommitType> clsList = new ArrayList<DataInputCommitType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputCommitType> groupOf(String groupName) {
            return new ArrayList<DataInputCommitType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 処理区分
     */
    public enum DataInputOperationType implements CDef {
        /** $0: アップロード */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ワーク取込 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: データ移行 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ダウンロード */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, DataInputOperationType> _codeClsMap = new HashMap<String, DataInputOperationType>();
        private static final Map<String, DataInputOperationType> _nameClsMap = new HashMap<String, DataInputOperationType>();
        static {
            for (DataInputOperationType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputOperationType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputOperationType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputOperationType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputOperationType) { return OptionalThing.of((DataInputOperationType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputOperationType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputOperationType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputOperationType) { return (DataInputOperationType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputOperationType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputOperationType> listAll() {
            return new ArrayList<DataInputOperationType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputOperationType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputOperationType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputOperationType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputOperationType> clsList = new ArrayList<DataInputOperationType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputOperationType> groupOf(String groupName) {
            return new ArrayList<DataInputOperationType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 処理区分
     */
    public enum DataInputProcessType implements CDef {
        /** $0: 追記のみ */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全削除後追記 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DataInputProcessType> _codeClsMap = new HashMap<String, DataInputProcessType>();
        private static final Map<String, DataInputProcessType> _nameClsMap = new HashMap<String, DataInputProcessType>();
        static {
            for (DataInputProcessType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputProcessType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputProcessType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputProcessType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputProcessType) { return OptionalThing.of((DataInputProcessType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputProcessType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputProcessType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputProcessType) { return (DataInputProcessType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputProcessType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputProcessType> listAll() {
            return new ArrayList<DataInputProcessType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputProcessType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputProcessType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputProcessType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputProcessType> clsList = new ArrayList<DataInputProcessType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputProcessType> groupOf(String groupName) {
            return new ArrayList<DataInputProcessType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 取込対象
     */
    public enum DataInputRange implements CDef {
        /** $0: 全件 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 未処理のみ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: エラーのみ */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, DataInputRange> _codeClsMap = new HashMap<String, DataInputRange>();
        private static final Map<String, DataInputRange> _nameClsMap = new HashMap<String, DataInputRange>();
        static {
            for (DataInputRange value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputRange(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputRange; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputRange> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputRange) { return OptionalThing.of((DataInputRange)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputRange> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputRange codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputRange) { return (DataInputRange)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputRange nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputRange> listAll() {
            return new ArrayList<DataInputRange>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputRange> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputRange." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputRange> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputRange> clsList = new ArrayList<DataInputRange>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputRange> groupOf(String groupName) {
            return new ArrayList<DataInputRange>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 取込種類
     */
    public enum DataInputType implements CDef {
        /** $01: 商品マスタ取込 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 商品荷姿マスタ取込 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 取引先マスタ取込 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: ロケーションマスタ取込 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 在庫データ取込 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 着店マスタ取込(ヤマト運輸) */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 着店マスタ取込(日本郵政) */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: 郵便番号マスタ取込 */
        $08("08", "$08", emptyStrings())
        ,
        /** $09: 郵便番号マスタ(大口事業所)取込 */
        $09("09", "$09", emptyStrings())
        ;
        private static final Map<String, DataInputType> _codeClsMap = new HashMap<String, DataInputType>();
        private static final Map<String, DataInputType> _nameClsMap = new HashMap<String, DataInputType>();
        static {
            for (DataInputType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputType) { return OptionalThing.of((DataInputType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputType) { return (DataInputType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputType> listAll() {
            return new ArrayList<DataInputType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputType> clsList = new ArrayList<DataInputType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputType> groupOf(String groupName) {
            return new ArrayList<DataInputType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * データ型
     */
    public enum DataType implements CDef {
        /** $date: 日付 */
        $date("date", "$date", emptyStrings())
        ,
        /** $datetime: 日時 */
        $datetime("datetime", "$datetime", emptyStrings())
        ,
        /** $number: 数値 */
        $number("number", "$number", emptyStrings())
        ,
        /** $text: テキスト */
        $text("text", "$text", emptyStrings())
        ,
        /** $time: 時刻 */
        $time("time", "$time", emptyStrings())
        ;
        private static final Map<String, DataType> _codeClsMap = new HashMap<String, DataType>();
        private static final Map<String, DataType> _nameClsMap = new HashMap<String, DataType>();
        static {
            for (DataType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataType) { return OptionalThing.of((DataType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataType) { return (DataType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataType> listAll() {
            return new ArrayList<DataType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataType> clsList = new ArrayList<DataType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataType> groupOf(String groupName) {
            return new ArrayList<DataType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * デフォルト
     */
    public enum Default implements CDef {
        /** $0: デフォルトでない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: デフォルト */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Default> _codeClsMap = new HashMap<String, Default>();
        private static final Map<String, Default> _nameClsMap = new HashMap<String, Default>();
        static {
            for (Default value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Default(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Default; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Default> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Default) { return OptionalThing.of((Default)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Default> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Default codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Default) { return (Default)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Default nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Default> listAll() {
            return new ArrayList<Default>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Default> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Default." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Default> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Default> clsList = new ArrayList<Default>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Default> groupOf(String groupName) {
            return new ArrayList<Default>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * デフォルトフラグ
     */
    public enum DefaultFlg implements CDef {
        /** $0: デフォルトでない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: デフォルト */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DefaultFlg> _codeClsMap = new HashMap<String, DefaultFlg>();
        private static final Map<String, DefaultFlg> _nameClsMap = new HashMap<String, DefaultFlg>();
        static {
            for (DefaultFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DefaultFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DefaultFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DefaultFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DefaultFlg) { return OptionalThing.of((DefaultFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DefaultFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DefaultFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DefaultFlg) { return (DefaultFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DefaultFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DefaultFlg> listAll() {
            return new ArrayList<DefaultFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DefaultFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DefaultFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DefaultFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DefaultFlg> clsList = new ArrayList<DefaultFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DefaultFlg> groupOf(String groupName) {
            return new ArrayList<DefaultFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 削除データ表示
     */
    public enum DeleteDataDisplay implements CDef {
        /** $0: 表示しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全件表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DeleteDataDisplay> _codeClsMap = new HashMap<String, DeleteDataDisplay>();
        private static final Map<String, DeleteDataDisplay> _nameClsMap = new HashMap<String, DeleteDataDisplay>();
        static {
            for (DeleteDataDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DeleteDataDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DeleteDataDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeleteDataDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DeleteDataDisplay) { return OptionalThing.of((DeleteDataDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeleteDataDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DeleteDataDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DeleteDataDisplay) { return (DeleteDataDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DeleteDataDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DeleteDataDisplay> listAll() {
            return new ArrayList<DeleteDataDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DeleteDataDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DeleteDataDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DeleteDataDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DeleteDataDisplay> clsList = new ArrayList<DeleteDataDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DeleteDataDisplay> groupOf(String groupName) {
            return new ArrayList<DeleteDataDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 納品先フラグ
     */
    public enum DeliveryFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DeliveryFlg> _codeClsMap = new HashMap<String, DeliveryFlg>();
        private static final Map<String, DeliveryFlg> _nameClsMap = new HashMap<String, DeliveryFlg>();
        static {
            for (DeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DeliveryFlg) { return OptionalThing.of((DeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DeliveryFlg) { return (DeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DeliveryFlg> listAll() {
            return new ArrayList<DeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DeliveryFlg> clsList = new ArrayList<DeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DeliveryFlg> groupOf(String groupName) {
            return new ArrayList<DeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送付先一致フラグ
     */
    public enum DelivMatchFlg implements CDef {
        /** $0: 不一致 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 一致 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DelivMatchFlg> _codeClsMap = new HashMap<String, DelivMatchFlg>();
        private static final Map<String, DelivMatchFlg> _nameClsMap = new HashMap<String, DelivMatchFlg>();
        static {
            for (DelivMatchFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DelivMatchFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DelivMatchFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivMatchFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DelivMatchFlg) { return OptionalThing.of((DelivMatchFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivMatchFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DelivMatchFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DelivMatchFlg) { return (DelivMatchFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DelivMatchFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DelivMatchFlg> listAll() {
            return new ArrayList<DelivMatchFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DelivMatchFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DelivMatchFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DelivMatchFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DelivMatchFlg> clsList = new ArrayList<DelivMatchFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DelivMatchFlg> groupOf(String groupName) {
            return new ArrayList<DelivMatchFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 納品時間帯
     */
    public enum DelivTz implements CDef {
        /** $A: 午前中 */
        $A("A", "$A", emptyStrings())
        ,
        /** $B: 12時～14時 */
        $B("B", "$B", emptyStrings())
        ,
        /** $C: 14時～16時 */
        $C("C", "$C", emptyStrings())
        ,
        /** $D: 16時～18時 */
        $D("D", "$D", emptyStrings())
        ,
        /** $E: 18時～20時 */
        $E("E", "$E", emptyStrings())
        ,
        /** $F: 18時～21時 */
        $F("F", "$F", emptyStrings())
        ,
        /** $G: 19時～21時 */
        $G("G", "$G", emptyStrings())
        ,
        /** $H: 20時～21時 */
        $H("H", "$H", emptyStrings())
        ,
        /** $I: 午前10時まで */
        $I("I", "$I", emptyStrings())
        ,
        /** $J: 午後5時まで */
        $J("J", "$J", emptyStrings())
        ;
        private static final Map<String, DelivTz> _codeClsMap = new HashMap<String, DelivTz>();
        private static final Map<String, DelivTz> _nameClsMap = new HashMap<String, DelivTz>();
        static {
            for (DelivTz value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DelivTz(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DelivTz; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivTz> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DelivTz) { return OptionalThing.of((DelivTz)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivTz> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DelivTz codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DelivTz) { return (DelivTz)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DelivTz nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DelivTz> listAll() {
            return new ArrayList<DelivTz>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DelivTz> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DelivTz." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DelivTz> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DelivTz> clsList = new ArrayList<DelivTz>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DelivTz> groupOf(String groupName) {
            return new ArrayList<DelivTz>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 削除フラグ
     */
    public enum DelFlg implements CDef {
        /** $0: 未削除 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 削除済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DelFlg> _codeClsMap = new HashMap<String, DelFlg>();
        private static final Map<String, DelFlg> _nameClsMap = new HashMap<String, DelFlg>();
        static {
            for (DelFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DelFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DelFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DelFlg) { return OptionalThing.of((DelFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DelFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DelFlg) { return (DelFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DelFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DelFlg> listAll() {
            return new ArrayList<DelFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DelFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DelFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DelFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DelFlg> clsList = new ArrayList<DelFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DelFlg> groupOf(String groupName) {
            return new ArrayList<DelFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 預託先フラグ
     */
    public enum DepositFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DepositFlg> _codeClsMap = new HashMap<String, DepositFlg>();
        private static final Map<String, DepositFlg> _nameClsMap = new HashMap<String, DepositFlg>();
        static {
            for (DepositFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DepositFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DepositFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DepositFlg) { return OptionalThing.of((DepositFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DepositFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DepositFlg) { return (DepositFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DepositFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DepositFlg> listAll() {
            return new ArrayList<DepositFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DepositFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DepositFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DepositFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DepositFlg> clsList = new ArrayList<DepositFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DepositFlg> groupOf(String groupName) {
            return new ArrayList<DepositFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 表示必須
     */
    public enum DisplayRequired implements CDef {
        /** $0: 任意 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 必須 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DisplayRequired> _codeClsMap = new HashMap<String, DisplayRequired>();
        private static final Map<String, DisplayRequired> _nameClsMap = new HashMap<String, DisplayRequired>();
        static {
            for (DisplayRequired value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DisplayRequired(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DisplayRequired; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DisplayRequired> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DisplayRequired) { return OptionalThing.of((DisplayRequired)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DisplayRequired> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DisplayRequired codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DisplayRequired) { return (DisplayRequired)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DisplayRequired nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DisplayRequired> listAll() {
            return new ArrayList<DisplayRequired>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DisplayRequired> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DisplayRequired." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DisplayRequired> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DisplayRequired> clsList = new ArrayList<DisplayRequired>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DisplayRequired> groupOf(String groupName) {
            return new ArrayList<DisplayRequired>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 日付区分
     */
    public enum DtCls implements CDef {
        /** $0: 取込日 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷日 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 作業日 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, DtCls> _codeClsMap = new HashMap<String, DtCls>();
        private static final Map<String, DtCls> _nameClsMap = new HashMap<String, DtCls>();
        static {
            for (DtCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DtCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DtCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DtCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DtCls) { return OptionalThing.of((DtCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DtCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DtCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DtCls) { return (DtCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DtCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DtCls> listAll() {
            return new ArrayList<DtCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DtCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DtCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DtCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DtCls> clsList = new ArrayList<DtCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DtCls> groupOf(String groupName) {
            return new ArrayList<DtCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 編集可否
     */
    public enum Editable implements CDef {
        /** $0: 編集不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 編集可 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Editable> _codeClsMap = new HashMap<String, Editable>();
        private static final Map<String, Editable> _nameClsMap = new HashMap<String, Editable>();
        static {
            for (Editable value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Editable(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Editable; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Editable> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Editable) { return OptionalThing.of((Editable)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Editable> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Editable codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Editable) { return (Editable)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Editable nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Editable> listAll() {
            return new ArrayList<Editable>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Editable> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Editable." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Editable> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Editable> clsList = new ArrayList<Editable>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Editable> groupOf(String groupName) {
            return new ArrayList<Editable>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 緊急表示区分
     */
    public enum EmergencyDisplay implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 緊急のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, EmergencyDisplay> _codeClsMap = new HashMap<String, EmergencyDisplay>();
        private static final Map<String, EmergencyDisplay> _nameClsMap = new HashMap<String, EmergencyDisplay>();
        static {
            for (EmergencyDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private EmergencyDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.EmergencyDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmergencyDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof EmergencyDisplay) { return OptionalThing.of((EmergencyDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmergencyDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static EmergencyDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof EmergencyDisplay) { return (EmergencyDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static EmergencyDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<EmergencyDisplay> listAll() {
            return new ArrayList<EmergencyDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<EmergencyDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: EmergencyDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<EmergencyDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<EmergencyDisplay> clsList = new ArrayList<EmergencyDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<EmergencyDisplay> groupOf(String groupName) {
            return new ArrayList<EmergencyDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 緊急フラグ
     */
    public enum EmergencyFlg implements CDef {
        /** $0: 通常 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 緊急 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, EmergencyFlg> _codeClsMap = new HashMap<String, EmergencyFlg>();
        private static final Map<String, EmergencyFlg> _nameClsMap = new HashMap<String, EmergencyFlg>();
        static {
            for (EmergencyFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private EmergencyFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.EmergencyFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmergencyFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof EmergencyFlg) { return OptionalThing.of((EmergencyFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmergencyFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static EmergencyFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof EmergencyFlg) { return (EmergencyFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static EmergencyFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<EmergencyFlg> listAll() {
            return new ArrayList<EmergencyFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<EmergencyFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: EmergencyFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<EmergencyFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<EmergencyFlg> clsList = new ArrayList<EmergencyFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<EmergencyFlg> groupOf(String groupName) {
            return new ArrayList<EmergencyFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * エラーフラグ
     */
    public enum ErrorFlg implements CDef {
        /** $0: エラー無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: エラー有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ErrorFlg> _codeClsMap = new HashMap<String, ErrorFlg>();
        private static final Map<String, ErrorFlg> _nameClsMap = new HashMap<String, ErrorFlg>();
        static {
            for (ErrorFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ErrorFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ErrorFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ErrorFlg) { return OptionalThing.of((ErrorFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ErrorFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ErrorFlg) { return (ErrorFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ErrorFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ErrorFlg> listAll() {
            return new ArrayList<ErrorFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ErrorFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ErrorFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ErrorFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ErrorFlg> clsList = new ArrayList<ErrorFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ErrorFlg> groupOf(String groupName) {
            return new ArrayList<ErrorFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * エラー処理方法
     */
    public enum ErrorProcessMet implements CDef {
        /** $0: 全て取込まない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: エラー以外を取り込む */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ErrorProcessMet> _codeClsMap = new HashMap<String, ErrorProcessMet>();
        private static final Map<String, ErrorProcessMet> _nameClsMap = new HashMap<String, ErrorProcessMet>();
        static {
            for (ErrorProcessMet value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ErrorProcessMet(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ErrorProcessMet; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorProcessMet> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ErrorProcessMet) { return OptionalThing.of((ErrorProcessMet)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorProcessMet> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ErrorProcessMet codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ErrorProcessMet) { return (ErrorProcessMet)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ErrorProcessMet nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ErrorProcessMet> listAll() {
            return new ArrayList<ErrorProcessMet>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ErrorProcessMet> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ErrorProcessMet." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ErrorProcessMet> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ErrorProcessMet> clsList = new ArrayList<ErrorProcessMet>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ErrorProcessMet> groupOf(String groupName) {
            return new ArrayList<ErrorProcessMet>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 定点切れ
     */
    public enum FixedPoint implements CDef {
        /** $0: 定点切れのみ表示 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, FixedPoint> _codeClsMap = new HashMap<String, FixedPoint>();
        private static final Map<String, FixedPoint> _nameClsMap = new HashMap<String, FixedPoint>();
        static {
            for (FixedPoint value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FixedPoint(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FixedPoint; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FixedPoint> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FixedPoint) { return OptionalThing.of((FixedPoint)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FixedPoint> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FixedPoint codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FixedPoint) { return (FixedPoint)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FixedPoint nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FixedPoint> listAll() {
            return new ArrayList<FixedPoint>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FixedPoint> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FixedPoint." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FixedPoint> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FixedPoint> clsList = new ArrayList<FixedPoint>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FixedPoint> groupOf(String groupName) {
            return new ArrayList<FixedPoint>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 強制確定フラグ
     */
    public enum ForceFixedFlg implements CDef {
        /** $0: 通常確定 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 強制確定 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ForceFixedFlg> _codeClsMap = new HashMap<String, ForceFixedFlg>();
        private static final Map<String, ForceFixedFlg> _nameClsMap = new HashMap<String, ForceFixedFlg>();
        static {
            for (ForceFixedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ForceFixedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ForceFixedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ForceFixedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ForceFixedFlg) { return OptionalThing.of((ForceFixedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ForceFixedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ForceFixedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ForceFixedFlg) { return (ForceFixedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ForceFixedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ForceFixedFlg> listAll() {
            return new ArrayList<ForceFixedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ForceFixedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ForceFixedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ForceFixedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ForceFixedFlg> clsList = new ArrayList<ForceFixedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ForceFixedFlg> groupOf(String groupName) {
            return new ArrayList<ForceFixedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 外貨フラグ
     */
    public enum ForeignFlg implements CDef {
        /** $0: 内貨 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 外貨 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ForeignFlg> _codeClsMap = new HashMap<String, ForeignFlg>();
        private static final Map<String, ForeignFlg> _nameClsMap = new HashMap<String, ForeignFlg>();
        static {
            for (ForeignFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ForeignFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ForeignFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ForeignFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ForeignFlg) { return OptionalThing.of((ForeignFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ForeignFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ForeignFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ForeignFlg) { return (ForeignFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ForeignFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ForeignFlg> listAll() {
            return new ArrayList<ForeignFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ForeignFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ForeignFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ForeignFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ForeignFlg> clsList = new ArrayList<ForeignFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ForeignFlg> groupOf(String groupName) {
            return new ArrayList<ForeignFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ギフトフラグ
     */
    public enum GiftFlg implements CDef {
        /** $0: ギフト指定無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ギフト指定有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, GiftFlg> _codeClsMap = new HashMap<String, GiftFlg>();
        private static final Map<String, GiftFlg> _nameClsMap = new HashMap<String, GiftFlg>();
        static {
            for (GiftFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private GiftFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.GiftFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GiftFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof GiftFlg) { return OptionalThing.of((GiftFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GiftFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static GiftFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof GiftFlg) { return (GiftFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static GiftFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<GiftFlg> listAll() {
            return new ArrayList<GiftFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<GiftFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: GiftFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<GiftFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<GiftFlg> clsList = new ArrayList<GiftFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<GiftFlg> groupOf(String groupName) {
            return new ArrayList<GiftFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ギフト用納品書種別
     */
    public enum GiftStatementType implements CDef {
        /** $0: 通常 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 金額非表示 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 明細非表示 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, GiftStatementType> _codeClsMap = new HashMap<String, GiftStatementType>();
        private static final Map<String, GiftStatementType> _nameClsMap = new HashMap<String, GiftStatementType>();
        static {
            for (GiftStatementType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private GiftStatementType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.GiftStatementType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GiftStatementType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof GiftStatementType) { return OptionalThing.of((GiftStatementType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GiftStatementType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static GiftStatementType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof GiftStatementType) { return (GiftStatementType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static GiftStatementType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<GiftStatementType> listAll() {
            return new ArrayList<GiftStatementType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<GiftStatementType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: GiftStatementType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<GiftStatementType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<GiftStatementType> clsList = new ArrayList<GiftStatementType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<GiftStatementType> groupOf(String groupName) {
            return new ArrayList<GiftStatementType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * HT文字認識使用フラグ
     */
    public enum HtCharReadFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, HtCharReadFlg> _codeClsMap = new HashMap<String, HtCharReadFlg>();
        private static final Map<String, HtCharReadFlg> _nameClsMap = new HashMap<String, HtCharReadFlg>();
        static {
            for (HtCharReadFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HtCharReadFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HtCharReadFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HtCharReadFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HtCharReadFlg) { return OptionalThing.of((HtCharReadFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HtCharReadFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HtCharReadFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HtCharReadFlg) { return (HtCharReadFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HtCharReadFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HtCharReadFlg> listAll() {
            return new ArrayList<HtCharReadFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HtCharReadFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HtCharReadFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HtCharReadFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HtCharReadFlg> clsList = new ArrayList<HtCharReadFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HtCharReadFlg> groupOf(String groupName) {
            return new ArrayList<HtCharReadFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 取込みフラグ
     */
    public enum ImportFlg implements CDef {
        /** $0: 未取込 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 取込済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ImportFlg> _codeClsMap = new HashMap<String, ImportFlg>();
        private static final Map<String, ImportFlg> _nameClsMap = new HashMap<String, ImportFlg>();
        static {
            for (ImportFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ImportFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ImportFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ImportFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ImportFlg) { return OptionalThing.of((ImportFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ImportFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ImportFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ImportFlg) { return (ImportFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ImportFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ImportFlg> listAll() {
            return new ArrayList<ImportFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ImportFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ImportFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ImportFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ImportFlg> clsList = new ArrayList<ImportFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ImportFlg> groupOf(String groupName) {
            return new ArrayList<ImportFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 終了したお知らせの表示
     */
    public enum InfoFlg implements CDef {
        /** $0: 表示する */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示しない */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InfoFlg> _codeClsMap = new HashMap<String, InfoFlg>();
        private static final Map<String, InfoFlg> _nameClsMap = new HashMap<String, InfoFlg>();
        static {
            for (InfoFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InfoFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InfoFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InfoFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InfoFlg) { return OptionalThing.of((InfoFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InfoFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InfoFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InfoFlg) { return (InfoFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InfoFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InfoFlg> listAll() {
            return new ArrayList<InfoFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InfoFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InfoFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InfoFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InfoFlg> clsList = new ArrayList<InfoFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InfoFlg> groupOf(String groupName) {
            return new ArrayList<InfoFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入出庫区分
     */
    public enum InoutType implements CDef {
        /** $0: 入庫 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出庫 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InoutType> _codeClsMap = new HashMap<String, InoutType>();
        private static final Map<String, InoutType> _nameClsMap = new HashMap<String, InoutType>();
        static {
            for (InoutType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InoutType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InoutType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InoutType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InoutType) { return OptionalThing.of((InoutType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InoutType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InoutType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InoutType) { return (InoutType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InoutType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InoutType> listAll() {
            return new ArrayList<InoutType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InoutType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InoutType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InoutType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InoutType> clsList = new ArrayList<InoutType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InoutType> groupOf(String groupName) {
            return new ArrayList<InoutType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入力区分
     */
    public enum InputType implements CDef {
        /** $00: 画面入力 */
        $00("00", "$00", emptyStrings())
        ,
        /** $10: アップロード */
        $10("10", "$10", emptyStrings())
        ,
        /** $20: EDI */
        $20("20", "$20", emptyStrings())
        ,
        /** $30: HT */
        $30("30", "$30", emptyStrings())
        ;
        private static final Map<String, InputType> _codeClsMap = new HashMap<String, InputType>();
        private static final Map<String, InputType> _nameClsMap = new HashMap<String, InputType>();
        static {
            for (InputType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InputType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InputType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InputType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InputType) { return OptionalThing.of((InputType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InputType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InputType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InputType) { return (InputType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InputType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InputType> listAll() {
            return new ArrayList<InputType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InputType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InputType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InputType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InputType> clsList = new ArrayList<InputType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InputType> groupOf(String groupName) {
            return new ArrayList<InputType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検品フラグ
     */
    public enum InspectionFlg implements CDef {
        /** $0: 未検品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 検品済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $7: 検品作業中 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, InspectionFlg> _codeClsMap = new HashMap<String, InspectionFlg>();
        private static final Map<String, InspectionFlg> _nameClsMap = new HashMap<String, InspectionFlg>();
        static {
            for (InspectionFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InspectionFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InspectionFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InspectionFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InspectionFlg) { return OptionalThing.of((InspectionFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InspectionFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InspectionFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InspectionFlg) { return (InspectionFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InspectionFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InspectionFlg> listAll() {
            return new ArrayList<InspectionFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InspectionFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InspectionFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InspectionFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InspectionFlg> clsList = new ArrayList<InspectionFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InspectionFlg> groupOf(String groupName) {
            return new ArrayList<InspectionFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 比較条件差異
     */
    public enum InventoryLocationProduct implements CDef {
        /** $0: 商品単位の差異 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ロケーション単位の差異 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InventoryLocationProduct> _codeClsMap = new HashMap<String, InventoryLocationProduct>();
        private static final Map<String, InventoryLocationProduct> _nameClsMap = new HashMap<String, InventoryLocationProduct>();
        static {
            for (InventoryLocationProduct value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InventoryLocationProduct(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InventoryLocationProduct; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryLocationProduct> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InventoryLocationProduct) { return OptionalThing.of((InventoryLocationProduct)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryLocationProduct> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InventoryLocationProduct codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InventoryLocationProduct) { return (InventoryLocationProduct)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InventoryLocationProduct nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InventoryLocationProduct> listAll() {
            return new ArrayList<InventoryLocationProduct>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InventoryLocationProduct> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InventoryLocationProduct." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InventoryLocationProduct> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InventoryLocationProduct> clsList = new ArrayList<InventoryLocationProduct>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InventoryLocationProduct> groupOf(String groupName) {
            return new ArrayList<InventoryLocationProduct>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状データ出力フラグ
     */
    public enum InvoiceCreateFlg implements CDef {
        /** $0: 未出力 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InvoiceCreateFlg> _codeClsMap = new HashMap<String, InvoiceCreateFlg>();
        private static final Map<String, InvoiceCreateFlg> _nameClsMap = new HashMap<String, InvoiceCreateFlg>();
        static {
            for (InvoiceCreateFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InvoiceCreateFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InvoiceCreateFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InvoiceCreateFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InvoiceCreateFlg) { return OptionalThing.of((InvoiceCreateFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InvoiceCreateFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InvoiceCreateFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InvoiceCreateFlg) { return (InvoiceCreateFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InvoiceCreateFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InvoiceCreateFlg> listAll() {
            return new ArrayList<InvoiceCreateFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InvoiceCreateFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InvoiceCreateFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InvoiceCreateFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InvoiceCreateFlg> clsList = new ArrayList<InvoiceCreateFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InvoiceCreateFlg> groupOf(String groupName) {
            return new ArrayList<InvoiceCreateFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 項目型
     */
    public enum ItemType implements CDef {
        /** $checkbox: チェックボックス */
        $checkbox("checkbox", "$checkbox", emptyStrings())
        ,
        /** $date: 日付 */
        $date("date", "$date", emptyStrings())
        ,
        /** $datetime: 日時 */
        $datetime("datetime", "$datetime", emptyStrings())
        ,
        /** $dropdown: コンボボックス */
        $dropdown("dropdown", "$dropdown", emptyStrings())
        ,
        /** $grid: グリッド */
        $grid("grid", "$grid", emptyStrings())
        ,
        /** $number: 数値 */
        $number("number", "$number", emptyStrings())
        ,
        /** $text: テキスト */
        $text("text", "$text", emptyStrings())
        ;
        private static final Map<String, ItemType> _codeClsMap = new HashMap<String, ItemType>();
        private static final Map<String, ItemType> _nameClsMap = new HashMap<String, ItemType>();
        static {
            for (ItemType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ItemType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ItemType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItemType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ItemType) { return OptionalThing.of((ItemType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItemType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ItemType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ItemType) { return (ItemType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ItemType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ItemType> listAll() {
            return new ArrayList<ItemType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ItemType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ItemType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ItemType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ItemType> clsList = new ArrayList<ItemType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ItemType> groupOf(String groupName) {
            return new ArrayList<ItemType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最新フラグ
     */
    public enum LastFlg implements CDef {
        /** $0: 最新でない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 最新 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LastFlg> _codeClsMap = new HashMap<String, LastFlg>();
        private static final Map<String, LastFlg> _nameClsMap = new HashMap<String, LastFlg>();
        static {
            for (LastFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LastFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LastFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LastFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LastFlg) { return OptionalThing.of((LastFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LastFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LastFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LastFlg) { return (LastFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LastFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LastFlg> listAll() {
            return new ArrayList<LastFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LastFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LastFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LastFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LastFlg> clsList = new ArrayList<LastFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LastFlg> groupOf(String groupName) {
            return new ArrayList<LastFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 期限日管理フラグ
     */
    public enum LimitDtManagFlg implements CDef {
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LimitDtManagFlg> _codeClsMap = new HashMap<String, LimitDtManagFlg>();
        private static final Map<String, LimitDtManagFlg> _nameClsMap = new HashMap<String, LimitDtManagFlg>();
        static {
            for (LimitDtManagFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitDtManagFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitDtManagFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtManagFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitDtManagFlg) { return OptionalThing.of((LimitDtManagFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtManagFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitDtManagFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitDtManagFlg) { return (LimitDtManagFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitDtManagFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitDtManagFlg> listAll() {
            return new ArrayList<LimitDtManagFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitDtManagFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitDtManagFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitDtManagFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitDtManagFlg> clsList = new ArrayList<LimitDtManagFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitDtManagFlg> groupOf(String groupName) {
            return new ArrayList<LimitDtManagFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 期限日逆転防止フラグ
     */
    public enum LimitDtReverseFlg implements CDef {
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LimitDtReverseFlg> _codeClsMap = new HashMap<String, LimitDtReverseFlg>();
        private static final Map<String, LimitDtReverseFlg> _nameClsMap = new HashMap<String, LimitDtReverseFlg>();
        static {
            for (LimitDtReverseFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitDtReverseFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitDtReverseFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtReverseFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitDtReverseFlg) { return OptionalThing.of((LimitDtReverseFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtReverseFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitDtReverseFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitDtReverseFlg) { return (LimitDtReverseFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitDtReverseFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitDtReverseFlg> listAll() {
            return new ArrayList<LimitDtReverseFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitDtReverseFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitDtReverseFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitDtReverseFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitDtReverseFlg> clsList = new ArrayList<LimitDtReverseFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitDtReverseFlg> groupOf(String groupName) {
            return new ArrayList<LimitDtReverseFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 制限メッセージCD
     */
    public enum LimitMessageCd implements CDef {
        /** $inputLimitCheckAlphabetAndHyphenOnlyError: 英字と-のみメッセージCD */
        $inputLimitCheckAlphabetAndHyphenOnlyError("inputLimitCheckAlphabetAndHyphenOnlyError", "$inputLimitCheckAlphabetAndHyphenOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckAlphabetAndNumericAndHyphenOnlyError: 英数字と-のみメッセージCD */
        $inputLimitCheckAlphabetAndNumericAndHyphenOnlyError("inputLimitCheckAlphabetAndNumericAndHyphenOnlyError", "$inputLimitCheckAlphabetAndNumericAndHyphenOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckAlphabetAndNumericAndSymbolOnlyError: 英数字と記号(半角カタカナ,SPを除く)メッセージCD */
        $inputLimitCheckAlphabetAndNumericAndSymbolOnlyError("inputLimitCheckAlphabetAndNumericAndSymbolOnlyError", "$inputLimitCheckAlphabetAndNumericAndSymbolOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckAlphabetAndNumericOnlyError: 英数字のみメッセージCD */
        $inputLimitCheckAlphabetAndNumericOnlyError("inputLimitCheckAlphabetAndNumericOnlyError", "$inputLimitCheckAlphabetAndNumericOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckAlphabetOnlyError: 英字のみメッセージCD */
        $inputLimitCheckAlphabetOnlyError("inputLimitCheckAlphabetOnlyError", "$inputLimitCheckAlphabetOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckFullWidthOnlyError: 全角文字のみメッセージCD */
        $inputLimitCheckFullWidthOnlyError("inputLimitCheckFullWidthOnlyError", "$inputLimitCheckFullWidthOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckHalfWidthOnlyError: 半角文字のみメッセージCD */
        $inputLimitCheckHalfWidthOnlyError("inputLimitCheckHalfWidthOnlyError", "$inputLimitCheckHalfWidthOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckNumericAndHyphenOnlyError: 数字と-のみ(電話番号等)メッセージCD */
        $inputLimitCheckNumericAndHyphenOnlyError("inputLimitCheckNumericAndHyphenOnlyError", "$inputLimitCheckNumericAndHyphenOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckNumericOnlyError: 数字のみメッセージCD */
        $inputLimitCheckNumericOnlyError("inputLimitCheckNumericOnlyError", "$inputLimitCheckNumericOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckTimeHHMMSSOnlyError: 時刻のみ(hh24:mm:ss)メッセージCD */
        $inputLimitCheckTimeHHMMSSOnlyError("inputLimitCheckTimeHHMMSSOnlyError", "$inputLimitCheckTimeHHMMSSOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckTimeOnlyError: 時刻のみ(hh24:mm)メッセージCD */
        $inputLimitCheckTimeOnlyError("inputLimitCheckTimeOnlyError", "$inputLimitCheckTimeOnlyError", emptyStrings())
        ;
        private static final Map<String, LimitMessageCd> _codeClsMap = new HashMap<String, LimitMessageCd>();
        private static final Map<String, LimitMessageCd> _nameClsMap = new HashMap<String, LimitMessageCd>();
        static {
            for (LimitMessageCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitMessageCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitMessageCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitMessageCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitMessageCd) { return OptionalThing.of((LimitMessageCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitMessageCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitMessageCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitMessageCd) { return (LimitMessageCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitMessageCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitMessageCd> listAll() {
            return new ArrayList<LimitMessageCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitMessageCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitMessageCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitMessageCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitMessageCd> clsList = new ArrayList<LimitMessageCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitMessageCd> groupOf(String groupName) {
            return new ArrayList<LimitMessageCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 改行コード
     */
    public enum LineFeedCd implements CDef {
        /** $1: CRLF */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: CR */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: LF */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LineFeedCd> _codeClsMap = new HashMap<String, LineFeedCd>();
        private static final Map<String, LineFeedCd> _nameClsMap = new HashMap<String, LineFeedCd>();
        static {
            for (LineFeedCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LineFeedCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LineFeedCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LineFeedCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LineFeedCd) { return OptionalThing.of((LineFeedCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LineFeedCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LineFeedCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LineFeedCd) { return (LineFeedCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LineFeedCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LineFeedCd> listAll() {
            return new ArrayList<LineFeedCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LineFeedCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LineFeedCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LineFeedCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LineFeedCd> clsList = new ArrayList<LineFeedCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LineFeedCd> groupOf(String groupName) {
            return new ArrayList<LineFeedCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * リスト発行フラグ
     */
    public enum ListOutFlg implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ListOutFlg> _codeClsMap = new HashMap<String, ListOutFlg>();
        private static final Map<String, ListOutFlg> _nameClsMap = new HashMap<String, ListOutFlg>();
        static {
            for (ListOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ListOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ListOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ListOutFlg) { return OptionalThing.of((ListOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ListOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ListOutFlg) { return (ListOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ListOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ListOutFlg> listAll() {
            return new ArrayList<ListOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ListOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ListOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ListOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ListOutFlg> clsList = new ArrayList<ListOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ListOutFlg> groupOf(String groupName) {
            return new ArrayList<ListOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * リスト発行フラグ(一覧表示用)
     */
    public enum ListOutFlgDisp implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 一部発行済 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ListOutFlgDisp> _codeClsMap = new HashMap<String, ListOutFlgDisp>();
        private static final Map<String, ListOutFlgDisp> _nameClsMap = new HashMap<String, ListOutFlgDisp>();
        static {
            for (ListOutFlgDisp value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ListOutFlgDisp(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ListOutFlgDisp; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutFlgDisp> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ListOutFlgDisp) { return OptionalThing.of((ListOutFlgDisp)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutFlgDisp> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ListOutFlgDisp codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ListOutFlgDisp) { return (ListOutFlgDisp)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ListOutFlgDisp nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ListOutFlgDisp> listAll() {
            return new ArrayList<ListOutFlgDisp>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ListOutFlgDisp> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ListOutFlgDisp." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ListOutFlgDisp> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ListOutFlgDisp> clsList = new ArrayList<ListOutFlgDisp>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ListOutFlgDisp> groupOf(String groupName) {
            return new ArrayList<ListOutFlgDisp>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 発行区分
     */
    public enum ListOutKbn implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 全件 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ListOutKbn> _codeClsMap = new HashMap<String, ListOutKbn>();
        private static final Map<String, ListOutKbn> _nameClsMap = new HashMap<String, ListOutKbn>();
        static {
            for (ListOutKbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ListOutKbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ListOutKbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutKbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ListOutKbn) { return OptionalThing.of((ListOutKbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutKbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ListOutKbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ListOutKbn) { return (ListOutKbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ListOutKbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ListOutKbn> listAll() {
            return new ArrayList<ListOutKbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ListOutKbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ListOutKbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ListOutKbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ListOutKbn> clsList = new ArrayList<ListOutKbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ListOutKbn> groupOf(String groupName) {
            return new ArrayList<ListOutKbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 積込フラグ
     */
    public enum LoadingFlg implements CDef {
        /** $0: 未検品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 検品済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LoadingFlg> _codeClsMap = new HashMap<String, LoadingFlg>();
        private static final Map<String, LoadingFlg> _nameClsMap = new HashMap<String, LoadingFlg>();
        static {
            for (LoadingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LoadingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LoadingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LoadingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LoadingFlg) { return OptionalThing.of((LoadingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LoadingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LoadingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LoadingFlg) { return (LoadingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LoadingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LoadingFlg> listAll() {
            return new ArrayList<LoadingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LoadingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LoadingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LoadingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LoadingFlg> clsList = new ArrayList<LoadingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LoadingFlg> groupOf(String groupName) {
            return new ArrayList<LoadingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロケーション種別
     */
    public enum LocationType implements CDef {
        /** $00: 通常ロケーション */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 入庫仮ロケーション */
        $01("01", "$01", emptyStrings())
        ;
        private static final Map<String, LocationType> _codeClsMap = new HashMap<String, LocationType>();
        private static final Map<String, LocationType> _nameClsMap = new HashMap<String, LocationType>();
        static {
            for (LocationType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LocationType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LocationType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LocationType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LocationType) { return OptionalThing.of((LocationType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LocationType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LocationType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LocationType) { return (LocationType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LocationType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LocationType> listAll() {
            return new ArrayList<LocationType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LocationType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LocationType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LocationType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LocationType> clsList = new ArrayList<LocationType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LocationType> groupOf(String groupName) {
            return new ArrayList<LocationType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロックアウト
     */
    public enum Lockout implements CDef {
        /** $0: アンロック */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ロックアウト */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Lockout> _codeClsMap = new HashMap<String, Lockout>();
        private static final Map<String, Lockout> _nameClsMap = new HashMap<String, Lockout>();
        static {
            for (Lockout value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Lockout(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Lockout; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Lockout> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Lockout) { return OptionalThing.of((Lockout)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Lockout> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Lockout codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Lockout) { return (Lockout)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Lockout nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Lockout> listAll() {
            return new ArrayList<Lockout>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Lockout> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Lockout." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Lockout> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Lockout> clsList = new ArrayList<Lockout>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Lockout> groupOf(String groupName) {
            return new ArrayList<Lockout>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ログ明細ステータス
     */
    public enum LogDtlStatus implements CDef {
        /** $1: 情報 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 警告 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: エラー */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LogDtlStatus> _codeClsMap = new HashMap<String, LogDtlStatus>();
        private static final Map<String, LogDtlStatus> _nameClsMap = new HashMap<String, LogDtlStatus>();
        static {
            for (LogDtlStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LogDtlStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LogDtlStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogDtlStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LogDtlStatus) { return OptionalThing.of((LogDtlStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogDtlStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LogDtlStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LogDtlStatus) { return (LogDtlStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LogDtlStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LogDtlStatus> listAll() {
            return new ArrayList<LogDtlStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LogDtlStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LogDtlStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LogDtlStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LogDtlStatus> clsList = new ArrayList<LogDtlStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LogDtlStatus> groupOf(String groupName) {
            return new ArrayList<LogDtlStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ログ明細種別
     */
    public enum LogDtlType implements CDef {
        /** $1: セクション開始ログ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: セクション終了ログ */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 明細ログ */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 基盤出力ログ */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, LogDtlType> _codeClsMap = new HashMap<String, LogDtlType>();
        private static final Map<String, LogDtlType> _nameClsMap = new HashMap<String, LogDtlType>();
        static {
            for (LogDtlType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LogDtlType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LogDtlType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogDtlType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LogDtlType) { return OptionalThing.of((LogDtlType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogDtlType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LogDtlType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LogDtlType) { return (LogDtlType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LogDtlType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LogDtlType> listAll() {
            return new ArrayList<LogDtlType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LogDtlType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LogDtlType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LogDtlType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LogDtlType> clsList = new ArrayList<LogDtlType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LogDtlType> groupOf(String groupName) {
            return new ArrayList<LogDtlType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ログステータス
     */
    public enum LogStatus implements CDef {
        /** $1: 処理中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 正常終了 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 異常終了 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LogStatus> _codeClsMap = new HashMap<String, LogStatus>();
        private static final Map<String, LogStatus> _nameClsMap = new HashMap<String, LogStatus>();
        static {
            for (LogStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LogStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LogStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LogStatus) { return OptionalThing.of((LogStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LogStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LogStatus) { return (LogStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LogStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LogStatus> listAll() {
            return new ArrayList<LogStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LogStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LogStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LogStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LogStatus> clsList = new ArrayList<LogStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LogStatus> groupOf(String groupName) {
            return new ArrayList<LogStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロット管理フラグ
     */
    public enum LotManagFlg implements CDef {
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LotManagFlg> _codeClsMap = new HashMap<String, LotManagFlg>();
        private static final Map<String, LotManagFlg> _nameClsMap = new HashMap<String, LotManagFlg>();
        static {
            for (LotManagFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LotManagFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LotManagFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotManagFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LotManagFlg) { return OptionalThing.of((LotManagFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotManagFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LotManagFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LotManagFlg) { return (LotManagFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LotManagFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LotManagFlg> listAll() {
            return new ArrayList<LotManagFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LotManagFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LotManagFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LotManagFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LotManagFlg> clsList = new ArrayList<LotManagFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LotManagFlg> groupOf(String groupName) {
            return new ArrayList<LotManagFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロット逆転防止フラグ
     */
    public enum LotReverseFlg implements CDef {
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LotReverseFlg> _codeClsMap = new HashMap<String, LotReverseFlg>();
        private static final Map<String, LotReverseFlg> _nameClsMap = new HashMap<String, LotReverseFlg>();
        static {
            for (LotReverseFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LotReverseFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LotReverseFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotReverseFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LotReverseFlg) { return OptionalThing.of((LotReverseFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotReverseFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LotReverseFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LotReverseFlg) { return (LotReverseFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LotReverseFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LotReverseFlg> listAll() {
            return new ArrayList<LotReverseFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LotReverseFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LotReverseFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LotReverseFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LotReverseFlg> clsList = new ArrayList<LotReverseFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LotReverseFlg> groupOf(String groupName) {
            return new ArrayList<LotReverseFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫No.マージ区分
     */
    public enum MergeCls implements CDef {
        /** $00: マージしない */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: ピックロケのみ自動マージ */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 自動マージ */
        $02("02", "$02", emptyStrings())
        ;
        private static final Map<String, MergeCls> _codeClsMap = new HashMap<String, MergeCls>();
        private static final Map<String, MergeCls> _nameClsMap = new HashMap<String, MergeCls>();
        static {
            for (MergeCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MergeCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MergeCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MergeCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MergeCls) { return OptionalThing.of((MergeCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MergeCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MergeCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MergeCls) { return (MergeCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MergeCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MergeCls> listAll() {
            return new ArrayList<MergeCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MergeCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MergeCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MergeCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MergeCls> clsList = new ArrayList<MergeCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MergeCls> groupOf(String groupName) {
            return new ArrayList<MergeCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 名寄せ有無
     */
    public enum MergeFlg implements CDef {
        /** $0: 名寄せ無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 名寄せ有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, MergeFlg> _codeClsMap = new HashMap<String, MergeFlg>();
        private static final Map<String, MergeFlg> _nameClsMap = new HashMap<String, MergeFlg>();
        static {
            for (MergeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MergeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MergeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MergeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MergeFlg) { return OptionalThing.of((MergeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MergeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MergeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MergeFlg) { return (MergeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MergeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MergeFlg> listAll() {
            return new ArrayList<MergeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MergeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MergeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MergeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MergeFlg> clsList = new ArrayList<MergeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MergeFlg> groupOf(String groupName) {
            return new ArrayList<MergeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 属性
     */
    public enum MessageType implements CDef {
        /** $confirm: 確認 */
        $confirm("confirm", "$confirm", emptyStrings())
        ,
        /** $error: エラー */
        $error("error", "$error", emptyStrings())
        ,
        /** $info: 情報 */
        $info("info", "$info", emptyStrings())
        ,
        /** $warn: 警告 */
        $warn("warn", "$warn", emptyStrings())
        ;
        private static final Map<String, MessageType> _codeClsMap = new HashMap<String, MessageType>();
        private static final Map<String, MessageType> _nameClsMap = new HashMap<String, MessageType>();
        static {
            for (MessageType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MessageType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MessageType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MessageType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MessageType) { return OptionalThing.of((MessageType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MessageType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MessageType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MessageType) { return (MessageType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MessageType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MessageType> listAll() {
            return new ArrayList<MessageType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MessageType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MessageType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MessageType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MessageType> clsList = new ArrayList<MessageType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MessageType> groupOf(String groupName) {
            return new ArrayList<MessageType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 混載フラグ
     */
    public enum MixedFlg implements CDef {
        /** $0: 単品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 混載 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, MixedFlg> _codeClsMap = new HashMap<String, MixedFlg>();
        private static final Map<String, MixedFlg> _nameClsMap = new HashMap<String, MixedFlg>();
        static {
            for (MixedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MixedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MixedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MixedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MixedFlg) { return OptionalThing.of((MixedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MixedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MixedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MixedFlg) { return (MixedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MixedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MixedFlg> listAll() {
            return new ArrayList<MixedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MixedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MixedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MixedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MixedFlg> clsList = new ArrayList<MixedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MixedFlg> groupOf(String groupName) {
            return new ArrayList<MixedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫移動指示ステータス
     */
    public enum MoveInstStatus implements CDef {
        /** $00: 未作業 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 作業中 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 完了 */
        $02("02", "$02", emptyStrings())
        ,
        /** $99: 取消 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, MoveInstStatus> _codeClsMap = new HashMap<String, MoveInstStatus>();
        private static final Map<String, MoveInstStatus> _nameClsMap = new HashMap<String, MoveInstStatus>();
        static {
            for (MoveInstStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MoveInstStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MoveInstStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MoveInstStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MoveInstStatus) { return OptionalThing.of((MoveInstStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MoveInstStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MoveInstStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MoveInstStatus) { return (MoveInstStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MoveInstStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MoveInstStatus> listAll() {
            return new ArrayList<MoveInstStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MoveInstStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MoveInstStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MoveInstStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MoveInstStatus> clsList = new ArrayList<MoveInstStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MoveInstStatus> groupOf(String groupName) {
            return new ArrayList<MoveInstStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * マルチピック計算区分
     */
    public enum MultiPicCls implements CDef {
        /** $0: マルチピック計算無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: マルチピック計算有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, MultiPicCls> _codeClsMap = new HashMap<String, MultiPicCls>();
        private static final Map<String, MultiPicCls> _nameClsMap = new HashMap<String, MultiPicCls>();
        static {
            for (MultiPicCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MultiPicCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MultiPicCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MultiPicCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MultiPicCls) { return OptionalThing.of((MultiPicCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MultiPicCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MultiPicCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MultiPicCls) { return (MultiPicCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MultiPicCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MultiPicCls> listAll() {
            return new ArrayList<MultiPicCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MultiPicCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MultiPicCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MultiPicCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MultiPicCls> clsList = new ArrayList<MultiPicCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MultiPicCls> groupOf(String groupName) {
            return new ArrayList<MultiPicCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * マルチピック計算フラグ
     */
    public enum MultiPicFlg implements CDef {
        /** $0: 計算無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 計算有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, MultiPicFlg> _codeClsMap = new HashMap<String, MultiPicFlg>();
        private static final Map<String, MultiPicFlg> _nameClsMap = new HashMap<String, MultiPicFlg>();
        static {
            for (MultiPicFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MultiPicFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MultiPicFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MultiPicFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MultiPicFlg) { return OptionalThing.of((MultiPicFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MultiPicFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MultiPicFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MultiPicFlg) { return (MultiPicFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MultiPicFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MultiPicFlg> listAll() {
            return new ArrayList<MultiPicFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MultiPicFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MultiPicFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MultiPicFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MultiPicFlg> clsList = new ArrayList<MultiPicFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MultiPicFlg> groupOf(String groupName) {
            return new ArrayList<MultiPicFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 必須
     */
    public enum Necessary implements CDef {
        /** $0: 任意 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 必須 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Necessary> _codeClsMap = new HashMap<String, Necessary>();
        private static final Map<String, Necessary> _nameClsMap = new HashMap<String, Necessary>();
        static {
            for (Necessary value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Necessary(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Necessary; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Necessary> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Necessary) { return OptionalThing.of((Necessary)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Necessary> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Necessary codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Necessary) { return (Necessary)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Necessary nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Necessary> listAll() {
            return new ArrayList<Necessary>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Necessary> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Necessary." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Necessary> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Necessary> clsList = new ArrayList<Necessary>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Necessary> groupOf(String groupName) {
            return new ArrayList<Necessary>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未完了のみ表示
     */
    public enum NotCompletedFlg implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 未完了のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NotCompletedFlg> _codeClsMap = new HashMap<String, NotCompletedFlg>();
        private static final Map<String, NotCompletedFlg> _nameClsMap = new HashMap<String, NotCompletedFlg>();
        static {
            for (NotCompletedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NotCompletedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NotCompletedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NotCompletedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NotCompletedFlg) { return OptionalThing.of((NotCompletedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NotCompletedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NotCompletedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NotCompletedFlg) { return (NotCompletedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NotCompletedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NotCompletedFlg> listAll() {
            return new ArrayList<NotCompletedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NotCompletedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NotCompletedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NotCompletedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NotCompletedFlg> clsList = new ArrayList<NotCompletedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NotCompletedFlg> groupOf(String groupName) {
            return new ArrayList<NotCompletedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未出庫全件表示区分
     */
    public enum NoAllcDisplayFlg implements CDef {
        /** $0: 全件ではない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全件表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoAllcDisplayFlg> _codeClsMap = new HashMap<String, NoAllcDisplayFlg>();
        private static final Map<String, NoAllcDisplayFlg> _nameClsMap = new HashMap<String, NoAllcDisplayFlg>();
        static {
            for (NoAllcDisplayFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoAllcDisplayFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoAllcDisplayFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoAllcDisplayFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoAllcDisplayFlg) { return OptionalThing.of((NoAllcDisplayFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoAllcDisplayFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoAllcDisplayFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoAllcDisplayFlg) { return (NoAllcDisplayFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoAllcDisplayFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoAllcDisplayFlg> listAll() {
            return new ArrayList<NoAllcDisplayFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoAllcDisplayFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoAllcDisplayFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoAllcDisplayFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoAllcDisplayFlg> clsList = new ArrayList<NoAllcDisplayFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoAllcDisplayFlg> groupOf(String groupName) {
            return new ArrayList<NoAllcDisplayFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未確定のみ表示
     */
    public enum NoConfirmedFlg implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 未確定のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoConfirmedFlg> _codeClsMap = new HashMap<String, NoConfirmedFlg>();
        private static final Map<String, NoConfirmedFlg> _nameClsMap = new HashMap<String, NoConfirmedFlg>();
        static {
            for (NoConfirmedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoConfirmedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoConfirmedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoConfirmedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoConfirmedFlg) { return OptionalThing.of((NoConfirmedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoConfirmedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoConfirmedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoConfirmedFlg) { return (NoConfirmedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoConfirmedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoConfirmedFlg> listAll() {
            return new ArrayList<NoConfirmedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoConfirmedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoConfirmedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoConfirmedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoConfirmedFlg> clsList = new ArrayList<NoConfirmedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoConfirmedFlg> groupOf(String groupName) {
            return new ArrayList<NoConfirmedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 下積み厳禁区分
     */
    public enum NoStockCls implements CDef {
        /** $0: 無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoStockCls> _codeClsMap = new HashMap<String, NoStockCls>();
        private static final Map<String, NoStockCls> _nameClsMap = new HashMap<String, NoStockCls>();
        static {
            for (NoStockCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoStockCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoStockCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoStockCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoStockCls) { return OptionalThing.of((NoStockCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoStockCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoStockCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoStockCls) { return (NoStockCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoStockCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoStockCls> listAll() {
            return new ArrayList<NoStockCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoStockCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoStockCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoStockCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoStockCls> clsList = new ArrayList<NoStockCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoStockCls> groupOf(String groupName) {
            return new ArrayList<NoStockCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品無のみ表示
     */
    public enum NoStockOutFlg implements CDef {
        /** $0: 欠品無のみ表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 欠品有のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoStockOutFlg> _codeClsMap = new HashMap<String, NoStockOutFlg>();
        private static final Map<String, NoStockOutFlg> _nameClsMap = new HashMap<String, NoStockOutFlg>();
        static {
            for (NoStockOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoStockOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoStockOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoStockOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoStockOutFlg) { return OptionalThing.of((NoStockOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoStockOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoStockOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoStockOutFlg) { return (NoStockOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoStockOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoStockOutFlg> listAll() {
            return new ArrayList<NoStockOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoStockOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoStockOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoStockOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoStockOutFlg> clsList = new ArrayList<NoStockOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoStockOutFlg> groupOf(String groupName) {
            return new ArrayList<NoStockOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 逆さま厳禁区分
     */
    public enum NoUpsideDownCls implements CDef {
        /** $0: 無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoUpsideDownCls> _codeClsMap = new HashMap<String, NoUpsideDownCls>();
        private static final Map<String, NoUpsideDownCls> _nameClsMap = new HashMap<String, NoUpsideDownCls>();
        static {
            for (NoUpsideDownCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoUpsideDownCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoUpsideDownCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoUpsideDownCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoUpsideDownCls) { return OptionalThing.of((NoUpsideDownCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoUpsideDownCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoUpsideDownCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoUpsideDownCls) { return (NoUpsideDownCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoUpsideDownCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoUpsideDownCls> listAll() {
            return new ArrayList<NoUpsideDownCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoUpsideDownCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoUpsideDownCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoUpsideDownCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoUpsideDownCls> clsList = new ArrayList<NoUpsideDownCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoUpsideDownCls> groupOf(String groupName) {
            return new ArrayList<NoUpsideDownCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ワンタイムフラグ
     */
    public enum OnetimeFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, OnetimeFlg> _codeClsMap = new HashMap<String, OnetimeFlg>();
        private static final Map<String, OnetimeFlg> _nameClsMap = new HashMap<String, OnetimeFlg>();
        static {
            for (OnetimeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OnetimeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OnetimeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OnetimeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OnetimeFlg) { return OptionalThing.of((OnetimeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OnetimeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OnetimeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OnetimeFlg) { return (OnetimeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OnetimeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OnetimeFlg> listAll() {
            return new ArrayList<OnetimeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OnetimeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OnetimeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OnetimeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OnetimeFlg> clsList = new ArrayList<OnetimeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OnetimeFlg> groupOf(String groupName) {
            return new ArrayList<OnetimeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * HT/SD過入荷可フラグ
     */
    public enum OverStoreNumFlg implements CDef {
        /** $0: 不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 可能 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, OverStoreNumFlg> _codeClsMap = new HashMap<String, OverStoreNumFlg>();
        private static final Map<String, OverStoreNumFlg> _nameClsMap = new HashMap<String, OverStoreNumFlg>();
        static {
            for (OverStoreNumFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OverStoreNumFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OverStoreNumFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OverStoreNumFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OverStoreNumFlg) { return OptionalThing.of((OverStoreNumFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OverStoreNumFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OverStoreNumFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OverStoreNumFlg) { return (OverStoreNumFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OverStoreNumFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OverStoreNumFlg> listAll() {
            return new ArrayList<OverStoreNumFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OverStoreNumFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OverStoreNumFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OverStoreNumFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OverStoreNumFlg> clsList = new ArrayList<OverStoreNumFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OverStoreNumFlg> groupOf(String groupName) {
            return new ArrayList<OverStoreNumFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 梱包計算処理区分
     */
    public enum PackingCalCls implements CDef {
        /** $0: 梱包計算無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 容積と重量による梱包計算 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PackingCalCls> _codeClsMap = new HashMap<String, PackingCalCls>();
        private static final Map<String, PackingCalCls> _nameClsMap = new HashMap<String, PackingCalCls>();
        static {
            for (PackingCalCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingCalCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingCalCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingCalCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingCalCls) { return OptionalThing.of((PackingCalCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingCalCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingCalCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingCalCls) { return (PackingCalCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingCalCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingCalCls> listAll() {
            return new ArrayList<PackingCalCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingCalCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingCalCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingCalCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingCalCls> clsList = new ArrayList<PackingCalCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingCalCls> groupOf(String groupName) {
            return new ArrayList<PackingCalCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 梱包方法
     */
    public enum PackingProcessCls implements CDef {
        /** $0: 受取側考慮(出荷指示昇順) */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: なるべく詰める(容積降順) */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PackingProcessCls> _codeClsMap = new HashMap<String, PackingProcessCls>();
        private static final Map<String, PackingProcessCls> _nameClsMap = new HashMap<String, PackingProcessCls>();
        static {
            for (PackingProcessCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingProcessCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingProcessCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingProcessCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingProcessCls) { return OptionalThing.of((PackingProcessCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingProcessCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingProcessCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingProcessCls) { return (PackingProcessCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingProcessCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingProcessCls> listAll() {
            return new ArrayList<PackingProcessCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingProcessCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingProcessCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingProcessCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingProcessCls> clsList = new ArrayList<PackingProcessCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingProcessCls> groupOf(String groupName) {
            return new ArrayList<PackingProcessCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 個数口表示フラグ
     */
    public enum PackingShowFlg implements CDef {
        /** $0: 表示する */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示しない */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PackingShowFlg> _codeClsMap = new HashMap<String, PackingShowFlg>();
        private static final Map<String, PackingShowFlg> _nameClsMap = new HashMap<String, PackingShowFlg>();
        static {
            for (PackingShowFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingShowFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingShowFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingShowFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingShowFlg) { return OptionalThing.of((PackingShowFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingShowFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingShowFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingShowFlg) { return (PackingShowFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingShowFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingShowFlg> listAll() {
            return new ArrayList<PackingShowFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingShowFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingShowFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingShowFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingShowFlg> clsList = new ArrayList<PackingShowFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingShowFlg> groupOf(String groupName) {
            return new ArrayList<PackingShowFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 梱包ステータス
     */
    public enum PackingStatus implements CDef {
        /** $10: 未出荷 */
        $10("10", "$10", emptyStrings())
        ,
        /** $15: 出庫指示中 */
        $15("15", "$15", emptyStrings())
        ,
        /** $20: 出庫指示解除中 */
        $20("20", "$20", emptyStrings())
        ,
        /** $25: 出庫指示済 */
        $25("25", "$25", emptyStrings())
        ,
        /** $30: ピッキング中 */
        $30("30", "$30", emptyStrings())
        ,
        /** $35: ピッキング済 */
        $35("35", "$35", emptyStrings())
        ,
        /** $40: 出荷検品中 */
        $40("40", "$40", emptyStrings())
        ,
        /** $45: 出荷検品中断 */
        $45("45", "$45", emptyStrings())
        ,
        /** $50: 出荷検品済 */
        $50("50", "$50", emptyStrings())
        ,
        /** $55: 出荷確定済 */
        $55("55", "$55", emptyStrings())
        ,
        /** $90: キャンセル */
        $90("90", "$90", emptyStrings())
        ,
        /** $99: エラー有 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, PackingStatus> _codeClsMap = new HashMap<String, PackingStatus>();
        private static final Map<String, PackingStatus> _nameClsMap = new HashMap<String, PackingStatus>();
        static {
            for (PackingStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingStatus) { return OptionalThing.of((PackingStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingStatus) { return (PackingStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingStatus> listAll() {
            return new ArrayList<PackingStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingStatus> clsList = new ArrayList<PackingStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingStatus> groupOf(String groupName) {
            return new ArrayList<PackingStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * パスワードリセット
     */
    public enum PasswordReset implements CDef {
        /** $0: 強制しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 強制する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PasswordReset> _codeClsMap = new HashMap<String, PasswordReset>();
        private static final Map<String, PasswordReset> _nameClsMap = new HashMap<String, PasswordReset>();
        static {
            for (PasswordReset value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PasswordReset(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PasswordReset; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PasswordReset> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PasswordReset) { return OptionalThing.of((PasswordReset)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PasswordReset> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PasswordReset codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PasswordReset) { return (PasswordReset)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PasswordReset nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PasswordReset> listAll() {
            return new ArrayList<PasswordReset>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PasswordReset> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PasswordReset." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PasswordReset> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PasswordReset> clsList = new ArrayList<PasswordReset>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PasswordReset> groupOf(String groupName) {
            return new ArrayList<PasswordReset>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * HT/SD過去日入力可フラグ
     */
    public enum PastStoreDtFlg implements CDef {
        /** $0: 不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 可能 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PastStoreDtFlg> _codeClsMap = new HashMap<String, PastStoreDtFlg>();
        private static final Map<String, PastStoreDtFlg> _nameClsMap = new HashMap<String, PastStoreDtFlg>();
        static {
            for (PastStoreDtFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PastStoreDtFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PastStoreDtFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PastStoreDtFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PastStoreDtFlg) { return OptionalThing.of((PastStoreDtFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PastStoreDtFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PastStoreDtFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PastStoreDtFlg) { return (PastStoreDtFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PastStoreDtFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PastStoreDtFlg> listAll() {
            return new ArrayList<PastStoreDtFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PastStoreDtFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PastStoreDtFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PastStoreDtFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PastStoreDtFlg> clsList = new ArrayList<PastStoreDtFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PastStoreDtFlg> groupOf(String groupName) {
            return new ArrayList<PastStoreDtFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 削除
     */
    public enum PhysicalDelete implements CDef {
        /** $1: 削除 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PhysicalDelete> _codeClsMap = new HashMap<String, PhysicalDelete>();
        private static final Map<String, PhysicalDelete> _nameClsMap = new HashMap<String, PhysicalDelete>();
        static {
            for (PhysicalDelete value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PhysicalDelete(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PhysicalDelete; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PhysicalDelete> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PhysicalDelete) { return OptionalThing.of((PhysicalDelete)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PhysicalDelete> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PhysicalDelete codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PhysicalDelete) { return (PhysicalDelete)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PhysicalDelete nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PhysicalDelete> listAll() {
            return new ArrayList<PhysicalDelete>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PhysicalDelete> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PhysicalDelete." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PhysicalDelete> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PhysicalDelete> clsList = new ArrayList<PhysicalDelete>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PhysicalDelete> groupOf(String groupName) {
            return new ArrayList<PhysicalDelete>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出庫フラグ
     */
    public enum PickingFlg implements CDef {
        /** $0: 未出庫 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出庫済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $7: 出庫作業中 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, PickingFlg> _codeClsMap = new HashMap<String, PickingFlg>();
        private static final Map<String, PickingFlg> _nameClsMap = new HashMap<String, PickingFlg>();
        static {
            for (PickingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingFlg) { return OptionalThing.of((PickingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingFlg) { return (PickingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingFlg> listAll() {
            return new ArrayList<PickingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingFlg> clsList = new ArrayList<PickingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingFlg> groupOf(String groupName) {
            return new ArrayList<PickingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ピックロケフラグ
     */
    public enum PickingLocationFlg implements CDef {
        /** $0: ピックロケーション以外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ピックロケーション */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PickingLocationFlg> _codeClsMap = new HashMap<String, PickingLocationFlg>();
        private static final Map<String, PickingLocationFlg> _nameClsMap = new HashMap<String, PickingLocationFlg>();
        static {
            for (PickingLocationFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingLocationFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingLocationFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingLocationFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingLocationFlg) { return OptionalThing.of((PickingLocationFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingLocationFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingLocationFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingLocationFlg) { return (PickingLocationFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingLocationFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingLocationFlg> listAll() {
            return new ArrayList<PickingLocationFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingLocationFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingLocationFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingLocationFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingLocationFlg> clsList = new ArrayList<PickingLocationFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingLocationFlg> groupOf(String groupName) {
            return new ArrayList<PickingLocationFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出庫ステータス
     */
    public enum PickingStatus implements CDef {
        /** $10: 未出荷 */
        $10("10", "$10", emptyStrings())
        ,
        /** $15: 出庫指示中 */
        $15("15", "$15", emptyStrings())
        ,
        /** $20: 出庫指示解除中 */
        $20("20", "$20", emptyStrings())
        ,
        /** $25: 出庫指示済 */
        $25("25", "$25", emptyStrings())
        ,
        /** $30: ピッキング中 */
        $30("30", "$30", emptyStrings())
        ,
        /** $35: ピッキング済 */
        $35("35", "$35", emptyStrings())
        ,
        /** $40: 出荷検品中 */
        $40("40", "$40", emptyStrings())
        ,
        /** $45: 出荷検品中断 */
        $45("45", "$45", emptyStrings())
        ,
        /** $50: 出荷検品済 */
        $50("50", "$50", emptyStrings())
        ,
        /** $55: 出荷確定済 */
        $55("55", "$55", emptyStrings())
        ,
        /** $90: キャンセル */
        $90("90", "$90", emptyStrings())
        ,
        /** $99: エラー有 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, PickingStatus> _codeClsMap = new HashMap<String, PickingStatus>();
        private static final Map<String, PickingStatus> _nameClsMap = new HashMap<String, PickingStatus>();
        static {
            for (PickingStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingStatus) { return OptionalThing.of((PickingStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingStatus) { return (PickingStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingStatus> listAll() {
            return new ArrayList<PickingStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingStatus> clsList = new ArrayList<PickingStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingStatus> groupOf(String groupName) {
            return new ArrayList<PickingStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ピッキング方法
     */
    public enum PicCls implements CDef {
        /** $1: 一次ピッキング */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 二次ピッキング */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ケースピッキング */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 送り状・荷札 */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, PicCls> _codeClsMap = new HashMap<String, PicCls>();
        private static final Map<String, PicCls> _nameClsMap = new HashMap<String, PicCls>();
        static {
            for (PicCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PicCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PicCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PicCls) { return OptionalThing.of((PicCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PicCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PicCls) { return (PicCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PicCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PicCls> listAll() {
            return new ArrayList<PicCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PicCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PicCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PicCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PicCls> clsList = new ArrayList<PicCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PicCls> groupOf(String groupName) {
            return new ArrayList<PicCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最適ピック提案ブレイクキー
     */
    public enum PicMthdRcmdBreakKey implements CDef {
        /** $1: 配送コース */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 運送業者 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, PicMthdRcmdBreakKey> _codeClsMap = new HashMap<String, PicMthdRcmdBreakKey>();
        private static final Map<String, PicMthdRcmdBreakKey> _nameClsMap = new HashMap<String, PicMthdRcmdBreakKey>();
        static {
            for (PicMthdRcmdBreakKey value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PicMthdRcmdBreakKey(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PicMthdRcmdBreakKey; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdBreakKey> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PicMthdRcmdBreakKey) { return OptionalThing.of((PicMthdRcmdBreakKey)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdBreakKey> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdBreakKey codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PicMthdRcmdBreakKey) { return (PicMthdRcmdBreakKey)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdBreakKey nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PicMthdRcmdBreakKey> listAll() {
            return new ArrayList<PicMthdRcmdBreakKey>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PicMthdRcmdBreakKey> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PicMthdRcmdBreakKey." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PicMthdRcmdBreakKey> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PicMthdRcmdBreakKey> clsList = new ArrayList<PicMthdRcmdBreakKey>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PicMthdRcmdBreakKey> groupOf(String groupName) {
            return new ArrayList<PicMthdRcmdBreakKey>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最適ピック提案フラグ
     */
    public enum PicMthdRcmdFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PicMthdRcmdFlg> _codeClsMap = new HashMap<String, PicMthdRcmdFlg>();
        private static final Map<String, PicMthdRcmdFlg> _nameClsMap = new HashMap<String, PicMthdRcmdFlg>();
        static {
            for (PicMthdRcmdFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PicMthdRcmdFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PicMthdRcmdFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PicMthdRcmdFlg) { return OptionalThing.of((PicMthdRcmdFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PicMthdRcmdFlg) { return (PicMthdRcmdFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PicMthdRcmdFlg> listAll() {
            return new ArrayList<PicMthdRcmdFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PicMthdRcmdFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PicMthdRcmdFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PicMthdRcmdFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PicMthdRcmdFlg> clsList = new ArrayList<PicMthdRcmdFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PicMthdRcmdFlg> groupOf(String groupName) {
            return new ArrayList<PicMthdRcmdFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最適ピックリスト出力フラグ
     */
    public enum PicMthdRcmdListOut implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PicMthdRcmdListOut> _codeClsMap = new HashMap<String, PicMthdRcmdListOut>();
        private static final Map<String, PicMthdRcmdListOut> _nameClsMap = new HashMap<String, PicMthdRcmdListOut>();
        static {
            for (PicMthdRcmdListOut value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PicMthdRcmdListOut(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PicMthdRcmdListOut; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdListOut> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PicMthdRcmdListOut) { return OptionalThing.of((PicMthdRcmdListOut)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdListOut> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdListOut codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PicMthdRcmdListOut) { return (PicMthdRcmdListOut)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdListOut nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PicMthdRcmdListOut> listAll() {
            return new ArrayList<PicMthdRcmdListOut>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PicMthdRcmdListOut> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PicMthdRcmdListOut." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PicMthdRcmdListOut> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PicMthdRcmdListOut> clsList = new ArrayList<PicMthdRcmdListOut>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PicMthdRcmdListOut> groupOf(String groupName) {
            return new ArrayList<PicMthdRcmdListOut>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 郵便種別
     */
    public enum PostType implements CDef {
        /** $0: ゆうパック */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ゆうメール */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 通常(定型) */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 通常(定型外) */
        $3("3", "$3", emptyStrings())
        ,
        /** $5: ポスパケット */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 宛名ラベル */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, PostType> _codeClsMap = new HashMap<String, PostType>();
        private static final Map<String, PostType> _nameClsMap = new HashMap<String, PostType>();
        static {
            for (PostType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PostType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PostType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PostType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PostType) { return OptionalThing.of((PostType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PostType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PostType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PostType) { return (PostType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PostType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PostType> listAll() {
            return new ArrayList<PostType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PostType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PostType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PostType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PostType> clsList = new ArrayList<PostType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PostType> groupOf(String groupName) {
            return new ArrayList<PostType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 再印刷有無
     */
    public enum PrintedFlg implements CDef {
        /** $0: 有 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 無 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PrintedFlg> _codeClsMap = new HashMap<String, PrintedFlg>();
        private static final Map<String, PrintedFlg> _nameClsMap = new HashMap<String, PrintedFlg>();
        static {
            for (PrintedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintedFlg) { return OptionalThing.of((PrintedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintedFlg) { return (PrintedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintedFlg> listAll() {
            return new ArrayList<PrintedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintedFlg> clsList = new ArrayList<PrintedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintedFlg> groupOf(String groupName) {
            return new ArrayList<PrintedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷データタイプ
     */
    public enum PrintDataType implements CDef {
        /** $1: 通常 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 保護PDF */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, PrintDataType> _codeClsMap = new HashMap<String, PrintDataType>();
        private static final Map<String, PrintDataType> _nameClsMap = new HashMap<String, PrintDataType>();
        static {
            for (PrintDataType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintDataType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintDataType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintDataType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintDataType) { return OptionalThing.of((PrintDataType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintDataType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintDataType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintDataType) { return (PrintDataType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintDataType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintDataType> listAll() {
            return new ArrayList<PrintDataType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintDataType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintDataType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintDataType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintDataType> clsList = new ArrayList<PrintDataType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintDataType> groupOf(String groupName) {
            return new ArrayList<PrintDataType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * エラーのみ
     */
    public enum PrintErrorFlg implements CDef {
        /** $0: 全て */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: エラーのみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PrintErrorFlg> _codeClsMap = new HashMap<String, PrintErrorFlg>();
        private static final Map<String, PrintErrorFlg> _nameClsMap = new HashMap<String, PrintErrorFlg>();
        static {
            for (PrintErrorFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintErrorFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintErrorFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintErrorFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintErrorFlg) { return OptionalThing.of((PrintErrorFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintErrorFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintErrorFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintErrorFlg) { return (PrintErrorFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintErrorFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintErrorFlg> listAll() {
            return new ArrayList<PrintErrorFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintErrorFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintErrorFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintErrorFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintErrorFlg> clsList = new ArrayList<PrintErrorFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintErrorFlg> groupOf(String groupName) {
            return new ArrayList<PrintErrorFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷キューステータス
     */
    public enum PrintQueueStatus implements CDef {
        /** $0: 未印刷 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 印刷中 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PrintQueueStatus> _codeClsMap = new HashMap<String, PrintQueueStatus>();
        private static final Map<String, PrintQueueStatus> _nameClsMap = new HashMap<String, PrintQueueStatus>();
        static {
            for (PrintQueueStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintQueueStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintQueueStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintQueueStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintQueueStatus) { return OptionalThing.of((PrintQueueStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintQueueStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintQueueStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintQueueStatus) { return (PrintQueueStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintQueueStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintQueueStatus> listAll() {
            return new ArrayList<PrintQueueStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintQueueStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintQueueStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintQueueStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintQueueStatus> clsList = new ArrayList<PrintQueueStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintQueueStatus> groupOf(String groupName) {
            return new ArrayList<PrintQueueStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷結果区分
     */
    public enum PrintResultClass implements CDef {
        /** $0: 印刷成功 */
        $0("0", "$0", emptyStrings())
        ,
        /** $9: 印刷失敗 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, PrintResultClass> _codeClsMap = new HashMap<String, PrintResultClass>();
        private static final Map<String, PrintResultClass> _nameClsMap = new HashMap<String, PrintResultClass>();
        static {
            for (PrintResultClass value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintResultClass(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintResultClass; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintResultClass> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintResultClass) { return OptionalThing.of((PrintResultClass)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintResultClass> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintResultClass codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintResultClass) { return (PrintResultClass)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintResultClass nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintResultClass> listAll() {
            return new ArrayList<PrintResultClass>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintResultClass> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintResultClass." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintResultClass> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintResultClass> clsList = new ArrayList<PrintResultClass>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintResultClass> groupOf(String groupName) {
            return new ArrayList<PrintResultClass>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷サービスステータス
     */
    public enum PrintServiceStatus implements CDef {
        /** $0: サービス中 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: サービス停止中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: シャットダウン中 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, PrintServiceStatus> _codeClsMap = new HashMap<String, PrintServiceStatus>();
        private static final Map<String, PrintServiceStatus> _nameClsMap = new HashMap<String, PrintServiceStatus>();
        static {
            for (PrintServiceStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintServiceStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintServiceStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintServiceStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintServiceStatus) { return OptionalThing.of((PrintServiceStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintServiceStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintServiceStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintServiceStatus) { return (PrintServiceStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintServiceStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintServiceStatus> listAll() {
            return new ArrayList<PrintServiceStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintServiceStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintServiceStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintServiceStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintServiceStatus> clsList = new ArrayList<PrintServiceStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintServiceStatus> groupOf(String groupName) {
            return new ArrayList<PrintServiceStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷ステータス
     */
    public enum PrintStatus implements CDef {
        /** $0: 未印刷 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 印刷中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 印刷済 */
        $2("2", "$2", emptyStrings())
        ,
        /** $9: 印刷失敗 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, PrintStatus> _codeClsMap = new HashMap<String, PrintStatus>();
        private static final Map<String, PrintStatus> _nameClsMap = new HashMap<String, PrintStatus>();
        static {
            for (PrintStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintStatus) { return OptionalThing.of((PrintStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintStatus) { return (PrintStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintStatus> listAll() {
            return new ArrayList<PrintStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintStatus> clsList = new ArrayList<PrintStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintStatus> groupOf(String groupName) {
            return new ArrayList<PrintStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 優先フラグ
     */
    public enum PriorityFlg implements CDef {
        /** $0: 優先指定無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 優先指定有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PriorityFlg> _codeClsMap = new HashMap<String, PriorityFlg>();
        private static final Map<String, PriorityFlg> _nameClsMap = new HashMap<String, PriorityFlg>();
        static {
            for (PriorityFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PriorityFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PriorityFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PriorityFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PriorityFlg) { return OptionalThing.of((PriorityFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PriorityFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PriorityFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PriorityFlg) { return (PriorityFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PriorityFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PriorityFlg> listAll() {
            return new ArrayList<PriorityFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PriorityFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PriorityFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PriorityFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PriorityFlg> clsList = new ArrayList<PriorityFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PriorityFlg> groupOf(String groupName) {
            return new ArrayList<PriorityFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品ラベルソースCDバーコード種別
     */
    public enum ProductLabelJanBarcode implements CDef {
        /** $CODABAR: CODABAR(NW-7) */
        $CODABAR("CODABAR", "$CODABAR", emptyStrings())
        ,
        /** $CODE128: CODE128 */
        $CODE128("CODE128", "$CODE128", emptyStrings())
        ,
        /** $CODE39: CODE39 */
        $CODE39("CODE39", "$CODE39", emptyStrings())
        ,
        /** $ITF: ITF */
        $ITF("ITF", "$ITF", emptyStrings())
        ,
        /** $JAN: JAN(8or13) */
        $JAN("JAN", "$JAN", emptyStrings())
        ;
        private static final Map<String, ProductLabelJanBarcode> _codeClsMap = new HashMap<String, ProductLabelJanBarcode>();
        private static final Map<String, ProductLabelJanBarcode> _nameClsMap = new HashMap<String, ProductLabelJanBarcode>();
        static {
            for (ProductLabelJanBarcode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductLabelJanBarcode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductLabelJanBarcode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelJanBarcode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductLabelJanBarcode) { return OptionalThing.of((ProductLabelJanBarcode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelJanBarcode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelJanBarcode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductLabelJanBarcode) { return (ProductLabelJanBarcode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelJanBarcode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductLabelJanBarcode> listAll() {
            return new ArrayList<ProductLabelJanBarcode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductLabelJanBarcode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductLabelJanBarcode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductLabelJanBarcode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductLabelJanBarcode> clsList = new ArrayList<ProductLabelJanBarcode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductLabelJanBarcode> groupOf(String groupName) {
            return new ArrayList<ProductLabelJanBarcode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品ラベル出力単位
     */
    public enum ProductLabelOutUnit implements CDef {
        /** $0: 1明細1枚 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 荷姿毎に1枚(在庫最小単位は全体で1枚) */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 在庫最小単位毎に1枚 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ProductLabelOutUnit> _codeClsMap = new HashMap<String, ProductLabelOutUnit>();
        private static final Map<String, ProductLabelOutUnit> _nameClsMap = new HashMap<String, ProductLabelOutUnit>();
        static {
            for (ProductLabelOutUnit value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductLabelOutUnit(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductLabelOutUnit; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelOutUnit> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductLabelOutUnit) { return OptionalThing.of((ProductLabelOutUnit)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelOutUnit> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelOutUnit codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductLabelOutUnit) { return (ProductLabelOutUnit)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelOutUnit nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductLabelOutUnit> listAll() {
            return new ArrayList<ProductLabelOutUnit>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductLabelOutUnit> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductLabelOutUnit." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductLabelOutUnit> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductLabelOutUnit> clsList = new ArrayList<ProductLabelOutUnit>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductLabelOutUnit> groupOf(String groupName) {
            return new ArrayList<ProductLabelOutUnit>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品ラベル商品CDバーコード種別
     */
    public enum ProductLabelProdBarcode implements CDef {
        /** $CODABAR: CODABAR(NW-7) */
        $CODABAR("CODABAR", "$CODABAR", emptyStrings())
        ,
        /** $CODE128: CODE128 */
        $CODE128("CODE128", "$CODE128", emptyStrings())
        ,
        /** $CODE39: CODE39 */
        $CODE39("CODE39", "$CODE39", emptyStrings())
        ,
        /** $ITF: ITF */
        $ITF("ITF", "$ITF", emptyStrings())
        ,
        /** $JAN: JAN(8or13) */
        $JAN("JAN", "$JAN", emptyStrings())
        ;
        private static final Map<String, ProductLabelProdBarcode> _codeClsMap = new HashMap<String, ProductLabelProdBarcode>();
        private static final Map<String, ProductLabelProdBarcode> _nameClsMap = new HashMap<String, ProductLabelProdBarcode>();
        static {
            for (ProductLabelProdBarcode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductLabelProdBarcode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductLabelProdBarcode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelProdBarcode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductLabelProdBarcode) { return OptionalThing.of((ProductLabelProdBarcode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelProdBarcode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelProdBarcode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductLabelProdBarcode) { return (ProductLabelProdBarcode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelProdBarcode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductLabelProdBarcode> listAll() {
            return new ArrayList<ProductLabelProdBarcode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductLabelProdBarcode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductLabelProdBarcode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductLabelProdBarcode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductLabelProdBarcode> clsList = new ArrayList<ProductLabelProdBarcode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductLabelProdBarcode> groupOf(String groupName) {
            return new ArrayList<ProductLabelProdBarcode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品毎別梱包
     */
    public enum ProductPartPacking implements CDef {
        /** $0: 不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 可能 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ProductPartPacking> _codeClsMap = new HashMap<String, ProductPartPacking>();
        private static final Map<String, ProductPartPacking> _nameClsMap = new HashMap<String, ProductPartPacking>();
        static {
            for (ProductPartPacking value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductPartPacking(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductPartPacking; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductPartPacking> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductPartPacking) { return OptionalThing.of((ProductPartPacking)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductPartPacking> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductPartPacking codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductPartPacking) { return (ProductPartPacking)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductPartPacking nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductPartPacking> listAll() {
            return new ArrayList<ProductPartPacking>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductPartPacking> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductPartPacking." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductPartPacking> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductPartPacking> clsList = new ArrayList<ProductPartPacking>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductPartPacking> groupOf(String groupName) {
            return new ArrayList<ProductPartPacking>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品種別コード
     */
    public enum ProductTypeCode implements CDef {
        /** $101: ゆうパック */
        $101("101", "$101", emptyStrings())
        ,
        /** $102: 空港ゆうパック */
        $102("102", "$102", emptyStrings())
        ,
        /** $103: チルドゆうパック */
        $103("103", "$103", emptyStrings())
        ,
        /** $105: 冷凍ゆうパック */
        $105("105", "$105", emptyStrings())
        ,
        /** $107: ゴルフゆうパック */
        $107("107", "$107", emptyStrings())
        ,
        /** $113: スキー・ホテル等ゆうパック */
        $113("113", "$113", emptyStrings())
        ,
        /** $201: 着払ゆうパック */
        $201("201", "$201", emptyStrings())
        ,
        /** $202: 着払ゆうパック(チルド) */
        $202("202", "$202", emptyStrings())
        ,
        /** $203: 着払ゆうパック(冷凍) */
        $203("203", "$203", emptyStrings())
        ,
        /** $601: 代金引換まとめ送金サービス */
        $601("601", "$601", emptyStrings())
        ,
        /** $603: 代金引換まとめ送金サービス(チルド) */
        $603("603", "$603", emptyStrings())
        ,
        /** $605: 代金引換まとめ送金サービス(冷凍) */
        $605("605", "$605", emptyStrings())
        ,
        /** $701: スキー・ホテル等ゆうパック(往路) */
        $701("701", "$701", emptyStrings())
        ,
        /** $702: 空港ゆうパック(往路) */
        $702("702", "$702", emptyStrings())
        ,
        /** $703: スキー・ホテル等ゆうパック(復路) */
        $703("703", "$703", emptyStrings())
        ,
        /** $704: 空港ゆうパック(復路) */
        $704("704", "$704", emptyStrings())
        ,
        /** $705: ゴルフゆうパック(往路) */
        $705("705", "$705", emptyStrings())
        ,
        /** $707: ゴルフゆうパック(復路) */
        $707("707", "$707", emptyStrings())
        ;
        private static final Map<String, ProductTypeCode> _codeClsMap = new HashMap<String, ProductTypeCode>();
        private static final Map<String, ProductTypeCode> _nameClsMap = new HashMap<String, ProductTypeCode>();
        static {
            for (ProductTypeCode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductTypeCode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductTypeCode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductTypeCode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductTypeCode) { return OptionalThing.of((ProductTypeCode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductTypeCode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductTypeCode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductTypeCode) { return (ProductTypeCode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductTypeCode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductTypeCode> listAll() {
            return new ArrayList<ProductTypeCode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductTypeCode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductTypeCode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductTypeCode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductTypeCode> clsList = new ArrayList<ProductTypeCode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductTypeCode> groupOf(String groupName) {
            return new ArrayList<ProductTypeCode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 0非表示
     */
    public enum Qty0Display implements CDef {
        /** $0: 0表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 0非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Qty0Display> _codeClsMap = new HashMap<String, Qty0Display>();
        private static final Map<String, Qty0Display> _nameClsMap = new HashMap<String, Qty0Display>();
        static {
            for (Qty0Display value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Qty0Display(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Qty0Display; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Qty0Display> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Qty0Display) { return OptionalThing.of((Qty0Display)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Qty0Display> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Qty0Display codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Qty0Display) { return (Qty0Display)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Qty0Display nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Qty0Display> listAll() {
            return new ArrayList<Qty0Display>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Qty0Display> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Qty0Display." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Qty0Display> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Qty0Display> clsList = new ArrayList<Qty0Display>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Qty0Display> groupOf(String groupName) {
            return new ArrayList<Qty0Display>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 変更理由
     */
    public enum ReasonType implements CDef {
        /** $0: 変更なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 市政・区政・町政・分区・政令指定都市施行 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 住居表示の実施 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 区画整理 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 郵便区調整等 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 訂正 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 廃止 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, ReasonType> _codeClsMap = new HashMap<String, ReasonType>();
        private static final Map<String, ReasonType> _nameClsMap = new HashMap<String, ReasonType>();
        static {
            for (ReasonType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReasonType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReasonType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReasonType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReasonType) { return OptionalThing.of((ReasonType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReasonType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReasonType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReasonType) { return (ReasonType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReasonType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReasonType> listAll() {
            return new ArrayList<ReasonType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReasonType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReasonType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReasonType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReasonType> clsList = new ArrayList<ReasonType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReasonType> groupOf(String groupName) {
            return new ArrayList<ReasonType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷納品ステータス
     */
    public enum ReceiveDeliveryStatus implements CDef {
        /** $00: 未完 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 完納 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 分納 */
        $02("02", "$02", emptyStrings())
        ,
        /** $09: 打切り */
        $09("09", "$09", emptyStrings())
        ;
        private static final Map<String, ReceiveDeliveryStatus> _codeClsMap = new HashMap<String, ReceiveDeliveryStatus>();
        private static final Map<String, ReceiveDeliveryStatus> _nameClsMap = new HashMap<String, ReceiveDeliveryStatus>();
        static {
            for (ReceiveDeliveryStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveDeliveryStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveDeliveryStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveDeliveryStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveDeliveryStatus) { return OptionalThing.of((ReceiveDeliveryStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveDeliveryStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveDeliveryStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveDeliveryStatus) { return (ReceiveDeliveryStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveDeliveryStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveDeliveryStatus> listAll() {
            return new ArrayList<ReceiveDeliveryStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveDeliveryStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveDeliveryStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveDeliveryStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveDeliveryStatus> clsList = new ArrayList<ReceiveDeliveryStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveDeliveryStatus> groupOf(String groupName) {
            return new ArrayList<ReceiveDeliveryStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷フラグ
     */
    public enum ReceiveFlg implements CDef {
        /** $0: 入荷対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 入荷対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReceiveFlg> _codeClsMap = new HashMap<String, ReceiveFlg>();
        private static final Map<String, ReceiveFlg> _nameClsMap = new HashMap<String, ReceiveFlg>();
        static {
            for (ReceiveFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveFlg) { return OptionalThing.of((ReceiveFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveFlg) { return (ReceiveFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveFlg> listAll() {
            return new ArrayList<ReceiveFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveFlg> clsList = new ArrayList<ReceiveFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveFlg> groupOf(String groupName) {
            return new ArrayList<ReceiveFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷ステータス
     */
    public enum ReceiveStatus implements CDef {
        /** $01: 未入荷 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 入荷中 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 入荷済 */
        $03("03", "$03", emptyStrings())
        ,
        /** $90: 入荷削除 */
        $90("90", "$90", emptyStrings())
        ,
        /** $99: エラー有 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, ReceiveStatus> _codeClsMap = new HashMap<String, ReceiveStatus>();
        private static final Map<String, ReceiveStatus> _nameClsMap = new HashMap<String, ReceiveStatus>();
        static {
            for (ReceiveStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveStatus) { return OptionalThing.of((ReceiveStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveStatus) { return (ReceiveStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveStatus> listAll() {
            return new ArrayList<ReceiveStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveStatus> clsList = new ArrayList<ReceiveStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveStatus> groupOf(String groupName) {
            return new ArrayList<ReceiveStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充ロケ割付区分
     */
    public enum ReplenishAllocCls implements CDef {
        /** $0: バッチ毎同一SKUは同一ロケに割付 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 補充毎に別ロケを割付 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReplenishAllocCls> _codeClsMap = new HashMap<String, ReplenishAllocCls>();
        private static final Map<String, ReplenishAllocCls> _nameClsMap = new HashMap<String, ReplenishAllocCls>();
        static {
            for (ReplenishAllocCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishAllocCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishAllocCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishAllocCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishAllocCls) { return OptionalThing.of((ReplenishAllocCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishAllocCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishAllocCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishAllocCls) { return (ReplenishAllocCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishAllocCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishAllocCls> listAll() {
            return new ArrayList<ReplenishAllocCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishAllocCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishAllocCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishAllocCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishAllocCls> clsList = new ArrayList<ReplenishAllocCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishAllocCls> groupOf(String groupName) {
            return new ArrayList<ReplenishAllocCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充商品CD未設定
     */
    public enum ReplenishProductCdUnset implements CDef {
        /** $1: 未設定のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReplenishProductCdUnset> _codeClsMap = new HashMap<String, ReplenishProductCdUnset>();
        private static final Map<String, ReplenishProductCdUnset> _nameClsMap = new HashMap<String, ReplenishProductCdUnset>();
        static {
            for (ReplenishProductCdUnset value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishProductCdUnset(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishProductCdUnset; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishProductCdUnset> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishProductCdUnset) { return OptionalThing.of((ReplenishProductCdUnset)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishProductCdUnset> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishProductCdUnset codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishProductCdUnset) { return (ReplenishProductCdUnset)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishProductCdUnset nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishProductCdUnset> listAll() {
            return new ArrayList<ReplenishProductCdUnset>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishProductCdUnset> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishProductCdUnset." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishProductCdUnset> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishProductCdUnset> clsList = new ArrayList<ReplenishProductCdUnset>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishProductCdUnset> groupOf(String groupName) {
            return new ArrayList<ReplenishProductCdUnset>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充点検索区分
     */
    public enum ReplenishSearchCls implements CDef {
        /** $0: 補充点以下 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 補充可能 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 全て */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ReplenishSearchCls> _codeClsMap = new HashMap<String, ReplenishSearchCls>();
        private static final Map<String, ReplenishSearchCls> _nameClsMap = new HashMap<String, ReplenishSearchCls>();
        static {
            for (ReplenishSearchCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishSearchCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishSearchCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishSearchCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishSearchCls) { return OptionalThing.of((ReplenishSearchCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishSearchCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishSearchCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishSearchCls) { return (ReplenishSearchCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishSearchCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishSearchCls> listAll() {
            return new ArrayList<ReplenishSearchCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishSearchCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishSearchCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishSearchCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishSearchCls> clsList = new ArrayList<ReplenishSearchCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishSearchCls> groupOf(String groupName) {
            return new ArrayList<ReplenishSearchCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充単位区分
     */
    public enum ReplenishUnitCls implements CDef {
        /** $0: 必要数 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 最大格納数荷姿切上 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReplenishUnitCls> _codeClsMap = new HashMap<String, ReplenishUnitCls>();
        private static final Map<String, ReplenishUnitCls> _nameClsMap = new HashMap<String, ReplenishUnitCls>();
        static {
            for (ReplenishUnitCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishUnitCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishUnitCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishUnitCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishUnitCls) { return OptionalThing.of((ReplenishUnitCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishUnitCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishUnitCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishUnitCls) { return (ReplenishUnitCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishUnitCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishUnitCls> listAll() {
            return new ArrayList<ReplenishUnitCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishUnitCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishUnitCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishUnitCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishUnitCls> clsList = new ArrayList<ReplenishUnitCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishUnitCls> groupOf(String groupName) {
            return new ArrayList<ReplenishUnitCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 項目型
     */
    public enum ReportLayoutItemType implements CDef {
        /** $0: 固定項目 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力項目 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReportLayoutItemType> _codeClsMap = new HashMap<String, ReportLayoutItemType>();
        private static final Map<String, ReportLayoutItemType> _nameClsMap = new HashMap<String, ReportLayoutItemType>();
        static {
            for (ReportLayoutItemType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReportLayoutItemType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReportLayoutItemType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReportLayoutItemType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReportLayoutItemType) { return OptionalThing.of((ReportLayoutItemType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReportLayoutItemType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReportLayoutItemType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReportLayoutItemType) { return (ReportLayoutItemType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReportLayoutItemType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReportLayoutItemType> listAll() {
            return new ArrayList<ReportLayoutItemType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReportLayoutItemType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReportLayoutItemType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReportLayoutItemType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReportLayoutItemType> clsList = new ArrayList<ReportLayoutItemType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReportLayoutItemType> groupOf(String groupName) {
            return new ArrayList<ReportLayoutItemType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充種別
     */
    public enum RestockType implements CDef {
        /** $0: 定期 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 緊急 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, RestockType> _codeClsMap = new HashMap<String, RestockType>();
        private static final Map<String, RestockType> _nameClsMap = new HashMap<String, RestockType>();
        static {
            for (RestockType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RestockType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RestockType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RestockType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RestockType) { return OptionalThing.of((RestockType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RestockType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RestockType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RestockType) { return (RestockType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RestockType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RestockType> listAll() {
            return new ArrayList<RestockType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RestockType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RestockType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RestockType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RestockType> clsList = new ArrayList<RestockType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RestockType> groupOf(String groupName) {
            return new ArrayList<RestockType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 実績入力後入庫/商品ラベル出力
     */
    public enum ResultAfterProductLabel implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 画面で実績入力後のみ出力 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: HT/SDで実績入力後のみ出力 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 出力する */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, ResultAfterProductLabel> _codeClsMap = new HashMap<String, ResultAfterProductLabel>();
        private static final Map<String, ResultAfterProductLabel> _nameClsMap = new HashMap<String, ResultAfterProductLabel>();
        static {
            for (ResultAfterProductLabel value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ResultAfterProductLabel(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ResultAfterProductLabel; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultAfterProductLabel> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ResultAfterProductLabel) { return OptionalThing.of((ResultAfterProductLabel)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultAfterProductLabel> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ResultAfterProductLabel codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ResultAfterProductLabel) { return (ResultAfterProductLabel)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ResultAfterProductLabel nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ResultAfterProductLabel> listAll() {
            return new ArrayList<ResultAfterProductLabel>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ResultAfterProductLabel> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ResultAfterProductLabel." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ResultAfterProductLabel> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ResultAfterProductLabel> clsList = new ArrayList<ResultAfterProductLabel>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ResultAfterProductLabel> groupOf(String groupName) {
            return new ArrayList<ResultAfterProductLabel>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 実績入力後入庫/商品ラベル出力対象
     */
    public enum ResultAfterProductTarget implements CDef {
        /** $1: 入庫ラベル */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 商品ラベル */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ResultAfterProductTarget> _codeClsMap = new HashMap<String, ResultAfterProductTarget>();
        private static final Map<String, ResultAfterProductTarget> _nameClsMap = new HashMap<String, ResultAfterProductTarget>();
        static {
            for (ResultAfterProductTarget value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ResultAfterProductTarget(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ResultAfterProductTarget; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultAfterProductTarget> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ResultAfterProductTarget) { return OptionalThing.of((ResultAfterProductTarget)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultAfterProductTarget> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ResultAfterProductTarget codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ResultAfterProductTarget) { return (ResultAfterProductTarget)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ResultAfterProductTarget nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ResultAfterProductTarget> listAll() {
            return new ArrayList<ResultAfterProductTarget>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ResultAfterProductTarget> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ResultAfterProductTarget." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ResultAfterProductTarget> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ResultAfterProductTarget> clsList = new ArrayList<ResultAfterProductTarget>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ResultAfterProductTarget> groupOf(String groupName) {
            return new ArrayList<ResultAfterProductTarget>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 期限日出荷制限フラグ
     */
    public enum ReverseValidFlg implements CDef {
        /** $0: 無効 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 有効 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReverseValidFlg> _codeClsMap = new HashMap<String, ReverseValidFlg>();
        private static final Map<String, ReverseValidFlg> _nameClsMap = new HashMap<String, ReverseValidFlg>();
        static {
            for (ReverseValidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReverseValidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReverseValidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReverseValidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReverseValidFlg) { return OptionalThing.of((ReverseValidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReverseValidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReverseValidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReverseValidFlg) { return (ReverseValidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReverseValidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReverseValidFlg> listAll() {
            return new ArrayList<ReverseValidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReverseValidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReverseValidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReverseValidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReverseValidFlg> clsList = new ArrayList<ReverseValidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReverseValidFlg> groupOf(String groupName) {
            return new ArrayList<ReverseValidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 権限制御区分
     */
    public enum RoleControlClass implements CDef {
        /** $1: 許可を指定 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 拒否を指定 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, RoleControlClass> _codeClsMap = new HashMap<String, RoleControlClass>();
        private static final Map<String, RoleControlClass> _nameClsMap = new HashMap<String, RoleControlClass>();
        static {
            for (RoleControlClass value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RoleControlClass(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RoleControlClass; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RoleControlClass> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RoleControlClass) { return OptionalThing.of((RoleControlClass)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RoleControlClass> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RoleControlClass codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RoleControlClass) { return (RoleControlClass)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RoleControlClass nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RoleControlClass> listAll() {
            return new ArrayList<RoleControlClass>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RoleControlClass> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RoleControlClass." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RoleControlClass> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RoleControlClass> clsList = new ArrayList<RoleControlClass>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RoleControlClass> groupOf(String groupName) {
            return new ArrayList<RoleControlClass>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 選択
     */
    public enum Select implements CDef {
        /** $0: 選択しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 選択する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Select> _codeClsMap = new HashMap<String, Select>();
        private static final Map<String, Select> _nameClsMap = new HashMap<String, Select>();
        static {
            for (Select value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Select(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Select; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Select> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Select) { return OptionalThing.of((Select)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Select> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Select codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Select) { return (Select)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Select nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Select> listAll() {
            return new ArrayList<Select>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Select> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Select." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Select> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Select> clsList = new ArrayList<Select>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Select> groupOf(String groupName) {
            return new ArrayList<Select>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷サービスステータス
     */
    public enum SelectPrintServiceStatus implements CDef {
        /** $0: サービス中 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: サービス停止中 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SelectPrintServiceStatus> _codeClsMap = new HashMap<String, SelectPrintServiceStatus>();
        private static final Map<String, SelectPrintServiceStatus> _nameClsMap = new HashMap<String, SelectPrintServiceStatus>();
        static {
            for (SelectPrintServiceStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SelectPrintServiceStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SelectPrintServiceStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SelectPrintServiceStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SelectPrintServiceStatus) { return OptionalThing.of((SelectPrintServiceStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SelectPrintServiceStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SelectPrintServiceStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SelectPrintServiceStatus) { return (SelectPrintServiceStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SelectPrintServiceStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SelectPrintServiceStatus> listAll() {
            return new ArrayList<SelectPrintServiceStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SelectPrintServiceStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SelectPrintServiceStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SelectPrintServiceStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SelectPrintServiceStatus> clsList = new ArrayList<SelectPrintServiceStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SelectPrintServiceStatus> groupOf(String groupName) {
            return new ArrayList<SelectPrintServiceStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 処理区分
     */
    public enum SerialOperationType implements CDef {
        /** $1: 入荷 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 出荷 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 削除 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, SerialOperationType> _codeClsMap = new HashMap<String, SerialOperationType>();
        private static final Map<String, SerialOperationType> _nameClsMap = new HashMap<String, SerialOperationType>();
        static {
            for (SerialOperationType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SerialOperationType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SerialOperationType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SerialOperationType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SerialOperationType) { return OptionalThing.of((SerialOperationType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SerialOperationType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SerialOperationType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SerialOperationType) { return (SerialOperationType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SerialOperationType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SerialOperationType> listAll() {
            return new ArrayList<SerialOperationType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SerialOperationType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SerialOperationType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SerialOperationType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SerialOperationType> clsList = new ArrayList<SerialOperationType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SerialOperationType> groupOf(String groupName) {
            return new ArrayList<SerialOperationType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 決済種別
     */
    public enum SettlementType implements CDef {
        /** $0: 指定なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全て可 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 現金のみ */
        $2("2", "$2", emptyStrings())
        ,
        /** $5: ﾃﾞﾋﾞｯﾄ･ｸﾚｼﾞｯﾄ */
        $5("5", "$5", emptyStrings())
        ;
        private static final Map<String, SettlementType> _codeClsMap = new HashMap<String, SettlementType>();
        private static final Map<String, SettlementType> _nameClsMap = new HashMap<String, SettlementType>();
        static {
            for (SettlementType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SettlementType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SettlementType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SettlementType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SettlementType) { return OptionalThing.of((SettlementType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SettlementType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SettlementType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SettlementType) { return (SettlementType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SettlementType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SettlementType> listAll() {
            return new ArrayList<SettlementType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SettlementType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SettlementType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SettlementType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SettlementType> clsList = new ArrayList<SettlementType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SettlementType> groupOf(String groupName) {
            return new ArrayList<SettlementType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 単行出荷検品荷札/納品明細出力区分
     */
    public enum SglRowInspAfterOutCls implements CDef {
        /** $1: 最初の商品検品後に出力 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 随時出力 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 最後の商品検品後に出力 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, SglRowInspAfterOutCls> _codeClsMap = new HashMap<String, SglRowInspAfterOutCls>();
        private static final Map<String, SglRowInspAfterOutCls> _nameClsMap = new HashMap<String, SglRowInspAfterOutCls>();
        static {
            for (SglRowInspAfterOutCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SglRowInspAfterOutCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SglRowInspAfterOutCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowInspAfterOutCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SglRowInspAfterOutCls) { return OptionalThing.of((SglRowInspAfterOutCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowInspAfterOutCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SglRowInspAfterOutCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SglRowInspAfterOutCls) { return (SglRowInspAfterOutCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SglRowInspAfterOutCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SglRowInspAfterOutCls> listAll() {
            return new ArrayList<SglRowInspAfterOutCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SglRowInspAfterOutCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SglRowInspAfterOutCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SglRowInspAfterOutCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SglRowInspAfterOutCls> clsList = new ArrayList<SglRowInspAfterOutCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SglRowInspAfterOutCls> groupOf(String groupName) {
            return new ArrayList<SglRowInspAfterOutCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 単行ピックフラグ
     */
    public enum SglRowPicFlg implements CDef {
        /** $0: 単行ピック無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 単行ピック有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SglRowPicFlg> _codeClsMap = new HashMap<String, SglRowPicFlg>();
        private static final Map<String, SglRowPicFlg> _nameClsMap = new HashMap<String, SglRowPicFlg>();
        static {
            for (SglRowPicFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SglRowPicFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SglRowPicFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowPicFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SglRowPicFlg) { return OptionalThing.of((SglRowPicFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowPicFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SglRowPicFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SglRowPicFlg) { return (SglRowPicFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SglRowPicFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SglRowPicFlg> listAll() {
            return new ArrayList<SglRowPicFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SglRowPicFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SglRowPicFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SglRowPicFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SglRowPicFlg> clsList = new ArrayList<SglRowPicFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SglRowPicFlg> groupOf(String groupName) {
            return new ArrayList<SglRowPicFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 部単位印刷要否
     */
    public enum SheetCollate implements CDef {
        /** $0: ページ毎印刷 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 部単位で印刷 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SheetCollate> _codeClsMap = new HashMap<String, SheetCollate>();
        private static final Map<String, SheetCollate> _nameClsMap = new HashMap<String, SheetCollate>();
        static {
            for (SheetCollate value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SheetCollate(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SheetCollate; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SheetCollate> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SheetCollate) { return OptionalThing.of((SheetCollate)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SheetCollate> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SheetCollate codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SheetCollate) { return (SheetCollate)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SheetCollate nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SheetCollate> listAll() {
            return new ArrayList<SheetCollate>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SheetCollate> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SheetCollate." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SheetCollate> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SheetCollate> clsList = new ArrayList<SheetCollate>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SheetCollate> groupOf(String groupName) {
            return new ArrayList<SheetCollate>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷フラグ
     */
    public enum ShippingFlg implements CDef {
        /** $0: 出荷対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShippingFlg> _codeClsMap = new HashMap<String, ShippingFlg>();
        private static final Map<String, ShippingFlg> _nameClsMap = new HashMap<String, ShippingFlg>();
        static {
            for (ShippingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingFlg) { return OptionalThing.of((ShippingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingFlg) { return (ShippingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingFlg> listAll() {
            return new ArrayList<ShippingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingFlg> clsList = new ArrayList<ShippingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingFlg> groupOf(String groupName) {
            return new ArrayList<ShippingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷ステータス
     */
    public enum ShippingStatus implements CDef {
        /** $10: 未出荷 */
        $10("10", "$10", emptyStrings())
        ,
        /** $15: 出庫指示中 */
        $15("15", "$15", emptyStrings())
        ,
        /** $20: 出庫指示解除中 */
        $20("20", "$20", emptyStrings())
        ,
        /** $25: 出庫指示済 */
        $25("25", "$25", emptyStrings())
        ,
        /** $30: ピッキング中 */
        $30("30", "$30", emptyStrings())
        ,
        /** $35: ピッキング済 */
        $35("35", "$35", emptyStrings())
        ,
        /** $40: 出荷検品中 */
        $40("40", "$40", emptyStrings())
        ,
        /** $45: 出荷検品中断 */
        $45("45", "$45", emptyStrings())
        ,
        /** $50: 出荷検品済 */
        $50("50", "$50", emptyStrings())
        ,
        /** $55: 出荷確定済 */
        $55("55", "$55", emptyStrings())
        ,
        /** $90: キャンセル */
        $90("90", "$90", emptyStrings())
        ,
        /** $99: エラー有 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, ShippingStatus> _codeClsMap = new HashMap<String, ShippingStatus>();
        private static final Map<String, ShippingStatus> _nameClsMap = new HashMap<String, ShippingStatus>();
        static {
            for (ShippingStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingStatus) { return OptionalThing.of((ShippingStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingStatus) { return (ShippingStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingStatus> listAll() {
            return new ArrayList<ShippingStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingStatus> clsList = new ArrayList<ShippingStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingStatus> groupOf(String groupName) {
            return new ArrayList<ShippingStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷停止フラグ
     */
    public enum ShippingStopFlg implements CDef {
        /** $0: 出荷可能 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷停止 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShippingStopFlg> _codeClsMap = new HashMap<String, ShippingStopFlg>();
        private static final Map<String, ShippingStopFlg> _nameClsMap = new HashMap<String, ShippingStopFlg>();
        static {
            for (ShippingStopFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingStopFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingStopFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingStopFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingStopFlg) { return OptionalThing.of((ShippingStopFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingStopFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingStopFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingStopFlg) { return (ShippingStopFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingStopFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingStopFlg> listAll() {
            return new ArrayList<ShippingStopFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingStopFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingStopFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingStopFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingStopFlg> clsList = new ArrayList<ShippingStopFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingStopFlg> groupOf(String groupName) {
            return new ArrayList<ShippingStopFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品表示区分
     */
    public enum ShortStockDisplay implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 欠品のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShortStockDisplay> _codeClsMap = new HashMap<String, ShortStockDisplay>();
        private static final Map<String, ShortStockDisplay> _nameClsMap = new HashMap<String, ShortStockDisplay>();
        static {
            for (ShortStockDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShortStockDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShortStockDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShortStockDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShortStockDisplay) { return OptionalThing.of((ShortStockDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShortStockDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShortStockDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShortStockDisplay) { return (ShortStockDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShortStockDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShortStockDisplay> listAll() {
            return new ArrayList<ShortStockDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShortStockDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShortStockDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShortStockDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShortStockDisplay> clsList = new ArrayList<ShortStockDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShortStockDisplay> groupOf(String groupName) {
            return new ArrayList<ShortStockDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷検品区分
     */
    public enum ShpCheckCls implements CDef {
        /** $0: ピース検品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ケース検品 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShpCheckCls> _codeClsMap = new HashMap<String, ShpCheckCls>();
        private static final Map<String, ShpCheckCls> _nameClsMap = new HashMap<String, ShpCheckCls>();
        static {
            for (ShpCheckCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShpCheckCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShpCheckCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShpCheckCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShpCheckCls) { return OptionalThing.of((ShpCheckCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShpCheckCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShpCheckCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShpCheckCls) { return (ShpCheckCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShpCheckCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShpCheckCls> listAll() {
            return new ArrayList<ShpCheckCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShpCheckCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShpCheckCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShpCheckCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShpCheckCls> clsList = new ArrayList<ShpCheckCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShpCheckCls> groupOf(String groupName) {
            return new ArrayList<ShpCheckCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未検品表示区分
     */
    public enum ShpCheckDisplay implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 未検品のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShpCheckDisplay> _codeClsMap = new HashMap<String, ShpCheckDisplay>();
        private static final Map<String, ShpCheckDisplay> _nameClsMap = new HashMap<String, ShpCheckDisplay>();
        static {
            for (ShpCheckDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShpCheckDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShpCheckDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShpCheckDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShpCheckDisplay) { return OptionalThing.of((ShpCheckDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShpCheckDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShpCheckDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShpCheckDisplay) { return (ShpCheckDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShpCheckDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShpCheckDisplay> listAll() {
            return new ArrayList<ShpCheckDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShpCheckDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShpCheckDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShpCheckDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShpCheckDisplay> clsList = new ArrayList<ShpCheckDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShpCheckDisplay> groupOf(String groupName) {
            return new ArrayList<ShpCheckDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状種別
     */
    public enum SlipType implements CDef {
        /** $0: 発払い */
        $0("0", "$0", emptyStrings())
        ,
        /** $2: コレクト */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: メール便 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: タイム */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 着払い */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: メール便速達サービス */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, SlipType> _codeClsMap = new HashMap<String, SlipType>();
        private static final Map<String, SlipType> _nameClsMap = new HashMap<String, SlipType>();
        static {
            for (SlipType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SlipType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SlipType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SlipType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SlipType) { return OptionalThing.of((SlipType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SlipType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SlipType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SlipType) { return (SlipType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SlipType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SlipType> listAll() {
            return new ArrayList<SlipType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SlipType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SlipType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SlipType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SlipType> clsList = new ArrayList<SlipType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SlipType> groupOf(String groupName) {
            return new ArrayList<SlipType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 操作音再生フラグ
     */
    public enum SoundPlayFlg implements CDef {
        /** $0: 再生しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 再生する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SoundPlayFlg> _codeClsMap = new HashMap<String, SoundPlayFlg>();
        private static final Map<String, SoundPlayFlg> _nameClsMap = new HashMap<String, SoundPlayFlg>();
        static {
            for (SoundPlayFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SoundPlayFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SoundPlayFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SoundPlayFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SoundPlayFlg) { return OptionalThing.of((SoundPlayFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SoundPlayFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SoundPlayFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SoundPlayFlg) { return (SoundPlayFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SoundPlayFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SoundPlayFlg> listAll() {
            return new ArrayList<SoundPlayFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SoundPlayFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SoundPlayFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SoundPlayFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SoundPlayFlg> clsList = new ArrayList<SoundPlayFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SoundPlayFlg> groupOf(String groupName) {
            return new ArrayList<SoundPlayFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫調整フラグ
     */
    public enum StockAdjustFlg implements CDef {
        /** $0: 在庫調整対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 在庫調整対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockAdjustFlg> _codeClsMap = new HashMap<String, StockAdjustFlg>();
        private static final Map<String, StockAdjustFlg> _nameClsMap = new HashMap<String, StockAdjustFlg>();
        static {
            for (StockAdjustFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockAdjustFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockAdjustFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockAdjustFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockAdjustFlg) { return OptionalThing.of((StockAdjustFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockAdjustFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockAdjustFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockAdjustFlg) { return (StockAdjustFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockAdjustFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockAdjustFlg> listAll() {
            return new ArrayList<StockAdjustFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockAdjustFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockAdjustFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockAdjustFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockAdjustFlg> clsList = new ArrayList<StockAdjustFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockAdjustFlg> groupOf(String groupName) {
            return new ArrayList<StockAdjustFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫表示内容
     */
    public enum StockDisplayFld implements CDef {
        /** $0: 商品順（日報なし） */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 商品順（日報あり） */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ロケーション順（日報なし） */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ロケーション順（日報あり） */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, StockDisplayFld> _codeClsMap = new HashMap<String, StockDisplayFld>();
        private static final Map<String, StockDisplayFld> _nameClsMap = new HashMap<String, StockDisplayFld>();
        static {
            for (StockDisplayFld value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockDisplayFld(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockDisplayFld; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockDisplayFld> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockDisplayFld) { return OptionalThing.of((StockDisplayFld)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockDisplayFld> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockDisplayFld codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockDisplayFld) { return (StockDisplayFld)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockDisplayFld nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockDisplayFld> listAll() {
            return new ArrayList<StockDisplayFld>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockDisplayFld> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockDisplayFld." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockDisplayFld> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockDisplayFld> clsList = new ArrayList<StockDisplayFld>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockDisplayFld> groupOf(String groupName) {
            return new ArrayList<StockDisplayFld>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫有のみフラグ
     */
    public enum StockExistOnlyFlg implements CDef {
        /** $0: 全て */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 在庫有のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockExistOnlyFlg> _codeClsMap = new HashMap<String, StockExistOnlyFlg>();
        private static final Map<String, StockExistOnlyFlg> _nameClsMap = new HashMap<String, StockExistOnlyFlg>();
        static {
            for (StockExistOnlyFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockExistOnlyFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockExistOnlyFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockExistOnlyFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockExistOnlyFlg) { return OptionalThing.of((StockExistOnlyFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockExistOnlyFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockExistOnlyFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockExistOnlyFlg) { return (StockExistOnlyFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockExistOnlyFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockExistOnlyFlg> listAll() {
            return new ArrayList<StockExistOnlyFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockExistOnlyFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockExistOnlyFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockExistOnlyFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockExistOnlyFlg> clsList = new ArrayList<StockExistOnlyFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockExistOnlyFlg> groupOf(String groupName) {
            return new ArrayList<StockExistOnlyFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫調整フラグ
     */
    public enum StockMoveFlg implements CDef {
        /** $0: 未調整 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 調整済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockMoveFlg> _codeClsMap = new HashMap<String, StockMoveFlg>();
        private static final Map<String, StockMoveFlg> _nameClsMap = new HashMap<String, StockMoveFlg>();
        static {
            for (StockMoveFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockMoveFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockMoveFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockMoveFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockMoveFlg) { return OptionalThing.of((StockMoveFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockMoveFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockMoveFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockMoveFlg) { return (StockMoveFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockMoveFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockMoveFlg> listAll() {
            return new ArrayList<StockMoveFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockMoveFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockMoveFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockMoveFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockMoveFlg> clsList = new ArrayList<StockMoveFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockMoveFlg> groupOf(String groupName) {
            return new ArrayList<StockMoveFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫数 0非表示
     */
    public enum StockNum0Display implements CDef {
        /** $0: 0表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 0非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockNum0Display> _codeClsMap = new HashMap<String, StockNum0Display>();
        private static final Map<String, StockNum0Display> _nameClsMap = new HashMap<String, StockNum0Display>();
        static {
            for (StockNum0Display value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockNum0Display(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockNum0Display; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockNum0Display> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockNum0Display) { return OptionalThing.of((StockNum0Display)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockNum0Display> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockNum0Display codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockNum0Display) { return (StockNum0Display)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockNum0Display nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockNum0Display> listAll() {
            return new ArrayList<StockNum0Display>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockNum0Display> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockNum0Display." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockNum0Display> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockNum0Display> clsList = new ArrayList<StockNum0Display>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockNum0Display> groupOf(String groupName) {
            return new ArrayList<StockNum0Display>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品時引当区分
     */
    public enum StockOutAllocCls implements CDef {
        /** $0: 引当可能数を引当 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 商品毎に0引当 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 納品先毎に0引当 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, StockOutAllocCls> _codeClsMap = new HashMap<String, StockOutAllocCls>();
        private static final Map<String, StockOutAllocCls> _nameClsMap = new HashMap<String, StockOutAllocCls>();
        static {
            for (StockOutAllocCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutAllocCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutAllocCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutAllocCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutAllocCls) { return OptionalThing.of((StockOutAllocCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutAllocCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutAllocCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutAllocCls) { return (StockOutAllocCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutAllocCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutAllocCls> listAll() {
            return new ArrayList<StockOutAllocCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutAllocCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutAllocCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutAllocCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutAllocCls> clsList = new ArrayList<StockOutAllocCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutAllocCls> groupOf(String groupName) {
            return new ArrayList<StockOutAllocCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品時自動出庫指示フラグ
     */
    public enum StockOutAutoInstFlg implements CDef {
        /** $0: 自動出庫指示に含めない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 自動出庫指示に含める */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockOutAutoInstFlg> _codeClsMap = new HashMap<String, StockOutAutoInstFlg>();
        private static final Map<String, StockOutAutoInstFlg> _nameClsMap = new HashMap<String, StockOutAutoInstFlg>();
        static {
            for (StockOutAutoInstFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutAutoInstFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutAutoInstFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutAutoInstFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutAutoInstFlg) { return OptionalThing.of((StockOutAutoInstFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutAutoInstFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutAutoInstFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutAutoInstFlg) { return (StockOutAutoInstFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutAutoInstFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutAutoInstFlg> listAll() {
            return new ArrayList<StockOutAutoInstFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutAutoInstFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutAutoInstFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutAutoInstFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutAutoInstFlg> clsList = new ArrayList<StockOutAutoInstFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutAutoInstFlg> groupOf(String groupName) {
            return new ArrayList<StockOutAutoInstFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品フラグ
     */
    public enum StockOutFlg implements CDef {
        /** $0: 欠品無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 欠品有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockOutFlg> _codeClsMap = new HashMap<String, StockOutFlg>();
        private static final Map<String, StockOutFlg> _nameClsMap = new HashMap<String, StockOutFlg>();
        static {
            for (StockOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutFlg) { return OptionalThing.of((StockOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutFlg) { return (StockOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutFlg> listAll() {
            return new ArrayList<StockOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutFlg> clsList = new ArrayList<StockOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutFlg> groupOf(String groupName) {
            return new ArrayList<StockOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品時出庫指示取消フラグ
     */
    public enum StockOutInstCxlFlg implements CDef {
        /** $0: 出庫指示を取消しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出庫指示を取消 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockOutInstCxlFlg> _codeClsMap = new HashMap<String, StockOutInstCxlFlg>();
        private static final Map<String, StockOutInstCxlFlg> _nameClsMap = new HashMap<String, StockOutInstCxlFlg>();
        static {
            for (StockOutInstCxlFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutInstCxlFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutInstCxlFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutInstCxlFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutInstCxlFlg) { return OptionalThing.of((StockOutInstCxlFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutInstCxlFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutInstCxlFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutInstCxlFlg) { return (StockOutInstCxlFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutInstCxlFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutInstCxlFlg> listAll() {
            return new ArrayList<StockOutInstCxlFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutInstCxlFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutInstCxlFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutInstCxlFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutInstCxlFlg> clsList = new ArrayList<StockOutInstCxlFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutInstCxlFlg> groupOf(String groupName) {
            return new ArrayList<StockOutInstCxlFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品時出荷指示分離フラグ
     */
    public enum StockOutInstSplitFlg implements CDef {
        /** $0: 分離しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 分離する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockOutInstSplitFlg> _codeClsMap = new HashMap<String, StockOutInstSplitFlg>();
        private static final Map<String, StockOutInstSplitFlg> _nameClsMap = new HashMap<String, StockOutInstSplitFlg>();
        static {
            for (StockOutInstSplitFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutInstSplitFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutInstSplitFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutInstSplitFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutInstSplitFlg) { return OptionalThing.of((StockOutInstSplitFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutInstSplitFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutInstSplitFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutInstSplitFlg) { return (StockOutInstSplitFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutInstSplitFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutInstSplitFlg> listAll() {
            return new ArrayList<StockOutInstSplitFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutInstSplitFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutInstSplitFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutInstSplitFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutInstSplitFlg> clsList = new ArrayList<StockOutInstSplitFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutInstSplitFlg> groupOf(String groupName) {
            return new ArrayList<StockOutInstSplitFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫数表示
     */
    public enum StockQtyDisplay implements CDef {
        /** $0: 表示しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockQtyDisplay> _codeClsMap = new HashMap<String, StockQtyDisplay>();
        private static final Map<String, StockQtyDisplay> _nameClsMap = new HashMap<String, StockQtyDisplay>();
        static {
            for (StockQtyDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockQtyDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockQtyDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockQtyDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockQtyDisplay) { return OptionalThing.of((StockQtyDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockQtyDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockQtyDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockQtyDisplay) { return (StockQtyDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockQtyDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockQtyDisplay> listAll() {
            return new ArrayList<StockQtyDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockQtyDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockQtyDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockQtyDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockQtyDisplay> clsList = new ArrayList<StockQtyDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockQtyDisplay> groupOf(String groupName) {
            return new ArrayList<StockQtyDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸データ有
     */
    public enum StockTakingInput implements CDef {
        /** $0: 棚卸入力無のみ表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 棚卸入力有のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockTakingInput> _codeClsMap = new HashMap<String, StockTakingInput>();
        private static final Map<String, StockTakingInput> _nameClsMap = new HashMap<String, StockTakingInput>();
        static {
            for (StockTakingInput value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockTakingInput(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockTakingInput; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTakingInput> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockTakingInput) { return OptionalThing.of((StockTakingInput)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTakingInput> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockTakingInput codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockTakingInput) { return (StockTakingInput)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockTakingInput nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockTakingInput> listAll() {
            return new ArrayList<StockTakingInput>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockTakingInput> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockTakingInput." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockTakingInput> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockTakingInput> clsList = new ArrayList<StockTakingInput>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockTakingInput> groupOf(String groupName) {
            return new ArrayList<StockTakingInput>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫対象
     */
    public enum StockTarget implements CDef {
        /** $0: 全部対象 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 引当可能数＋引当済数＞０ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockTarget> _codeClsMap = new HashMap<String, StockTarget>();
        private static final Map<String, StockTarget> _nameClsMap = new HashMap<String, StockTarget>();
        static {
            for (StockTarget value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockTarget(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockTarget; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTarget> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockTarget) { return OptionalThing.of((StockTarget)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTarget> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockTarget codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockTarget) { return (StockTarget)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockTarget nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockTarget> listAll() {
            return new ArrayList<StockTarget>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockTarget> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockTarget." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockTarget> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockTarget> clsList = new ArrayList<StockTarget>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockTarget> groupOf(String groupName) {
            return new ArrayList<StockTarget>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫日管理フラグ
     */
    public enum StoreDtFlg implements CDef {
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreDtFlg> _codeClsMap = new HashMap<String, StoreDtFlg>();
        private static final Map<String, StoreDtFlg> _nameClsMap = new HashMap<String, StoreDtFlg>();
        static {
            for (StoreDtFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreDtFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreDtFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreDtFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreDtFlg) { return OptionalThing.of((StoreDtFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreDtFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreDtFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreDtFlg) { return (StoreDtFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreDtFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreDtFlg> listAll() {
            return new ArrayList<StoreDtFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreDtFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreDtFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreDtFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreDtFlg> clsList = new ArrayList<StoreDtFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreDtFlg> groupOf(String groupName) {
            return new ArrayList<StoreDtFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 格納フラグ
     */
    public enum StoreFlg implements CDef {
        /** $0: 未格納 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 格納 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreFlg> _codeClsMap = new HashMap<String, StoreFlg>();
        private static final Map<String, StoreFlg> _nameClsMap = new HashMap<String, StoreFlg>();
        static {
            for (StoreFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreFlg) { return OptionalThing.of((StoreFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreFlg) { return (StoreFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreFlg> listAll() {
            return new ArrayList<StoreFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreFlg> clsList = new ArrayList<StoreFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreFlg> groupOf(String groupName) {
            return new ArrayList<StoreFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫No.分割表示
     */
    public enum StoreNoDivideDisplay implements CDef {
        /** $0: 表示しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreNoDivideDisplay> _codeClsMap = new HashMap<String, StoreNoDivideDisplay>();
        private static final Map<String, StoreNoDivideDisplay> _nameClsMap = new HashMap<String, StoreNoDivideDisplay>();
        static {
            for (StoreNoDivideDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreNoDivideDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreNoDivideDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoDivideDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreNoDivideDisplay) { return OptionalThing.of((StoreNoDivideDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoDivideDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreNoDivideDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreNoDivideDisplay) { return (StoreNoDivideDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreNoDivideDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreNoDivideDisplay> listAll() {
            return new ArrayList<StoreNoDivideDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreNoDivideDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreNoDivideDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreNoDivideDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreNoDivideDisplay> clsList = new ArrayList<StoreNoDivideDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreNoDivideDisplay> groupOf(String groupName) {
            return new ArrayList<StoreNoDivideDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫No.管理フラグ
     */
    public enum StoreNoFlg implements CDef {
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreNoFlg> _codeClsMap = new HashMap<String, StoreNoFlg>();
        private static final Map<String, StoreNoFlg> _nameClsMap = new HashMap<String, StoreNoFlg>();
        static {
            for (StoreNoFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreNoFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreNoFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreNoFlg) { return OptionalThing.of((StoreNoFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreNoFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreNoFlg) { return (StoreNoFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreNoFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreNoFlg> listAll() {
            return new ArrayList<StoreNoFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreNoFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreNoFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreNoFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreNoFlg> clsList = new ArrayList<StoreNoFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreNoFlg> groupOf(String groupName) {
            return new ArrayList<StoreNoFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫No.マージフラグ
     */
    public enum StoreNoMergeFlg implements CDef {
        /** $0: マージしない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: マージする */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreNoMergeFlg> _codeClsMap = new HashMap<String, StoreNoMergeFlg>();
        private static final Map<String, StoreNoMergeFlg> _nameClsMap = new HashMap<String, StoreNoMergeFlg>();
        static {
            for (StoreNoMergeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreNoMergeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreNoMergeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoMergeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreNoMergeFlg) { return OptionalThing.of((StoreNoMergeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoMergeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreNoMergeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreNoMergeFlg) { return (StoreNoMergeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreNoMergeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreNoMergeFlg> listAll() {
            return new ArrayList<StoreNoMergeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreNoMergeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreNoMergeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreNoMergeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreNoMergeFlg> clsList = new ArrayList<StoreNoMergeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreNoMergeFlg> groupOf(String groupName) {
            return new ArrayList<StoreNoMergeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * システムログステータス
     */
    public enum SystemLogStatus implements CDef {
        /** $1: 正常 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 異常 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, SystemLogStatus> _codeClsMap = new HashMap<String, SystemLogStatus>();
        private static final Map<String, SystemLogStatus> _nameClsMap = new HashMap<String, SystemLogStatus>();
        static {
            for (SystemLogStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SystemLogStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SystemLogStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemLogStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SystemLogStatus) { return OptionalThing.of((SystemLogStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemLogStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SystemLogStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SystemLogStatus) { return (SystemLogStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SystemLogStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SystemLogStatus> listAll() {
            return new ArrayList<SystemLogStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SystemLogStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SystemLogStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SystemLogStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SystemLogStatus> clsList = new ArrayList<SystemLogStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SystemLogStatus> groupOf(String groupName) {
            return new ArrayList<SystemLogStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * システムログ種別
     */
    public enum SystemLogType implements CDef {
        /** $1: 通常 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: SQL(SELECT) */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: SQL(INSERT) */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: SQL(UPDATE) */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: SQL(DELETE) */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: SQL(OTHERS) */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, SystemLogType> _codeClsMap = new HashMap<String, SystemLogType>();
        private static final Map<String, SystemLogType> _nameClsMap = new HashMap<String, SystemLogType>();
        static {
            for (SystemLogType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SystemLogType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SystemLogType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemLogType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SystemLogType) { return OptionalThing.of((SystemLogType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemLogType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SystemLogType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SystemLogType) { return (SystemLogType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SystemLogType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SystemLogType> listAll() {
            return new ArrayList<SystemLogType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SystemLogType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SystemLogType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SystemLogType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SystemLogType> clsList = new ArrayList<SystemLogType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SystemLogType> groupOf(String groupName) {
            return new ArrayList<SystemLogType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * システム種別
     */
    public enum SystemType implements CDef {
        /** $base: 基盤 */
        $base("base", "$base", emptyStrings())
        ,
        /** $wms: WMS */
        $wms("wms", "$wms", emptyStrings())
        ,
        /** $tsn: tsn */
        $tsn("tsn", "$tsn", emptyStrings())
        ;
        private static final Map<String, SystemType> _codeClsMap = new HashMap<String, SystemType>();
        private static final Map<String, SystemType> _nameClsMap = new HashMap<String, SystemType>();
        static {
            for (SystemType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SystemType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SystemType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SystemType) { return OptionalThing.of((SystemType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SystemType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SystemType) { return (SystemType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SystemType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SystemType> listAll() {
            return new ArrayList<SystemType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SystemType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SystemType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SystemType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SystemType> clsList = new ArrayList<SystemType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SystemType> groupOf(String groupName) {
            return new ArrayList<SystemType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷札納品書在中出力フラグ
     */
    public enum TagDeliveryOutFlg implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 1枚目のみ出力 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, TagDeliveryOutFlg> _codeClsMap = new HashMap<String, TagDeliveryOutFlg>();
        private static final Map<String, TagDeliveryOutFlg> _nameClsMap = new HashMap<String, TagDeliveryOutFlg>();
        static {
            for (TagDeliveryOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TagDeliveryOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TagDeliveryOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TagDeliveryOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TagDeliveryOutFlg) { return OptionalThing.of((TagDeliveryOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TagDeliveryOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TagDeliveryOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TagDeliveryOutFlg) { return (TagDeliveryOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TagDeliveryOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TagDeliveryOutFlg> listAll() {
            return new ArrayList<TagDeliveryOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TagDeliveryOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TagDeliveryOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TagDeliveryOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TagDeliveryOutFlg> clsList = new ArrayList<TagDeliveryOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TagDeliveryOutFlg> groupOf(String groupName) {
            return new ArrayList<TagDeliveryOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業日/出荷日/納品日区分
     */
    public enum TakingShippingDtFlg implements CDef {
        /** $0: 作業日 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷日 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 納品日 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, TakingShippingDtFlg> _codeClsMap = new HashMap<String, TakingShippingDtFlg>();
        private static final Map<String, TakingShippingDtFlg> _nameClsMap = new HashMap<String, TakingShippingDtFlg>();
        static {
            for (TakingShippingDtFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TakingShippingDtFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TakingShippingDtFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TakingShippingDtFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TakingShippingDtFlg) { return OptionalThing.of((TakingShippingDtFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TakingShippingDtFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TakingShippingDtFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TakingShippingDtFlg) { return (TakingShippingDtFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TakingShippingDtFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TakingShippingDtFlg> listAll() {
            return new ArrayList<TakingShippingDtFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TakingShippingDtFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TakingShippingDtFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TakingShippingDtFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TakingShippingDtFlg> clsList = new ArrayList<TakingShippingDtFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TakingShippingDtFlg> groupOf(String groupName) {
            return new ArrayList<TakingShippingDtFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業日/出荷日区分
     */
    public enum TakingShippingFlg implements CDef {
        /** $0: 作業日 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷日 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, TakingShippingFlg> _codeClsMap = new HashMap<String, TakingShippingFlg>();
        private static final Map<String, TakingShippingFlg> _nameClsMap = new HashMap<String, TakingShippingFlg>();
        static {
            for (TakingShippingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TakingShippingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TakingShippingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TakingShippingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TakingShippingFlg) { return OptionalThing.of((TakingShippingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TakingShippingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TakingShippingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TakingShippingFlg) { return (TakingShippingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TakingShippingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TakingShippingFlg> listAll() {
            return new ArrayList<TakingShippingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TakingShippingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TakingShippingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TakingShippingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TakingShippingFlg> clsList = new ArrayList<TakingShippingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TakingShippingFlg> groupOf(String groupName) {
            return new ArrayList<TakingShippingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ターゲットウインドウ
     */
    public enum TargetWindow implements CDef {
        /** $0: 同一ウインドウで開く */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 別ウインドウを新規で開く */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 別ウインドウを同一画面で開く */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, TargetWindow> _codeClsMap = new HashMap<String, TargetWindow>();
        private static final Map<String, TargetWindow> _nameClsMap = new HashMap<String, TargetWindow>();
        static {
            for (TargetWindow value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TargetWindow(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TargetWindow; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetWindow> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TargetWindow) { return OptionalThing.of((TargetWindow)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetWindow> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TargetWindow codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TargetWindow) { return (TargetWindow)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TargetWindow nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TargetWindow> listAll() {
            return new ArrayList<TargetWindow>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TargetWindow> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TargetWindow." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TargetWindow> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TargetWindow> clsList = new ArrayList<TargetWindow>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TargetWindow> groupOf(String groupName) {
            return new ArrayList<TargetWindow>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 表示位置
     */
    public enum TextAlign implements CDef {
        /** $center: 中央揃え */
        $center("center", "$center", emptyStrings())
        ,
        /** $left: 左寄せ */
        $left("left", "$left", emptyStrings())
        ,
        /** $right: 右寄せ */
        $right("right", "$right", emptyStrings())
        ;
        private static final Map<String, TextAlign> _codeClsMap = new HashMap<String, TextAlign>();
        private static final Map<String, TextAlign> _nameClsMap = new HashMap<String, TextAlign>();
        static {
            for (TextAlign value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TextAlign(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TextAlign; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TextAlign> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TextAlign) { return OptionalThing.of((TextAlign)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TextAlign> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TextAlign codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TextAlign) { return (TextAlign)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TextAlign nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TextAlign> listAll() {
            return new ArrayList<TextAlign>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TextAlign> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TextAlign." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TextAlign> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TextAlign> clsList = new ArrayList<TextAlign>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TextAlign> groupOf(String groupName) {
            return new ArrayList<TextAlign>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * トータルピックフラグ
     */
    public enum TotalPicFlg implements CDef {
        /** $0: トータルピック無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: トータルピック有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, TotalPicFlg> _codeClsMap = new HashMap<String, TotalPicFlg>();
        private static final Map<String, TotalPicFlg> _nameClsMap = new HashMap<String, TotalPicFlg>();
        static {
            for (TotalPicFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TotalPicFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TotalPicFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TotalPicFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TotalPicFlg) { return OptionalThing.of((TotalPicFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TotalPicFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TotalPicFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TotalPicFlg) { return (TotalPicFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TotalPicFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TotalPicFlg> listAll() {
            return new ArrayList<TotalPicFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TotalPicFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TotalPicFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TotalPicFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TotalPicFlg> clsList = new ArrayList<TotalPicFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TotalPicFlg> groupOf(String groupName) {
            return new ArrayList<TotalPicFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 追跡番号採番単位
     */
    public enum TrackingNumberingUnit implements CDef {
        /** $1: 出庫作業No単位 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 梱包単位 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, TrackingNumberingUnit> _codeClsMap = new HashMap<String, TrackingNumberingUnit>();
        private static final Map<String, TrackingNumberingUnit> _nameClsMap = new HashMap<String, TrackingNumberingUnit>();
        static {
            for (TrackingNumberingUnit value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TrackingNumberingUnit(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TrackingNumberingUnit; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TrackingNumberingUnit> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TrackingNumberingUnit) { return OptionalThing.of((TrackingNumberingUnit)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TrackingNumberingUnit> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TrackingNumberingUnit codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TrackingNumberingUnit) { return (TrackingNumberingUnit)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TrackingNumberingUnit nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TrackingNumberingUnit> listAll() {
            return new ArrayList<TrackingNumberingUnit>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TrackingNumberingUnit> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TrackingNumberingUnit." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TrackingNumberingUnit> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TrackingNumberingUnit> clsList = new ArrayList<TrackingNumberingUnit>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TrackingNumberingUnit> groupOf(String groupName) {
            return new ArrayList<TrackingNumberingUnit>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 積送中在庫のみ表示
     */
    public enum TransitDisplay implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 積送中在庫のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, TransitDisplay> _codeClsMap = new HashMap<String, TransitDisplay>();
        private static final Map<String, TransitDisplay> _nameClsMap = new HashMap<String, TransitDisplay>();
        static {
            for (TransitDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TransitDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TransitDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TransitDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TransitDisplay) { return OptionalThing.of((TransitDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TransitDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TransitDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TransitDisplay) { return (TransitDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TransitDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TransitDisplay> listAll() {
            return new ArrayList<TransitDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TransitDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TransitDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TransitDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TransitDisplay> clsList = new ArrayList<TransitDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TransitDisplay> groupOf(String groupName) {
            return new ArrayList<TransitDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * アンマッチ有
     */
    public enum Unmatch implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: アンマッチ有のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Unmatch> _codeClsMap = new HashMap<String, Unmatch>();
        private static final Map<String, Unmatch> _nameClsMap = new HashMap<String, Unmatch>();
        static {
            for (Unmatch value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Unmatch(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Unmatch; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Unmatch> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Unmatch) { return OptionalThing.of((Unmatch)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Unmatch> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Unmatch codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Unmatch) { return (Unmatch)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Unmatch nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Unmatch> listAll() {
            return new ArrayList<Unmatch>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Unmatch> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Unmatch." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Unmatch> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Unmatch> clsList = new ArrayList<Unmatch>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Unmatch> groupOf(String groupName) {
            return new ArrayList<Unmatch>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 更新可否
     */
    public enum Updatable implements CDef {
        /** $0: 更新不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 更新可能 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Updatable> _codeClsMap = new HashMap<String, Updatable>();
        private static final Map<String, Updatable> _nameClsMap = new HashMap<String, Updatable>();
        static {
            for (Updatable value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Updatable(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Updatable; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Updatable> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Updatable) { return OptionalThing.of((Updatable)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Updatable> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Updatable codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Updatable) { return (Updatable)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Updatable nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Updatable> listAll() {
            return new ArrayList<Updatable>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Updatable> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Updatable." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Updatable> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Updatable> clsList = new ArrayList<Updatable>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Updatable> groupOf(String groupName) {
            return new ArrayList<Updatable>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 修正コード
     */
    public enum UpdCd implements CDef {
        /** $0: 修正なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 新規追加 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 廃止 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, UpdCd> _codeClsMap = new HashMap<String, UpdCd>();
        private static final Map<String, UpdCd> _nameClsMap = new HashMap<String, UpdCd>();
        static {
            for (UpdCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UpdCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UpdCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UpdCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UpdCd) { return OptionalThing.of((UpdCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UpdCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UpdCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UpdCd) { return (UpdCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UpdCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UpdCd> listAll() {
            return new ArrayList<UpdCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UpdCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UpdCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UpdCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UpdCd> clsList = new ArrayList<UpdCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UpdCd> groupOf(String groupName) {
            return new ArrayList<UpdCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 更新区分
     */
    public enum UpdType implements CDef {
        /** $0: 変更なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 変更あり */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 廃止 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, UpdType> _codeClsMap = new HashMap<String, UpdType>();
        private static final Map<String, UpdType> _nameClsMap = new HashMap<String, UpdType>();
        static {
            for (UpdType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UpdType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UpdType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UpdType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UpdType) { return OptionalThing.of((UpdType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UpdType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UpdType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UpdType) { return (UpdType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UpdType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UpdType> listAll() {
            return new ArrayList<UpdType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UpdType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UpdType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UpdType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UpdType> clsList = new ArrayList<UpdType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UpdType> groupOf(String groupName) {
            return new ArrayList<UpdType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * アップロードテーブル名
     */
    public enum UploadTableNm implements CDef {
        /** $tAmazonOrder: Amazon受注 */
        $tAmazonOrder("tAmazonOrder", "$tAmazonOrder", emptyStrings())
        ,
        /** $tRakutenOrder: 楽天RMS受注 */
        $tRakutenOrder("tRakutenOrder", "$tRakutenOrder", emptyStrings())
        ,
        /** $tYahooOrder: Yahoo受注 */
        $tYahooOrder("tYahooOrder", "$tYahooOrder", emptyStrings())
        ;
        private static final Map<String, UploadTableNm> _codeClsMap = new HashMap<String, UploadTableNm>();
        private static final Map<String, UploadTableNm> _nameClsMap = new HashMap<String, UploadTableNm>();
        static {
            for (UploadTableNm value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UploadTableNm(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UploadTableNm; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UploadTableNm> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UploadTableNm) { return OptionalThing.of((UploadTableNm)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UploadTableNm> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UploadTableNm codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UploadTableNm) { return (UploadTableNm)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UploadTableNm nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UploadTableNm> listAll() {
            return new ArrayList<UploadTableNm>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UploadTableNm> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UploadTableNm." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UploadTableNm> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UploadTableNm> clsList = new ArrayList<UploadTableNm>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UploadTableNm> groupOf(String groupName) {
            return new ArrayList<UploadTableNm>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ユーザ編集可否
     */
    public enum UserEditable implements CDef {
        /** $0: 否 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 可 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, UserEditable> _codeClsMap = new HashMap<String, UserEditable>();
        private static final Map<String, UserEditable> _nameClsMap = new HashMap<String, UserEditable>();
        static {
            for (UserEditable value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UserEditable(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UserEditable; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UserEditable> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UserEditable) { return OptionalThing.of((UserEditable)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UserEditable> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UserEditable codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UserEditable) { return (UserEditable)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UserEditable nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UserEditable> listAll() {
            return new ArrayList<UserEditable>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UserEditable> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UserEditable." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UserEditable> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UserEditable> clsList = new ArrayList<UserEditable>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UserEditable> groupOf(String groupName) {
            return new ArrayList<UserEditable>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * HT/SDケースピック使用フラグ
     */
    public enum UseHtShipFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, UseHtShipFlg> _codeClsMap = new HashMap<String, UseHtShipFlg>();
        private static final Map<String, UseHtShipFlg> _nameClsMap = new HashMap<String, UseHtShipFlg>();
        static {
            for (UseHtShipFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UseHtShipFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UseHtShipFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UseHtShipFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UseHtShipFlg) { return OptionalThing.of((UseHtShipFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UseHtShipFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UseHtShipFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UseHtShipFlg) { return (UseHtShipFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UseHtShipFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UseHtShipFlg> listAll() {
            return new ArrayList<UseHtShipFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UseHtShipFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UseHtShipFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UseHtShipFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UseHtShipFlg> clsList = new ArrayList<UseHtShipFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UseHtShipFlg> groupOf(String groupName) {
            return new ArrayList<UseHtShipFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕入先フラグ
     */
    public enum VendorFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, VendorFlg> _codeClsMap = new HashMap<String, VendorFlg>();
        private static final Map<String, VendorFlg> _nameClsMap = new HashMap<String, VendorFlg>();
        static {
            for (VendorFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private VendorFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.VendorFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<VendorFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof VendorFlg) { return OptionalThing.of((VendorFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<VendorFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static VendorFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof VendorFlg) { return (VendorFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static VendorFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<VendorFlg> listAll() {
            return new ArrayList<VendorFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<VendorFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: VendorFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<VendorFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<VendorFlg> clsList = new ArrayList<VendorFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<VendorFlg> groupOf(String groupName) {
            return new ArrayList<VendorFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 表示可否
     */
    public enum Visible implements CDef {
        /** $0: 非表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Visible> _codeClsMap = new HashMap<String, Visible>();
        private static final Map<String, Visible> _nameClsMap = new HashMap<String, Visible>();
        static {
            for (Visible value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Visible(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Visible; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Visible> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Visible) { return OptionalThing.of((Visible)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Visible> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Visible codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Visible) { return (Visible)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Visible nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Visible> listAll() {
            return new ArrayList<Visible>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Visible> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Visible." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Visible> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Visible> clsList = new ArrayList<Visible>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Visible> groupOf(String groupName) {
            return new ArrayList<Visible>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 処理済フラグ
     */
    public enum WorkFlg implements CDef {
        /** $0: 未処理 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 処理済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, WorkFlg> _codeClsMap = new HashMap<String, WorkFlg>();
        private static final Map<String, WorkFlg> _nameClsMap = new HashMap<String, WorkFlg>();
        static {
            for (WorkFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkFlg) { return OptionalThing.of((WorkFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkFlg) { return (WorkFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkFlg> listAll() {
            return new ArrayList<WorkFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkFlg> clsList = new ArrayList<WorkFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkFlg> groupOf(String groupName) {
            return new ArrayList<WorkFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業メッセージ有無
     */
    public enum WorkMessageFlg implements CDef {
        /** $0: メッセージ無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: メッセージ有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, WorkMessageFlg> _codeClsMap = new HashMap<String, WorkMessageFlg>();
        private static final Map<String, WorkMessageFlg> _nameClsMap = new HashMap<String, WorkMessageFlg>();
        static {
            for (WorkMessageFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkMessageFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkMessageFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkMessageFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkMessageFlg) { return OptionalThing.of((WorkMessageFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkMessageFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkMessageFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkMessageFlg) { return (WorkMessageFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkMessageFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkMessageFlg> listAll() {
            return new ArrayList<WorkMessageFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkMessageFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkMessageFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkMessageFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkMessageFlg> clsList = new ArrayList<WorkMessageFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkMessageFlg> groupOf(String groupName) {
            return new ArrayList<WorkMessageFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ヤマト配達時間帯
     */
    public enum YamatoDelivTz implements CDef {
        /** $0010: 午前10時まで */
        $0010("0010", "$0010", emptyStrings())
        ,
        /** $0017: 午後5時まで */
        $0017("0017", "$0017", emptyStrings())
        ,
        /** $0812: 午前中 */
        $0812("0812", "$0812", emptyStrings())
        ,
        /** $1214: 12時～14時 */
        $1214("1214", "$1214", emptyStrings())
        ,
        /** $1416: 14時～16時 */
        $1416("1416", "$1416", emptyStrings())
        ,
        /** $1618: 16時～18時 */
        $1618("1618", "$1618", emptyStrings())
        ,
        /** $1820: 18時～20時 */
        $1820("1820", "$1820", emptyStrings())
        ,
        /** $1921: 19時～21時 */
        $1921("1921", "$1921", emptyStrings())
        ,
        /** $2021: 20時～21時 */
        $2021("2021", "$2021", emptyStrings())
        ;
        private static final Map<String, YamatoDelivTz> _codeClsMap = new HashMap<String, YamatoDelivTz>();
        private static final Map<String, YamatoDelivTz> _nameClsMap = new HashMap<String, YamatoDelivTz>();
        static {
            for (YamatoDelivTz value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private YamatoDelivTz(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.YamatoDelivTz; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<YamatoDelivTz> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof YamatoDelivTz) { return OptionalThing.of((YamatoDelivTz)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<YamatoDelivTz> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static YamatoDelivTz codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof YamatoDelivTz) { return (YamatoDelivTz)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static YamatoDelivTz nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<YamatoDelivTz> listAll() {
            return new ArrayList<YamatoDelivTz>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<YamatoDelivTz> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: YamatoDelivTz." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<YamatoDelivTz> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<YamatoDelivTz> clsList = new ArrayList<YamatoDelivTz>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<YamatoDelivTz> groupOf(String groupName) {
            return new ArrayList<YamatoDelivTz>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ゆうパック配達時間帯
     */
    public enum YupackDelivTz implements CDef {
        /** $00: 時間指定なし */
        $00("00", "$00", emptyStrings())
        ,
        /** $51: 午前中 */
        $51("51", "$51", emptyStrings())
        ,
        /** $52: 12時～14時 */
        $52("52", "$52", emptyStrings())
        ,
        /** $53: 14時～16時 */
        $53("53", "$53", emptyStrings())
        ,
        /** $54: 16時～18時 */
        $54("54", "$54", emptyStrings())
        ,
        /** $55: 18時～20時 */
        $55("55", "$55", emptyStrings())
        ,
        /** $56: 20時～21時 */
        $56("56", "$56", emptyStrings())
        ;
        private static final Map<String, YupackDelivTz> _codeClsMap = new HashMap<String, YupackDelivTz>();
        private static final Map<String, YupackDelivTz> _nameClsMap = new HashMap<String, YupackDelivTz>();
        static {
            for (YupackDelivTz value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private YupackDelivTz(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.YupackDelivTz; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<YupackDelivTz> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof YupackDelivTz) { return OptionalThing.of((YupackDelivTz)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<YupackDelivTz> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static YupackDelivTz codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof YupackDelivTz) { return (YupackDelivTz)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static YupackDelivTz nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<YupackDelivTz> listAll() {
            return new ArrayList<YupackDelivTz>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<YupackDelivTz> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: YupackDelivTz." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<YupackDelivTz> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<YupackDelivTz> clsList = new ArrayList<YupackDelivTz>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<YupackDelivTz> groupOf(String groupName) {
            return new ArrayList<YupackDelivTz>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 郵便番号フラグ
     */
    public enum ZipFlg implements CDef {
        /** $0: 該当せず */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 該当 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ZipFlg> _codeClsMap = new HashMap<String, ZipFlg>();
        private static final Map<String, ZipFlg> _nameClsMap = new HashMap<String, ZipFlg>();
        static {
            for (ZipFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ZipFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ZipFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ZipFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ZipFlg) { return OptionalThing.of((ZipFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ZipFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ZipFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ZipFlg) { return (ZipFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ZipFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ZipFlg> listAll() {
            return new ArrayList<ZipFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ZipFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ZipFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ZipFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ZipFlg> clsList = new ArrayList<ZipFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ZipFlg> groupOf(String groupName) {
            return new ArrayList<ZipFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出退勤・休憩
     */
    public enum AttendanceLeavingRest implements CDef {
        /** $1: 出勤 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 退勤 */
        $2("2", "$2", emptyStrings())
        ,
        /** $4: 休憩開始 */
        $4("4", "$4", emptyStrings())
        ,
        /** $8: 休憩終了 */
        $8("8", "$8", emptyStrings())
        ;
        private static final Map<String, AttendanceLeavingRest> _codeClsMap = new HashMap<String, AttendanceLeavingRest>();
        private static final Map<String, AttendanceLeavingRest> _nameClsMap = new HashMap<String, AttendanceLeavingRest>();
        static {
            for (AttendanceLeavingRest value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AttendanceLeavingRest(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AttendanceLeavingRest; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AttendanceLeavingRest> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AttendanceLeavingRest) { return OptionalThing.of((AttendanceLeavingRest)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AttendanceLeavingRest> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AttendanceLeavingRest codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AttendanceLeavingRest) { return (AttendanceLeavingRest)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AttendanceLeavingRest nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AttendanceLeavingRest> listAll() {
            return new ArrayList<AttendanceLeavingRest>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AttendanceLeavingRest> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AttendanceLeavingRest." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AttendanceLeavingRest> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AttendanceLeavingRest> clsList = new ArrayList<AttendanceLeavingRest>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AttendanceLeavingRest> groupOf(String groupName) {
            return new ArrayList<AttendanceLeavingRest>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Bill of Lading出力対象フラグ
     */
    public enum BolOutputTargetFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, BolOutputTargetFlg> _codeClsMap = new HashMap<String, BolOutputTargetFlg>();
        private static final Map<String, BolOutputTargetFlg> _nameClsMap = new HashMap<String, BolOutputTargetFlg>();
        static {
            for (BolOutputTargetFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BolOutputTargetFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BolOutputTargetFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BolOutputTargetFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BolOutputTargetFlg) { return OptionalThing.of((BolOutputTargetFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BolOutputTargetFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BolOutputTargetFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BolOutputTargetFlg) { return (BolOutputTargetFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BolOutputTargetFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BolOutputTargetFlg> listAll() {
            return new ArrayList<BolOutputTargetFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BolOutputTargetFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BolOutputTargetFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BolOutputTargetFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BolOutputTargetFlg> clsList = new ArrayList<BolOutputTargetFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BolOutputTargetFlg> groupOf(String groupName) {
            return new ArrayList<BolOutputTargetFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Bill of Lading出力フラグ
     */
    public enum BolOutFlg implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, BolOutFlg> _codeClsMap = new HashMap<String, BolOutFlg>();
        private static final Map<String, BolOutFlg> _nameClsMap = new HashMap<String, BolOutFlg>();
        static {
            for (BolOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BolOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BolOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BolOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BolOutFlg) { return OptionalThing.of((BolOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BolOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BolOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BolOutFlg) { return (BolOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BolOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BolOutFlg> listAll() {
            return new ArrayList<BolOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BolOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BolOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BolOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BolOutFlg> clsList = new ArrayList<BolOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BolOutFlg> groupOf(String groupName) {
            return new ArrayList<BolOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Call Before Delivery フラグCD
     */
    public enum CallBeforeDeliveryFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CallBeforeDeliveryFlg> _codeClsMap = new HashMap<String, CallBeforeDeliveryFlg>();
        private static final Map<String, CallBeforeDeliveryFlg> _nameClsMap = new HashMap<String, CallBeforeDeliveryFlg>();
        static {
            for (CallBeforeDeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CallBeforeDeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CallBeforeDeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CallBeforeDeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CallBeforeDeliveryFlg) { return OptionalThing.of((CallBeforeDeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CallBeforeDeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CallBeforeDeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CallBeforeDeliveryFlg) { return (CallBeforeDeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CallBeforeDeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CallBeforeDeliveryFlg> listAll() {
            return new ArrayList<CallBeforeDeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CallBeforeDeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CallBeforeDeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CallBeforeDeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CallBeforeDeliveryFlg> clsList = new ArrayList<CallBeforeDeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CallBeforeDeliveryFlg> groupOf(String groupName) {
            return new ArrayList<CallBeforeDeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケースピッキング対象
     */
    public enum CasePickFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CasePickFlg> _codeClsMap = new HashMap<String, CasePickFlg>();
        private static final Map<String, CasePickFlg> _nameClsMap = new HashMap<String, CasePickFlg>();
        static {
            for (CasePickFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CasePickFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CasePickFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePickFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CasePickFlg) { return OptionalThing.of((CasePickFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePickFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CasePickFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CasePickFlg) { return (CasePickFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CasePickFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CasePickFlg> listAll() {
            return new ArrayList<CasePickFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CasePickFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CasePickFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CasePickFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CasePickFlg> clsList = new ArrayList<CasePickFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CasePickFlg> groupOf(String groupName) {
            return new ArrayList<CasePickFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケースピッキング対象
     */
    public enum CasePicTarget implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CasePicTarget> _codeClsMap = new HashMap<String, CasePicTarget>();
        private static final Map<String, CasePicTarget> _nameClsMap = new HashMap<String, CasePicTarget>();
        static {
            for (CasePicTarget value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CasePicTarget(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CasePicTarget; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePicTarget> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CasePicTarget) { return OptionalThing.of((CasePicTarget)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePicTarget> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CasePicTarget codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CasePicTarget) { return (CasePicTarget)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CasePicTarget nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CasePicTarget> listAll() {
            return new ArrayList<CasePicTarget>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CasePicTarget> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CasePicTarget." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CasePicTarget> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CasePicTarget> clsList = new ArrayList<CasePicTarget>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CasePicTarget> groupOf(String groupName) {
            return new ArrayList<CasePicTarget>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * CES連携フラグ
     */
    public enum CesIntegrationFlg implements CDef {
        /** $0: 連携しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 連携する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CesIntegrationFlg> _codeClsMap = new HashMap<String, CesIntegrationFlg>();
        private static final Map<String, CesIntegrationFlg> _nameClsMap = new HashMap<String, CesIntegrationFlg>();
        static {
            for (CesIntegrationFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CesIntegrationFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CesIntegrationFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CesIntegrationFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CesIntegrationFlg) { return OptionalThing.of((CesIntegrationFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CesIntegrationFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CesIntegrationFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CesIntegrationFlg) { return (CesIntegrationFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CesIntegrationFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CesIntegrationFlg> listAll() {
            return new ArrayList<CesIntegrationFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CesIntegrationFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CesIntegrationFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CesIntegrationFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CesIntegrationFlg> clsList = new ArrayList<CesIntegrationFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CesIntegrationFlg> groupOf(String groupName) {
            return new ArrayList<CesIntegrationFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Collect On Delivery フラグCD
     */
    public enum CodFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CodFlg> _codeClsMap = new HashMap<String, CodFlg>();
        private static final Map<String, CodFlg> _nameClsMap = new HashMap<String, CodFlg>();
        static {
            for (CodFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodFlg) { return OptionalThing.of((CodFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodFlg) { return (CodFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodFlg> listAll() {
            return new ArrayList<CodFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodFlg> clsList = new ArrayList<CodFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodFlg> groupOf(String groupName) {
            return new ArrayList<CodFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 小数有無フラグ
     */
    public enum DecimalExistFlg implements CDef {
        /** $0: 小数を含まない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 小数を含む */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DecimalExistFlg> _codeClsMap = new HashMap<String, DecimalExistFlg>();
        private static final Map<String, DecimalExistFlg> _nameClsMap = new HashMap<String, DecimalExistFlg>();
        static {
            for (DecimalExistFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DecimalExistFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DecimalExistFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DecimalExistFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DecimalExistFlg) { return OptionalThing.of((DecimalExistFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DecimalExistFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DecimalExistFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DecimalExistFlg) { return (DecimalExistFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DecimalExistFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DecimalExistFlg> listAll() {
            return new ArrayList<DecimalExistFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DecimalExistFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DecimalExistFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DecimalExistFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DecimalExistFlg> clsList = new ArrayList<DecimalExistFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DecimalExistFlg> groupOf(String groupName) {
            return new ArrayList<DecimalExistFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 小数管理商品梱包単位
     */
    public enum DecimalProductPacking implements CDef {
        /** $0: 荷姿単位で1梱包 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 商品単位で1梱包 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DecimalProductPacking> _codeClsMap = new HashMap<String, DecimalProductPacking>();
        private static final Map<String, DecimalProductPacking> _nameClsMap = new HashMap<String, DecimalProductPacking>();
        static {
            for (DecimalProductPacking value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DecimalProductPacking(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DecimalProductPacking; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DecimalProductPacking> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DecimalProductPacking) { return OptionalThing.of((DecimalProductPacking)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DecimalProductPacking> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DecimalProductPacking codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DecimalProductPacking) { return (DecimalProductPacking)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DecimalProductPacking nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DecimalProductPacking> listAll() {
            return new ArrayList<DecimalProductPacking>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DecimalProductPacking> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DecimalProductPacking." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DecimalProductPacking> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DecimalProductPacking> clsList = new ArrayList<DecimalProductPacking>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DecimalProductPacking> groupOf(String groupName) {
            return new ArrayList<DecimalProductPacking>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Do Not Stack Pallets フラグCD
     */
    public enum DoNotStackStackFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DoNotStackStackFlg> _codeClsMap = new HashMap<String, DoNotStackStackFlg>();
        private static final Map<String, DoNotStackStackFlg> _nameClsMap = new HashMap<String, DoNotStackStackFlg>();
        static {
            for (DoNotStackStackFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DoNotStackStackFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DoNotStackStackFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DoNotStackStackFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DoNotStackStackFlg) { return OptionalThing.of((DoNotStackStackFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DoNotStackStackFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DoNotStackStackFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DoNotStackStackFlg) { return (DoNotStackStackFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DoNotStackStackFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DoNotStackStackFlg> listAll() {
            return new ArrayList<DoNotStackStackFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DoNotStackStackFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DoNotStackStackFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DoNotStackStackFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DoNotStackStackFlg> clsList = new ArrayList<DoNotStackStackFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DoNotStackStackFlg> groupOf(String groupName) {
            return new ArrayList<DoNotStackStackFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 緊急補充ゾーン補充荷姿
     */
    public enum EmReplenishShapeFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, EmReplenishShapeFlg> _codeClsMap = new HashMap<String, EmReplenishShapeFlg>();
        private static final Map<String, EmReplenishShapeFlg> _nameClsMap = new HashMap<String, EmReplenishShapeFlg>();
        static {
            for (EmReplenishShapeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private EmReplenishShapeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.EmReplenishShapeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmReplenishShapeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof EmReplenishShapeFlg) { return OptionalThing.of((EmReplenishShapeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmReplenishShapeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static EmReplenishShapeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof EmReplenishShapeFlg) { return (EmReplenishShapeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static EmReplenishShapeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<EmReplenishShapeFlg> listAll() {
            return new ArrayList<EmReplenishShapeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<EmReplenishShapeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: EmReplenishShapeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<EmReplenishShapeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<EmReplenishShapeFlg> clsList = new ArrayList<EmReplenishShapeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<EmReplenishShapeFlg> groupOf(String groupName) {
            return new ArrayList<EmReplenishShapeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Food フラグCD
     */
    public enum FoogFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, FoogFlg> _codeClsMap = new HashMap<String, FoogFlg>();
        private static final Map<String, FoogFlg> _nameClsMap = new HashMap<String, FoogFlg>();
        static {
            for (FoogFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FoogFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FoogFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FoogFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FoogFlg) { return OptionalThing.of((FoogFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FoogFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FoogFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FoogFlg) { return (FoogFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FoogFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FoogFlg> listAll() {
            return new ArrayList<FoogFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FoogFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FoogFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FoogFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FoogFlg> clsList = new ArrayList<FoogFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FoogFlg> groupOf(String groupName) {
            return new ArrayList<FoogFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Freezable Protection フラグCD
     */
    public enum FreezableProtectionFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, FreezableProtectionFlg> _codeClsMap = new HashMap<String, FreezableProtectionFlg>();
        private static final Map<String, FreezableProtectionFlg> _nameClsMap = new HashMap<String, FreezableProtectionFlg>();
        static {
            for (FreezableProtectionFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FreezableProtectionFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FreezableProtectionFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FreezableProtectionFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FreezableProtectionFlg) { return OptionalThing.of((FreezableProtectionFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FreezableProtectionFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FreezableProtectionFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FreezableProtectionFlg) { return (FreezableProtectionFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FreezableProtectionFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FreezableProtectionFlg> listAll() {
            return new ArrayList<FreezableProtectionFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FreezableProtectionFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FreezableProtectionFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FreezableProtectionFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FreezableProtectionFlg> clsList = new ArrayList<FreezableProtectionFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FreezableProtectionFlg> groupOf(String groupName) {
            return new ArrayList<FreezableProtectionFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Freight Class
     */
    public enum FreightCls implements CDef {
        /** $01: 50 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 55 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 60 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 65 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 70 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 77.5 */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 85 */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: 92.5 */
        $08("08", "$08", emptyStrings())
        ,
        /** $09: 100 */
        $09("09", "$09", emptyStrings())
        ,
        /** $10: 110 */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: 125 */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 150 */
        $12("12", "$12", emptyStrings())
        ,
        /** $13: 175 */
        $13("13", "$13", emptyStrings())
        ,
        /** $14: 200 */
        $14("14", "$14", emptyStrings())
        ,
        /** $15: 250 */
        $15("15", "$15", emptyStrings())
        ,
        /** $16: 300 */
        $16("16", "$16", emptyStrings())
        ,
        /** $17: 400 */
        $17("17", "$17", emptyStrings())
        ,
        /** $18: 500 */
        $18("18", "$18", emptyStrings())
        ;
        private static final Map<String, FreightCls> _codeClsMap = new HashMap<String, FreightCls>();
        private static final Map<String, FreightCls> _nameClsMap = new HashMap<String, FreightCls>();
        static {
            for (FreightCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FreightCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FreightCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FreightCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FreightCls) { return OptionalThing.of((FreightCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FreightCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FreightCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FreightCls) { return (FreightCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FreightCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FreightCls> listAll() {
            return new ArrayList<FreightCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FreightCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FreightCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FreightCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FreightCls> clsList = new ArrayList<FreightCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FreightCls> groupOf(String groupName) {
            return new ArrayList<FreightCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Guaranteed Plus フラグCD
     */
    public enum GuaranteedPlusFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, GuaranteedPlusFlg> _codeClsMap = new HashMap<String, GuaranteedPlusFlg>();
        private static final Map<String, GuaranteedPlusFlg> _nameClsMap = new HashMap<String, GuaranteedPlusFlg>();
        static {
            for (GuaranteedPlusFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private GuaranteedPlusFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.GuaranteedPlusFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GuaranteedPlusFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof GuaranteedPlusFlg) { return OptionalThing.of((GuaranteedPlusFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GuaranteedPlusFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static GuaranteedPlusFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof GuaranteedPlusFlg) { return (GuaranteedPlusFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static GuaranteedPlusFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<GuaranteedPlusFlg> listAll() {
            return new ArrayList<GuaranteedPlusFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<GuaranteedPlusFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: GuaranteedPlusFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<GuaranteedPlusFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<GuaranteedPlusFlg> clsList = new ArrayList<GuaranteedPlusFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<GuaranteedPlusFlg> groupOf(String groupName) {
            return new ArrayList<GuaranteedPlusFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Inside Delivery フラグCD (Collect)
     */
    public enum InsideDeliveryCollectFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InsideDeliveryCollectFlg> _codeClsMap = new HashMap<String, InsideDeliveryCollectFlg>();
        private static final Map<String, InsideDeliveryCollectFlg> _nameClsMap = new HashMap<String, InsideDeliveryCollectFlg>();
        static {
            for (InsideDeliveryCollectFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InsideDeliveryCollectFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InsideDeliveryCollectFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsideDeliveryCollectFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InsideDeliveryCollectFlg) { return OptionalThing.of((InsideDeliveryCollectFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsideDeliveryCollectFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InsideDeliveryCollectFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InsideDeliveryCollectFlg) { return (InsideDeliveryCollectFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InsideDeliveryCollectFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InsideDeliveryCollectFlg> listAll() {
            return new ArrayList<InsideDeliveryCollectFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InsideDeliveryCollectFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InsideDeliveryCollectFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InsideDeliveryCollectFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InsideDeliveryCollectFlg> clsList = new ArrayList<InsideDeliveryCollectFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InsideDeliveryCollectFlg> groupOf(String groupName) {
            return new ArrayList<InsideDeliveryCollectFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Inside Delivery フラグCD (Prepaid)
     */
    public enum InsideDeliveryPrepaidFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InsideDeliveryPrepaidFlg> _codeClsMap = new HashMap<String, InsideDeliveryPrepaidFlg>();
        private static final Map<String, InsideDeliveryPrepaidFlg> _nameClsMap = new HashMap<String, InsideDeliveryPrepaidFlg>();
        static {
            for (InsideDeliveryPrepaidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InsideDeliveryPrepaidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InsideDeliveryPrepaidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsideDeliveryPrepaidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InsideDeliveryPrepaidFlg) { return OptionalThing.of((InsideDeliveryPrepaidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsideDeliveryPrepaidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InsideDeliveryPrepaidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InsideDeliveryPrepaidFlg) { return (InsideDeliveryPrepaidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InsideDeliveryPrepaidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InsideDeliveryPrepaidFlg> listAll() {
            return new ArrayList<InsideDeliveryPrepaidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InsideDeliveryPrepaidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InsideDeliveryPrepaidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InsideDeliveryPrepaidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InsideDeliveryPrepaidFlg> clsList = new ArrayList<InsideDeliveryPrepaidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InsideDeliveryPrepaidFlg> groupOf(String groupName) {
            return new ArrayList<InsideDeliveryPrepaidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Inside Pickup フラグCD (Collect)
     */
    public enum InsidePickupCollectFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InsidePickupCollectFlg> _codeClsMap = new HashMap<String, InsidePickupCollectFlg>();
        private static final Map<String, InsidePickupCollectFlg> _nameClsMap = new HashMap<String, InsidePickupCollectFlg>();
        static {
            for (InsidePickupCollectFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InsidePickupCollectFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InsidePickupCollectFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsidePickupCollectFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InsidePickupCollectFlg) { return OptionalThing.of((InsidePickupCollectFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsidePickupCollectFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InsidePickupCollectFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InsidePickupCollectFlg) { return (InsidePickupCollectFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InsidePickupCollectFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InsidePickupCollectFlg> listAll() {
            return new ArrayList<InsidePickupCollectFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InsidePickupCollectFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InsidePickupCollectFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InsidePickupCollectFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InsidePickupCollectFlg> clsList = new ArrayList<InsidePickupCollectFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InsidePickupCollectFlg> groupOf(String groupName) {
            return new ArrayList<InsidePickupCollectFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Inside Pickup フラグCD (Prepaid)
     */
    public enum InsidePickupPrepaidFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InsidePickupPrepaidFlg> _codeClsMap = new HashMap<String, InsidePickupPrepaidFlg>();
        private static final Map<String, InsidePickupPrepaidFlg> _nameClsMap = new HashMap<String, InsidePickupPrepaidFlg>();
        static {
            for (InsidePickupPrepaidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InsidePickupPrepaidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InsidePickupPrepaidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsidePickupPrepaidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InsidePickupPrepaidFlg) { return OptionalThing.of((InsidePickupPrepaidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsidePickupPrepaidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InsidePickupPrepaidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InsidePickupPrepaidFlg) { return (InsidePickupPrepaidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InsidePickupPrepaidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InsidePickupPrepaidFlg> listAll() {
            return new ArrayList<InsidePickupPrepaidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InsidePickupPrepaidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InsidePickupPrepaidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InsidePickupPrepaidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InsidePickupPrepaidFlg> clsList = new ArrayList<InsidePickupPrepaidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InsidePickupPrepaidFlg> groupOf(String groupName) {
            return new ArrayList<InsidePickupPrepaidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検品ラベル出力
     */
    public enum InspectionLabelOutFlg implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InspectionLabelOutFlg> _codeClsMap = new HashMap<String, InspectionLabelOutFlg>();
        private static final Map<String, InspectionLabelOutFlg> _nameClsMap = new HashMap<String, InspectionLabelOutFlg>();
        static {
            for (InspectionLabelOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InspectionLabelOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InspectionLabelOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InspectionLabelOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InspectionLabelOutFlg) { return OptionalThing.of((InspectionLabelOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InspectionLabelOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InspectionLabelOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InspectionLabelOutFlg) { return (InspectionLabelOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InspectionLabelOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InspectionLabelOutFlg> listAll() {
            return new ArrayList<InspectionLabelOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InspectionLabelOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InspectionLabelOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InspectionLabelOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InspectionLabelOutFlg> clsList = new ArrayList<InspectionLabelOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InspectionLabelOutFlg> groupOf(String groupName) {
            return new ArrayList<InspectionLabelOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Liftgate at delivery フラグCD (Collect)
     */
    public enum LiftgateDeliveryCollectFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LiftgateDeliveryCollectFlg> _codeClsMap = new HashMap<String, LiftgateDeliveryCollectFlg>();
        private static final Map<String, LiftgateDeliveryCollectFlg> _nameClsMap = new HashMap<String, LiftgateDeliveryCollectFlg>();
        static {
            for (LiftgateDeliveryCollectFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LiftgateDeliveryCollectFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LiftgateDeliveryCollectFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgateDeliveryCollectFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LiftgateDeliveryCollectFlg) { return OptionalThing.of((LiftgateDeliveryCollectFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgateDeliveryCollectFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LiftgateDeliveryCollectFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LiftgateDeliveryCollectFlg) { return (LiftgateDeliveryCollectFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LiftgateDeliveryCollectFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LiftgateDeliveryCollectFlg> listAll() {
            return new ArrayList<LiftgateDeliveryCollectFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LiftgateDeliveryCollectFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LiftgateDeliveryCollectFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LiftgateDeliveryCollectFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LiftgateDeliveryCollectFlg> clsList = new ArrayList<LiftgateDeliveryCollectFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LiftgateDeliveryCollectFlg> groupOf(String groupName) {
            return new ArrayList<LiftgateDeliveryCollectFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Liftgate at delivery フラグCD (Prepaid)
     */
    public enum LiftgateDeliveryPrepaidFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LiftgateDeliveryPrepaidFlg> _codeClsMap = new HashMap<String, LiftgateDeliveryPrepaidFlg>();
        private static final Map<String, LiftgateDeliveryPrepaidFlg> _nameClsMap = new HashMap<String, LiftgateDeliveryPrepaidFlg>();
        static {
            for (LiftgateDeliveryPrepaidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LiftgateDeliveryPrepaidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LiftgateDeliveryPrepaidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgateDeliveryPrepaidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LiftgateDeliveryPrepaidFlg) { return OptionalThing.of((LiftgateDeliveryPrepaidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgateDeliveryPrepaidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LiftgateDeliveryPrepaidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LiftgateDeliveryPrepaidFlg) { return (LiftgateDeliveryPrepaidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LiftgateDeliveryPrepaidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LiftgateDeliveryPrepaidFlg> listAll() {
            return new ArrayList<LiftgateDeliveryPrepaidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LiftgateDeliveryPrepaidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LiftgateDeliveryPrepaidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LiftgateDeliveryPrepaidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LiftgateDeliveryPrepaidFlg> clsList = new ArrayList<LiftgateDeliveryPrepaidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LiftgateDeliveryPrepaidFlg> groupOf(String groupName) {
            return new ArrayList<LiftgateDeliveryPrepaidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Liftgate at pickup フラグCD (Collect)
     */
    public enum LiftgatePickupCollectFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LiftgatePickupCollectFlg> _codeClsMap = new HashMap<String, LiftgatePickupCollectFlg>();
        private static final Map<String, LiftgatePickupCollectFlg> _nameClsMap = new HashMap<String, LiftgatePickupCollectFlg>();
        static {
            for (LiftgatePickupCollectFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LiftgatePickupCollectFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LiftgatePickupCollectFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgatePickupCollectFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LiftgatePickupCollectFlg) { return OptionalThing.of((LiftgatePickupCollectFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgatePickupCollectFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LiftgatePickupCollectFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LiftgatePickupCollectFlg) { return (LiftgatePickupCollectFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LiftgatePickupCollectFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LiftgatePickupCollectFlg> listAll() {
            return new ArrayList<LiftgatePickupCollectFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LiftgatePickupCollectFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LiftgatePickupCollectFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LiftgatePickupCollectFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LiftgatePickupCollectFlg> clsList = new ArrayList<LiftgatePickupCollectFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LiftgatePickupCollectFlg> groupOf(String groupName) {
            return new ArrayList<LiftgatePickupCollectFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Liftgate at pickup フラグCD (Prepaid)
     */
    public enum LiftgatePickupPrepaidFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LiftgatePickupPrepaidFlg> _codeClsMap = new HashMap<String, LiftgatePickupPrepaidFlg>();
        private static final Map<String, LiftgatePickupPrepaidFlg> _nameClsMap = new HashMap<String, LiftgatePickupPrepaidFlg>();
        static {
            for (LiftgatePickupPrepaidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LiftgatePickupPrepaidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LiftgatePickupPrepaidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgatePickupPrepaidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LiftgatePickupPrepaidFlg) { return OptionalThing.of((LiftgatePickupPrepaidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgatePickupPrepaidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LiftgatePickupPrepaidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LiftgatePickupPrepaidFlg) { return (LiftgatePickupPrepaidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LiftgatePickupPrepaidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LiftgatePickupPrepaidFlg> listAll() {
            return new ArrayList<LiftgatePickupPrepaidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LiftgatePickupPrepaidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LiftgatePickupPrepaidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LiftgatePickupPrepaidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LiftgatePickupPrepaidFlg> clsList = new ArrayList<LiftgatePickupPrepaidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LiftgatePickupPrepaidFlg> groupOf(String groupName) {
            return new ArrayList<LiftgatePickupPrepaidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Limited Access Delivery フラグCD
     */
    public enum LimitedAccessDeliveryFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LimitedAccessDeliveryFlg> _codeClsMap = new HashMap<String, LimitedAccessDeliveryFlg>();
        private static final Map<String, LimitedAccessDeliveryFlg> _nameClsMap = new HashMap<String, LimitedAccessDeliveryFlg>();
        static {
            for (LimitedAccessDeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitedAccessDeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitedAccessDeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitedAccessDeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitedAccessDeliveryFlg) { return OptionalThing.of((LimitedAccessDeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitedAccessDeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitedAccessDeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitedAccessDeliveryFlg) { return (LimitedAccessDeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitedAccessDeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitedAccessDeliveryFlg> listAll() {
            return new ArrayList<LimitedAccessDeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitedAccessDeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitedAccessDeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitedAccessDeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitedAccessDeliveryFlg> clsList = new ArrayList<LimitedAccessDeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitedAccessDeliveryFlg> groupOf(String groupName) {
            return new ArrayList<LimitedAccessDeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Limited Access Pickup フラグCD
     */
    public enum LimitedAccessPickupFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LimitedAccessPickupFlg> _codeClsMap = new HashMap<String, LimitedAccessPickupFlg>();
        private static final Map<String, LimitedAccessPickupFlg> _nameClsMap = new HashMap<String, LimitedAccessPickupFlg>();
        static {
            for (LimitedAccessPickupFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitedAccessPickupFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitedAccessPickupFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitedAccessPickupFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitedAccessPickupFlg) { return OptionalThing.of((LimitedAccessPickupFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitedAccessPickupFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitedAccessPickupFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitedAccessPickupFlg) { return (LimitedAccessPickupFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitedAccessPickupFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitedAccessPickupFlg> listAll() {
            return new ArrayList<LimitedAccessPickupFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitedAccessPickupFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitedAccessPickupFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitedAccessPickupFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitedAccessPickupFlg> clsList = new ArrayList<LimitedAccessPickupFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitedAccessPickupFlg> groupOf(String groupName) {
            return new ArrayList<LimitedAccessPickupFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Over-Sized/Extreme Length フラグCD
     */
    public enum OverSizedFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, OverSizedFlg> _codeClsMap = new HashMap<String, OverSizedFlg>();
        private static final Map<String, OverSizedFlg> _nameClsMap = new HashMap<String, OverSizedFlg>();
        static {
            for (OverSizedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OverSizedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OverSizedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OverSizedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OverSizedFlg) { return OptionalThing.of((OverSizedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OverSizedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OverSizedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OverSizedFlg) { return (OverSizedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OverSizedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OverSizedFlg> listAll() {
            return new ArrayList<OverSizedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OverSizedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OverSizedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OverSizedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OverSizedFlg> clsList = new ArrayList<OverSizedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OverSizedFlg> groupOf(String groupName) {
            return new ArrayList<OverSizedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 納品明細書自動発行フラグ
     */
    public enum PackingSlipAutoOutputFlg implements CDef {
        /** $0: 発行しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PackingSlipAutoOutputFlg> _codeClsMap = new HashMap<String, PackingSlipAutoOutputFlg>();
        private static final Map<String, PackingSlipAutoOutputFlg> _nameClsMap = new HashMap<String, PackingSlipAutoOutputFlg>();
        static {
            for (PackingSlipAutoOutputFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingSlipAutoOutputFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingSlipAutoOutputFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingSlipAutoOutputFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingSlipAutoOutputFlg) { return OptionalThing.of((PackingSlipAutoOutputFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingSlipAutoOutputFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingSlipAutoOutputFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingSlipAutoOutputFlg) { return (PackingSlipAutoOutputFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingSlipAutoOutputFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingSlipAutoOutputFlg> listAll() {
            return new ArrayList<PackingSlipAutoOutputFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingSlipAutoOutputFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingSlipAutoOutputFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingSlipAutoOutputFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingSlipAutoOutputFlg> clsList = new ArrayList<PackingSlipAutoOutputFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingSlipAutoOutputFlg> groupOf(String groupName) {
            return new ArrayList<PackingSlipAutoOutputFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Payment Term
     */
    public enum PaymentTerm implements CDef {
        /** $3PL: 3rd Party */
        $3PL("3PL", "$3PL", emptyStrings())
        ,
        /** $CO1: COD Bill FRT */
        $CO1("CO1", "$CO1", emptyStrings())
        ,
        /** $CO2: COD NOT Bill FRT */
        $CO2("CO2", "$CO2", emptyStrings())
        ,
        /** $COL: Collect */
        $COL("COL", "$COL", emptyStrings())
        ,
        /** $PPB: PrePaid &amp; Bill */
        $PPB("PPB", "$PPB", emptyStrings())
        ,
        /** $PPD: PrePaid */
        $PPD("PPD", "$PPD", emptyStrings())
        ;
        private static final Map<String, PaymentTerm> _codeClsMap = new HashMap<String, PaymentTerm>();
        private static final Map<String, PaymentTerm> _nameClsMap = new HashMap<String, PaymentTerm>();
        static {
            for (PaymentTerm value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PaymentTerm(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PaymentTerm; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PaymentTerm> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PaymentTerm) { return OptionalThing.of((PaymentTerm)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PaymentTerm> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PaymentTerm codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PaymentTerm) { return (PaymentTerm)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PaymentTerm nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PaymentTerm> listAll() {
            return new ArrayList<PaymentTerm>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PaymentTerm> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PaymentTerm." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PaymentTerm> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PaymentTerm> clsList = new ArrayList<PaymentTerm>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PaymentTerm> groupOf(String groupName) {
            return new ArrayList<PaymentTerm>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ピッキング種別
     */
    public enum PickingType implements CDef {
        /** $0: バラ */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ケース */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PickingType> _codeClsMap = new HashMap<String, PickingType>();
        private static final Map<String, PickingType> _nameClsMap = new HashMap<String, PickingType>();
        static {
            for (PickingType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingType) { return OptionalThing.of((PickingType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingType) { return (PickingType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingType> listAll() {
            return new ArrayList<PickingType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingType> clsList = new ArrayList<PickingType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingType> groupOf(String groupName) {
            return new ArrayList<PickingType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Poison フラグCD
     */
    public enum PoisonFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PoisonFlg> _codeClsMap = new HashMap<String, PoisonFlg>();
        private static final Map<String, PoisonFlg> _nameClsMap = new HashMap<String, PoisonFlg>();
        static {
            for (PoisonFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PoisonFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PoisonFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PoisonFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PoisonFlg) { return OptionalThing.of((PoisonFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PoisonFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PoisonFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PoisonFlg) { return (PoisonFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PoisonFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PoisonFlg> listAll() {
            return new ArrayList<PoisonFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PoisonFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PoisonFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PoisonFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PoisonFlg> clsList = new ArrayList<PoisonFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PoisonFlg> groupOf(String groupName) {
            return new ArrayList<PoisonFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 提案ピッキング方法
     */
    public enum RcmdPickingCls implements CDef {
        /** $1: オーダーピッキング */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: トータルピッキング＋摘み取り */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: トータルピッキング＋種蒔き */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: マルチピッキング */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 単行ピッキング */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: ケースピッキング */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, RcmdPickingCls> _codeClsMap = new HashMap<String, RcmdPickingCls>();
        private static final Map<String, RcmdPickingCls> _nameClsMap = new HashMap<String, RcmdPickingCls>();
        static {
            for (RcmdPickingCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RcmdPickingCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RcmdPickingCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RcmdPickingCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RcmdPickingCls) { return OptionalThing.of((RcmdPickingCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RcmdPickingCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RcmdPickingCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RcmdPickingCls) { return (RcmdPickingCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RcmdPickingCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RcmdPickingCls> listAll() {
            return new ArrayList<RcmdPickingCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RcmdPickingCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RcmdPickingCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RcmdPickingCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RcmdPickingCls> clsList = new ArrayList<RcmdPickingCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RcmdPickingCls> groupOf(String groupName) {
            return new ArrayList<RcmdPickingCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Residential Delivery フラグCD
     */
    public enum ResidentialDeliveryFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ResidentialDeliveryFlg> _codeClsMap = new HashMap<String, ResidentialDeliveryFlg>();
        private static final Map<String, ResidentialDeliveryFlg> _nameClsMap = new HashMap<String, ResidentialDeliveryFlg>();
        static {
            for (ResidentialDeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ResidentialDeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ResidentialDeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResidentialDeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ResidentialDeliveryFlg) { return OptionalThing.of((ResidentialDeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResidentialDeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ResidentialDeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ResidentialDeliveryFlg) { return (ResidentialDeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ResidentialDeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ResidentialDeliveryFlg> listAll() {
            return new ArrayList<ResidentialDeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ResidentialDeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ResidentialDeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ResidentialDeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ResidentialDeliveryFlg> clsList = new ArrayList<ResidentialDeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ResidentialDeliveryFlg> groupOf(String groupName) {
            return new ArrayList<ResidentialDeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Residential Pickup フラグCD
     */
    public enum ResidentialPickupFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ResidentialPickupFlg> _codeClsMap = new HashMap<String, ResidentialPickupFlg>();
        private static final Map<String, ResidentialPickupFlg> _nameClsMap = new HashMap<String, ResidentialPickupFlg>();
        static {
            for (ResidentialPickupFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ResidentialPickupFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ResidentialPickupFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResidentialPickupFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ResidentialPickupFlg) { return OptionalThing.of((ResidentialPickupFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResidentialPickupFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ResidentialPickupFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ResidentialPickupFlg) { return (ResidentialPickupFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ResidentialPickupFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ResidentialPickupFlg> listAll() {
            return new ArrayList<ResidentialPickupFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ResidentialPickupFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ResidentialPickupFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ResidentialPickupFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ResidentialPickupFlg> clsList = new ArrayList<ResidentialPickupFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ResidentialPickupFlg> groupOf(String groupName) {
            return new ArrayList<ResidentialPickupFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Saturday Delivery フラグCD
     */
    public enum SatDeliveryFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SatDeliveryFlg> _codeClsMap = new HashMap<String, SatDeliveryFlg>();
        private static final Map<String, SatDeliveryFlg> _nameClsMap = new HashMap<String, SatDeliveryFlg>();
        static {
            for (SatDeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SatDeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SatDeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SatDeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SatDeliveryFlg) { return OptionalThing.of((SatDeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SatDeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SatDeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SatDeliveryFlg) { return (SatDeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SatDeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SatDeliveryFlg> listAll() {
            return new ArrayList<SatDeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SatDeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SatDeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SatDeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SatDeliveryFlg> clsList = new ArrayList<SatDeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SatDeliveryFlg> groupOf(String groupName) {
            return new ArrayList<SatDeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 単行ピッキング対象
     */
    public enum SglRowPicTarget implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SglRowPicTarget> _codeClsMap = new HashMap<String, SglRowPicTarget>();
        private static final Map<String, SglRowPicTarget> _nameClsMap = new HashMap<String, SglRowPicTarget>();
        static {
            for (SglRowPicTarget value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SglRowPicTarget(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SglRowPicTarget; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowPicTarget> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SglRowPicTarget) { return OptionalThing.of((SglRowPicTarget)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowPicTarget> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SglRowPicTarget codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SglRowPicTarget) { return (SglRowPicTarget)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SglRowPicTarget nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SglRowPicTarget> listAll() {
            return new ArrayList<SglRowPicTarget>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SglRowPicTarget> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SglRowPicTarget." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SglRowPicTarget> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SglRowPicTarget> clsList = new ArrayList<SglRowPicTarget>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SglRowPicTarget> groupOf(String groupName) {
            return new ArrayList<SglRowPicTarget>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Signature ReleaseフラグCD
     */
    public enum SignatureReleaseFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SignatureReleaseFlg> _codeClsMap = new HashMap<String, SignatureReleaseFlg>();
        private static final Map<String, SignatureReleaseFlg> _nameClsMap = new HashMap<String, SignatureReleaseFlg>();
        static {
            for (SignatureReleaseFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SignatureReleaseFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SignatureReleaseFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SignatureReleaseFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SignatureReleaseFlg) { return OptionalThing.of((SignatureReleaseFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SignatureReleaseFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SignatureReleaseFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SignatureReleaseFlg) { return (SignatureReleaseFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SignatureReleaseFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SignatureReleaseFlg> listAll() {
            return new ArrayList<SignatureReleaseFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SignatureReleaseFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SignatureReleaseFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SignatureReleaseFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SignatureReleaseFlg> clsList = new ArrayList<SignatureReleaseFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SignatureReleaseFlg> groupOf(String groupName) {
            return new ArrayList<SignatureReleaseFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Signature Required フラグCD
     */
    public enum SignatureRequiredFlg implements CDef {
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SignatureRequiredFlg> _codeClsMap = new HashMap<String, SignatureRequiredFlg>();
        private static final Map<String, SignatureRequiredFlg> _nameClsMap = new HashMap<String, SignatureRequiredFlg>();
        static {
            for (SignatureRequiredFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SignatureRequiredFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SignatureRequiredFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SignatureRequiredFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SignatureRequiredFlg) { return OptionalThing.of((SignatureRequiredFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SignatureRequiredFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SignatureRequiredFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SignatureRequiredFlg) { return (SignatureRequiredFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SignatureRequiredFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SignatureRequiredFlg> listAll() {
            return new ArrayList<SignatureRequiredFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SignatureRequiredFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SignatureRequiredFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SignatureRequiredFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SignatureRequiredFlg> clsList = new ArrayList<SignatureRequiredFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SignatureRequiredFlg> groupOf(String groupName) {
            return new ArrayList<SignatureRequiredFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 郵便番号種別
     */
    public enum UploadZipType implements CDef {
        /** $0: 住所 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 事業所 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, UploadZipType> _codeClsMap = new HashMap<String, UploadZipType>();
        private static final Map<String, UploadZipType> _nameClsMap = new HashMap<String, UploadZipType>();
        static {
            for (UploadZipType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UploadZipType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UploadZipType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UploadZipType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UploadZipType) { return OptionalThing.of((UploadZipType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UploadZipType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UploadZipType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UploadZipType) { return (UploadZipType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UploadZipType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UploadZipType> listAll() {
            return new ArrayList<UploadZipType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UploadZipType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UploadZipType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UploadZipType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UploadZipType> clsList = new ArrayList<UploadZipType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UploadZipType> groupOf(String groupName) {
            return new ArrayList<UploadZipType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業実績出力フラグ
     */
    public enum WorkLogOutFlg implements CDef {
        /** $0: 未出力 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, WorkLogOutFlg> _codeClsMap = new HashMap<String, WorkLogOutFlg>();
        private static final Map<String, WorkLogOutFlg> _nameClsMap = new HashMap<String, WorkLogOutFlg>();
        static {
            for (WorkLogOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkLogOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkLogOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkLogOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkLogOutFlg) { return OptionalThing.of((WorkLogOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkLogOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkLogOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkLogOutFlg) { return (WorkLogOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkLogOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkLogOutFlg> listAll() {
            return new ArrayList<WorkLogOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkLogOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkLogOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkLogOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkLogOutFlg> clsList = new ArrayList<WorkLogOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkLogOutFlg> groupOf(String groupName) {
            return new ArrayList<WorkLogOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業ステータス
     */
    public enum WorkStatus implements CDef {
        /** $01: 作業中 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 正常終了 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 基盤強制終了 */
        $03("03", "$03", emptyStrings())
        ;
        private static final Map<String, WorkStatus> _codeClsMap = new HashMap<String, WorkStatus>();
        private static final Map<String, WorkStatus> _nameClsMap = new HashMap<String, WorkStatus>();
        static {
            for (WorkStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkStatus) { return OptionalThing.of((WorkStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkStatus) { return (WorkStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkStatus> listAll() {
            return new ArrayList<WorkStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkStatus> clsList = new ArrayList<WorkStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkStatus> groupOf(String groupName) {
            return new ArrayList<WorkStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 滅却ステータス
     */
    public enum Adjuststatus implements CDef {
        /** $100: 予定 */
        $100("100", "$100", emptyStrings())
        ,
        /** $500: 滅却完了 */
        $500("500", "$500", emptyStrings())
        ;
        private static final Map<String, Adjuststatus> _codeClsMap = new HashMap<String, Adjuststatus>();
        private static final Map<String, Adjuststatus> _nameClsMap = new HashMap<String, Adjuststatus>();
        static {
            for (Adjuststatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Adjuststatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Adjuststatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Adjuststatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Adjuststatus) { return OptionalThing.of((Adjuststatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Adjuststatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Adjuststatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Adjuststatus) { return (Adjuststatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Adjuststatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Adjuststatus> listAll() {
            return new ArrayList<Adjuststatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Adjuststatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Adjuststatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Adjuststatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Adjuststatus> clsList = new ArrayList<Adjuststatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Adjuststatus> groupOf(String groupName) {
            return new ArrayList<Adjuststatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 組織区分
     */
    public enum Companygroup implements CDef {
        /** $111: 本社営業統括部 */
        $111("111", "$111", emptyStrings())
        ,
        /** $112: 本社営業部 */
        $112("112", "$112", emptyStrings())
        ,
        /** $113: 資金部 */
        $113("113", "$113", emptyStrings())
        ,
        /** $151: JT受注センター */
        $151("151", "$151", emptyStrings())
        ,
        /** $211: JT本社物流 */
        $211("211", "$211", emptyStrings())
        ,
        /** $212: TS本社 */
        $212("212", "$212", emptyStrings())
        ,
        /** $251: TS受注センター */
        $251("251", "$251", emptyStrings())
        ,
        /** $252: FAXセンター */
        $252("252", "$252", emptyStrings())
        ,
        /** $261: 物流センター */
        $261("261", "$261", emptyStrings())
        ,
        /** $271: 製造工場 */
        $271("271", "$271", emptyStrings())
        ,
        /** $280: 基地圏 */
        $280("280", "$280", emptyStrings())
        ,
        /** $281: 流通基地 */
        $281("281", "$281", emptyStrings())
        ,
        /** $282: 保税基地 */
        $282("282", "$282", emptyStrings())
        ,
        /** $283: 流通センター */
        $283("283", "$283", emptyStrings())
        ,
        /** $284: TC */
        $284("284", "$284", emptyStrings())
        ,
        /** $285: TD */
        $285("285", "$285", emptyStrings())
        ,
        /** $286: デポ */
        $286("286", "$286", emptyStrings())
        ,
        /** $287: 離島倉庫 */
        $287("287", "$287", emptyStrings())
        ,
        /** $291: 不適品センター */
        $291("291", "$291", emptyStrings())
        ,
        /** $292: 輸入保税基地 */
        $292("292", "$292", emptyStrings())
        ,
        /** $293: 払出倉庫 */
        $293("293", "$293", emptyStrings())
        ,
        /** $294: 払出枝倉庫 */
        $294("294", "$294", emptyStrings())
        ,
        /** $LNE: ライン */
        $LNE("LNE", "$LNE", emptyStrings())
        ,
        /** $RCK: ラック */
        $RCK("RCK", "$RCK", emptyStrings())
        ,
        /** $BLK: ブロック */
        $BLK("BLK", "$BLK", emptyStrings())
        ,
        /** $RTT: 融通 */
        $RTT("RTT", "$RTT", emptyStrings())
        ,
        /** $RCV: 引取場 */
        $RCV("RCV", "$RCV", emptyStrings())
        ,
        /** $ETC: その他 */
        $ETC("ETC", "$ETC", emptyStrings())
        ;
        private static final Map<String, Companygroup> _codeClsMap = new HashMap<String, Companygroup>();
        private static final Map<String, Companygroup> _nameClsMap = new HashMap<String, Companygroup>();
        static {
            for (Companygroup value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Companygroup(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Companygroup; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Companygroup> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Companygroup) { return OptionalThing.of((Companygroup)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Companygroup> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Companygroup codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Companygroup) { return (Companygroup)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Companygroup nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Companygroup> listAll() {
            return new ArrayList<Companygroup>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Companygroup> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Companygroup." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Companygroup> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Companygroup> clsList = new ArrayList<Companygroup>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Companygroup> groupOf(String groupName) {
            return new ArrayList<Companygroup>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロケーショングループ
     */
    public enum LocGroup implements CDef {
        /** $01: 入庫場 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 保管場 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 検査場 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 棚出場 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 積替場 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 仕分場 */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 出庫場 */
        $07("07", "$07", emptyStrings())
        ,
        /** $09: 不良品置場 */
        $09("09", "$09", emptyStrings())
        ,
        /** $10: 移動中ロケ */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: 引取場 */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: かし品 */
        $12("12", "$12", emptyStrings())
        ,
        /** $13: 国税還付品 */
        $13("13", "$13", emptyStrings())
        ,
        /** $14: 未入庫 */
        $14("14", "$14", emptyStrings())
        ;
        private static final Map<String, LocGroup> _codeClsMap = new HashMap<String, LocGroup>();
        private static final Map<String, LocGroup> _nameClsMap = new HashMap<String, LocGroup>();
        static {
            for (LocGroup value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LocGroup(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LocGroup; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LocGroup> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LocGroup) { return OptionalThing.of((LocGroup)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LocGroup> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LocGroup codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LocGroup) { return (LocGroup)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LocGroup nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LocGroup> listAll() {
            return new ArrayList<LocGroup>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LocGroup> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LocGroup." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LocGroup> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LocGroup> clsList = new ArrayList<LocGroup>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LocGroup> groupOf(String groupName) {
            return new ArrayList<LocGroup>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業区分
     */
    public enum Worktype implements CDef {
        /** $RV: 入庫 */
        $RV("RV", "$RV", emptyStrings())
        ,
        /** $SO: 仕分 */
        $SO("SO", "$SO", emptyStrings())
        ,
        /** $SOFULL: 棚出(単品) */
        $SOFULL("SOFULL", "$SOFULL", emptyStrings())
        ,
        /** $MV: はい替 */
        $MV("MV", "$MV", emptyStrings())
        ,
        /** $CT: 分割はい替 */
        $CT("CT", "$CT", emptyStrings())
        ,
        /** $PI: パレタイズ検品 */
        $PI("PI", "$PI", emptyStrings())
        ,
        /** $TI: 積替場受入検品 */
        $TI("TI", "$TI", emptyStrings())
        ,
        /** $DC: ロット属性変更 */
        $DC("DC", "$DC", emptyStrings())
        ,
        /** $PS: パレタイズ検品（段ボール追加） */
        $PS("PS", "$PS", emptyStrings())
        ,
        /** $SC: 段ボール状態登録 */
        $SC("SC", "$SC", emptyStrings())
        ,
        /** $JS: 国免在庫引当 */
        $JS("JS", "$JS", emptyStrings())
        ,
        /** $PM: パレットはり紙登録 */
        $PM("PM", "$PM", emptyStrings())
        ,
        /** $EX: 検査結果入力 */
        $EX("EX", "$EX", emptyStrings())
        ,
        /** $IM: 移行ツール */
        $IM("IM", "$IM", emptyStrings())
        ,
        /** $SN: 段ボール状態取消 */
        $SN("SN", "$SN", emptyStrings())
        ,
        /** $AS: カートン詰合せ */
        $AS("AS", "$AS", emptyStrings())
        ,
        /** $NS: 製品移動(その他) */
        $NS("NS", "$NS", emptyStrings())
        ;
        private static final Map<String, Worktype> _codeClsMap = new HashMap<String, Worktype>();
        private static final Map<String, Worktype> _nameClsMap = new HashMap<String, Worktype>();
        static {
            for (Worktype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Worktype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Worktype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Worktype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Worktype) { return OptionalThing.of((Worktype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Worktype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Worktype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Worktype) { return (Worktype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Worktype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Worktype> listAll() {
            return new ArrayList<Worktype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Worktype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Worktype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Worktype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Worktype> clsList = new ArrayList<Worktype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Worktype> groupOf(String groupName) {
            return new ArrayList<Worktype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * CAP銘柄区分
     */
    public enum Capitemflg implements CDef {
        /** $0: CAPセンター取扱以外銘柄 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: CAPセンター取扱銘柄 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Capitemflg> _codeClsMap = new HashMap<String, Capitemflg>();
        private static final Map<String, Capitemflg> _nameClsMap = new HashMap<String, Capitemflg>();
        static {
            for (Capitemflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Capitemflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Capitemflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Capitemflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Capitemflg) { return OptionalThing.of((Capitemflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Capitemflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Capitemflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Capitemflg) { return (Capitemflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Capitemflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Capitemflg> listAll() {
            return new ArrayList<Capitemflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Capitemflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Capitemflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Capitemflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Capitemflg> clsList = new ArrayList<Capitemflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Capitemflg> groupOf(String groupName) {
            return new ArrayList<Capitemflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * パレットはり紙ステータス
     */
    public enum Palletests implements CDef {
        /** $0: 未貼付 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 貼付済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 格納済 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Palletests> _codeClsMap = new HashMap<String, Palletests>();
        private static final Map<String, Palletests> _nameClsMap = new HashMap<String, Palletests>();
        static {
            for (Palletests value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Palletests(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Palletests; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Palletests> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Palletests) { return OptionalThing.of((Palletests)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Palletests> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Palletests codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Palletests) { return (Palletests)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Palletests nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Palletests> listAll() {
            return new ArrayList<Palletests>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Palletests> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Palletests." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Palletests> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Palletests> clsList = new ArrayList<Palletests>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Palletests> groupOf(String groupName) {
            return new ArrayList<Palletests>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 銘柄マスタ使用区分1
     */
    public enum Usid implements CDef {
        /** $11: 国産 */
        $11("11", "$11", emptyStrings())
        ,
        /** $31: 輸入 */
        $31("31", "$31", emptyStrings())
        ;
        private static final Map<String, Usid> _codeClsMap = new HashMap<String, Usid>();
        private static final Map<String, Usid> _nameClsMap = new HashMap<String, Usid>();
        static {
            for (Usid value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Usid(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Usid; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Usid> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Usid) { return OptionalThing.of((Usid)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Usid> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Usid codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Usid) { return (Usid)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Usid nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Usid> listAll() {
            return new ArrayList<Usid>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Usid> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Usid." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Usid> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Usid> clsList = new ArrayList<Usid>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Usid> groupOf(String groupName) {
            return new ArrayList<Usid>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 銘柄マスタ使用区分2
     */
    public enum Itemusedflg implements CDef {
        /** $11: 国産 */
        $11("11", "$11", emptyStrings())
        ,
        /** $31: 輸入 */
        $31("31", "$31", emptyStrings())
        ;
        private static final Map<String, Itemusedflg> _codeClsMap = new HashMap<String, Itemusedflg>();
        private static final Map<String, Itemusedflg> _nameClsMap = new HashMap<String, Itemusedflg>();
        static {
            for (Itemusedflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Itemusedflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Itemusedflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Itemusedflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Itemusedflg) { return OptionalThing.of((Itemusedflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Itemusedflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Itemusedflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Itemusedflg) { return (Itemusedflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Itemusedflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Itemusedflg> listAll() {
            return new ArrayList<Itemusedflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Itemusedflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Itemusedflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Itemusedflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Itemusedflg> clsList = new ArrayList<Itemusedflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Itemusedflg> groupOf(String groupName) {
            return new ArrayList<Itemusedflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 段ボールステータス
     */
    public enum Symbolsts implements CDef {
        /** $0: シンボル作成 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: シンボル貼付済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: パレタイザ投入済 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: パレタイズ済 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: はり紙検品済 */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, Symbolsts> _codeClsMap = new HashMap<String, Symbolsts>();
        private static final Map<String, Symbolsts> _nameClsMap = new HashMap<String, Symbolsts>();
        static {
            for (Symbolsts value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Symbolsts(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Symbolsts; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Symbolsts> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Symbolsts) { return OptionalThing.of((Symbolsts)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Symbolsts> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Symbolsts codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Symbolsts) { return (Symbolsts)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Symbolsts nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Symbolsts> listAll() {
            return new ArrayList<Symbolsts>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Symbolsts> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Symbolsts." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Symbolsts> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Symbolsts> clsList = new ArrayList<Symbolsts>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Symbolsts> groupOf(String groupName) {
            return new ArrayList<Symbolsts>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保税出庫関連リスト帳票区分
     */
    public enum Solistkbn implements CDef {
        /** $1: 棚出リスト（端数） */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 棚出リスト（単品） */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: パレット明細（単品） */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: パレット明細（端数） */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 仕分場受入検品リスト */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 積込リスト */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: パレット内個体情報コード一覧 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, Solistkbn> _codeClsMap = new HashMap<String, Solistkbn>();
        private static final Map<String, Solistkbn> _nameClsMap = new HashMap<String, Solistkbn>();
        static {
            for (Solistkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Solistkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Solistkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Solistkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Solistkbn) { return OptionalThing.of((Solistkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Solistkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Solistkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Solistkbn) { return (Solistkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Solistkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Solistkbn> listAll() {
            return new ArrayList<Solistkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Solistkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Solistkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Solistkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Solistkbn> clsList = new ArrayList<Solistkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Solistkbn> groupOf(String groupName) {
            return new ArrayList<Solistkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * パレットはり紙作成区分
     */
    public enum Palletaddflg implements CDef {
        /** $0: 自動作成 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 事前作成 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 手動作成 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Palletaddflg> _codeClsMap = new HashMap<String, Palletaddflg>();
        private static final Map<String, Palletaddflg> _nameClsMap = new HashMap<String, Palletaddflg>();
        static {
            for (Palletaddflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Palletaddflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Palletaddflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Palletaddflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Palletaddflg) { return OptionalThing.of((Palletaddflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Palletaddflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Palletaddflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Palletaddflg) { return (Palletaddflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Palletaddflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Palletaddflg> listAll() {
            return new ArrayList<Palletaddflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Palletaddflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Palletaddflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Palletaddflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Palletaddflg> clsList = new ArrayList<Palletaddflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Palletaddflg> groupOf(String groupName) {
            return new ArrayList<Palletaddflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製品区分
     */
    public enum Productdiv implements CDef {
        /** $1: 輸入品 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 国産品 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Productdiv> _codeClsMap = new HashMap<String, Productdiv>();
        private static final Map<String, Productdiv> _nameClsMap = new HashMap<String, Productdiv>();
        static {
            for (Productdiv value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Productdiv(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Productdiv; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productdiv> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Productdiv) { return OptionalThing.of((Productdiv)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productdiv> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Productdiv codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Productdiv) { return (Productdiv)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Productdiv nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Productdiv> listAll() {
            return new ArrayList<Productdiv>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Productdiv> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Productdiv." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Productdiv> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Productdiv> clsList = new ArrayList<Productdiv>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Productdiv> groupOf(String groupName) {
            return new ArrayList<Productdiv>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出庫経路区分
     */
    public enum Soroutediv implements CDef {
        /** $1: 保税通関システム */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: JT */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 新規(輸入) */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 新規(国免) */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, Soroutediv> _codeClsMap = new HashMap<String, Soroutediv>();
        private static final Map<String, Soroutediv> _nameClsMap = new HashMap<String, Soroutediv>();
        static {
            for (Soroutediv value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Soroutediv(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Soroutediv; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Soroutediv> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Soroutediv) { return OptionalThing.of((Soroutediv)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Soroutediv> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Soroutediv codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Soroutediv) { return (Soroutediv)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Soroutediv nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Soroutediv> listAll() {
            return new ArrayList<Soroutediv>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Soroutediv> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Soroutediv." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Soroutediv> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Soroutediv> clsList = new ArrayList<Soroutediv>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Soroutediv> groupOf(String groupName) {
            return new ArrayList<Soroutediv>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 依頼種別
     */
    public enum Requesttype implements CDef {
        /** $03: 商社通関 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 輸入免税 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 通関のみ */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 倉庫間移動 */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 積戻し */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: 滅却その他 */
        $08("08", "$08", emptyStrings())
        ,
        /** $09: サンプル */
        $09("09", "$09", emptyStrings())
        ,
        /** $10: 需給(定期) */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: 仮引当 */
        $11("11", "$11", emptyStrings())
        ,
        /** $13: 卸代行 */
        $13("13", "$13", emptyStrings())
        ,
        /** $20: 定期払出 */
        $20("20", "$20", emptyStrings())
        ,
        /** $21: 仮一次輸送 */
        $21("21", "$21", emptyStrings())
        ,
        /** $30: 需給(臨時) */
        $30("30", "$30", emptyStrings())
        ,
        /** $39: 需給(臨時) */
        $39("39", "$39", emptyStrings())
        ,
        /** $40: 販物登録済 */
        $40("40", "$40", emptyStrings())
        ,
        /** $41: 依頼前計画 */
        $41("41", "$41", emptyStrings())
        ,
        /** $48: 臨時要請払 */
        $48("48", "$48", emptyStrings())
        ,
        /** $49: 臨時払出 */
        $49("49", "$49", emptyStrings())
        ,
        /** $80: ボール割 */
        $80("80", "$80", emptyStrings())
        ,
        /** $K1: 国内免税品 */
        $K1("K1", "$K1", emptyStrings())
        ,
        /** $K2: 国免倉庫間移動 */
        $K2("K2", "$K2", emptyStrings())
        ,
        /** $K3: 自拠点戻し */
        $K3("K3", "$K3", emptyStrings())
        ,
        /** $K4: 簡易出庫 */
        $K4("K4", "$K4", emptyStrings())
        ;
        private static final Map<String, Requesttype> _codeClsMap = new HashMap<String, Requesttype>();
        private static final Map<String, Requesttype> _nameClsMap = new HashMap<String, Requesttype>();
        static {
            for (Requesttype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Requesttype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Requesttype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Requesttype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Requesttype) { return OptionalThing.of((Requesttype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Requesttype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Requesttype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Requesttype) { return (Requesttype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Requesttype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Requesttype> listAll() {
            return new ArrayList<Requesttype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Requesttype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Requesttype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Requesttype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Requesttype> clsList = new ArrayList<Requesttype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Requesttype> groupOf(String groupName) {
            return new ArrayList<Requesttype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検査ステータス
     */
    public enum Examsts implements CDef {
        /** $0: 未検査 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 検査中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 検査済 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Examsts> _codeClsMap = new HashMap<String, Examsts>();
        private static final Map<String, Examsts> _nameClsMap = new HashMap<String, Examsts>();
        static {
            for (Examsts value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Examsts(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Examsts; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Examsts> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Examsts) { return OptionalThing.of((Examsts)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Examsts> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Examsts codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Examsts) { return (Examsts)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Examsts nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Examsts> listAll() {
            return new ArrayList<Examsts>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Examsts> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Examsts." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Examsts> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Examsts> clsList = new ArrayList<Examsts>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Examsts> groupOf(String groupName) {
            return new ArrayList<Examsts>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 受注番号付加コード
     */
    public enum Ordernoaddcd implements CDef {
        /** $DE: 受注番号付加コード */
        $DE("DE", "$DE", emptyStrings())
        ;
        private static final Map<String, Ordernoaddcd> _codeClsMap = new HashMap<String, Ordernoaddcd>();
        private static final Map<String, Ordernoaddcd> _nameClsMap = new HashMap<String, Ordernoaddcd>();
        static {
            for (Ordernoaddcd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Ordernoaddcd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Ordernoaddcd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Ordernoaddcd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Ordernoaddcd) { return OptionalThing.of((Ordernoaddcd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Ordernoaddcd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Ordernoaddcd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Ordernoaddcd) { return (Ordernoaddcd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Ordernoaddcd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Ordernoaddcd> listAll() {
            return new ArrayList<Ordernoaddcd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Ordernoaddcd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Ordernoaddcd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Ordernoaddcd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Ordernoaddcd> clsList = new ArrayList<Ordernoaddcd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Ordernoaddcd> groupOf(String groupName) {
            return new ArrayList<Ordernoaddcd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 追跡区分
     */
    public enum Tracetype implements CDef {
        /** $01: 倉庫内 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 出庫 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 出庫 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 出庫 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 操作 */
        $05("05", "$05", emptyStrings())
        ,
        /** $80: ロケ移動 */
        $80("80", "$80", emptyStrings())
        ,
        /** $81: ロット属性変更 */
        $81("81", "$81", emptyStrings())
        ,
        /** $96: 移行 */
        $96("96", "$96", emptyStrings())
        ,
        /** $97: 不良品 */
        $97("97", "$97", emptyStrings())
        ,
        /** $98: 検査 */
        $98("98", "$98", emptyStrings())
        ,
        /** $99: その他 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, Tracetype> _codeClsMap = new HashMap<String, Tracetype>();
        private static final Map<String, Tracetype> _nameClsMap = new HashMap<String, Tracetype>();
        static {
            for (Tracetype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Tracetype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Tracetype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tracetype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Tracetype) { return OptionalThing.of((Tracetype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tracetype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Tracetype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Tracetype) { return (Tracetype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Tracetype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Tracetype> listAll() {
            return new ArrayList<Tracetype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Tracetype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Tracetype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Tracetype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Tracetype> clsList = new ArrayList<Tracetype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Tracetype> groupOf(String groupName) {
            return new ArrayList<Tracetype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 倉庫識別
     */
    public enum Warehouseid implements CDef {
        /** $0: 輸入倉庫 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 国免倉庫 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Warehouseid> _codeClsMap = new HashMap<String, Warehouseid>();
        private static final Map<String, Warehouseid> _nameClsMap = new HashMap<String, Warehouseid>();
        static {
            for (Warehouseid value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Warehouseid(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Warehouseid; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Warehouseid> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Warehouseid) { return OptionalThing.of((Warehouseid)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Warehouseid> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Warehouseid codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Warehouseid) { return (Warehouseid)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Warehouseid nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Warehouseid> listAll() {
            return new ArrayList<Warehouseid>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Warehouseid> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Warehouseid." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Warehouseid> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Warehouseid> clsList = new ArrayList<Warehouseid>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Warehouseid> groupOf(String groupName) {
            return new ArrayList<Warehouseid>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 市場区分
     */
    public enum Markettype implements CDef {
        /** $1: 空港 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 機内 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 外航船 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: その他 */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, Markettype> _codeClsMap = new HashMap<String, Markettype>();
        private static final Map<String, Markettype> _nameClsMap = new HashMap<String, Markettype>();
        static {
            for (Markettype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Markettype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Markettype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Markettype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Markettype) { return OptionalThing.of((Markettype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Markettype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Markettype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Markettype) { return (Markettype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Markettype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Markettype> listAll() {
            return new ArrayList<Markettype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Markettype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Markettype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Markettype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Markettype> clsList = new ArrayList<Markettype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Markettype> groupOf(String groupName) {
            return new ArrayList<Markettype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保留フラグ
     */
    public enum Reservationflg implements CDef {
        /** $0: - */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 異常品 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 保留品 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Reservationflg> _codeClsMap = new HashMap<String, Reservationflg>();
        private static final Map<String, Reservationflg> _nameClsMap = new HashMap<String, Reservationflg>();
        static {
            for (Reservationflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Reservationflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Reservationflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Reservationflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Reservationflg) { return OptionalThing.of((Reservationflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Reservationflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Reservationflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Reservationflg) { return (Reservationflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Reservationflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Reservationflg> listAll() {
            return new ArrayList<Reservationflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Reservationflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Reservationflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Reservationflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Reservationflg> clsList = new ArrayList<Reservationflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Reservationflg> groupOf(String groupName) {
            return new ArrayList<Reservationflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製品包装形態
     */
    public enum Packingtype implements CDef {
        /** $1: ソフトパーセル */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ハードパック */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 缶詰 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 袋詰 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: ワイドパック */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: シェル・スラ */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: その他 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, Packingtype> _codeClsMap = new HashMap<String, Packingtype>();
        private static final Map<String, Packingtype> _nameClsMap = new HashMap<String, Packingtype>();
        static {
            for (Packingtype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Packingtype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Packingtype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Packingtype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Packingtype) { return OptionalThing.of((Packingtype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Packingtype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Packingtype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Packingtype) { return (Packingtype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Packingtype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Packingtype> listAll() {
            return new ArrayList<Packingtype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Packingtype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Packingtype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Packingtype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Packingtype> clsList = new ArrayList<Packingtype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Packingtype> groupOf(String groupName) {
            return new ArrayList<Packingtype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製造記号パターン（国産）
     */
    public enum Productmarkptn implements CDef {
        /** $2001: Q */
        $2001("2001", "$2001", emptyStrings())
        ,
        /** $2002: R */
        $2002("2002", "$2002", emptyStrings())
        ,
        /** $2003: S */
        $2003("2003", "$2003", emptyStrings())
        ,
        /** $2004: T */
        $2004("2004", "$2004", emptyStrings())
        ,
        /** $2005: U */
        $2005("2005", "$2005", emptyStrings())
        ,
        /** $2006: V */
        $2006("2006", "$2006", emptyStrings())
        ,
        /** $2007: W */
        $2007("2007", "$2007", emptyStrings())
        ,
        /** $2008: X */
        $2008("2008", "$2008", emptyStrings())
        ,
        /** $2009: Y */
        $2009("2009", "$2009", emptyStrings())
        ,
        /** $2010: Z */
        $2010("2010", "$2010", emptyStrings())
        ,
        /** $2011: Q */
        $2011("2011", "$2011", emptyStrings())
        ,
        /** $2012: R */
        $2012("2012", "$2012", emptyStrings())
        ,
        /** $2013: S */
        $2013("2013", "$2013", emptyStrings())
        ,
        /** $2014: T */
        $2014("2014", "$2014", emptyStrings())
        ,
        /** $2015: U */
        $2015("2015", "$2015", emptyStrings())
        ,
        /** $2016: V */
        $2016("2016", "$2016", emptyStrings())
        ,
        /** $2017: W */
        $2017("2017", "$2017", emptyStrings())
        ,
        /** $2018: X */
        $2018("2018", "$2018", emptyStrings())
        ,
        /** $2019: Y */
        $2019("2019", "$2019", emptyStrings())
        ,
        /** $2020: Z */
        $2020("2020", "$2020", emptyStrings())
        ,
        /** $2021: Q */
        $2021("2021", "$2021", emptyStrings())
        ,
        /** $2022: R */
        $2022("2022", "$2022", emptyStrings())
        ,
        /** $2023: S */
        $2023("2023", "$2023", emptyStrings())
        ,
        /** $2024: T */
        $2024("2024", "$2024", emptyStrings())
        ,
        /** $2025: U */
        $2025("2025", "$2025", emptyStrings())
        ,
        /** $2026: V */
        $2026("2026", "$2026", emptyStrings())
        ,
        /** $2027: W */
        $2027("2027", "$2027", emptyStrings())
        ,
        /** $2028: X */
        $2028("2028", "$2028", emptyStrings())
        ,
        /** $2029: Y */
        $2029("2029", "$2029", emptyStrings())
        ,
        /** $2030: Z */
        $2030("2030", "$2030", emptyStrings())
        ,
        /** $2031: Q */
        $2031("2031", "$2031", emptyStrings())
        ,
        /** $2032: R */
        $2032("2032", "$2032", emptyStrings())
        ,
        /** $2033: S */
        $2033("2033", "$2033", emptyStrings())
        ,
        /** $2034: T */
        $2034("2034", "$2034", emptyStrings())
        ,
        /** $2035: U */
        $2035("2035", "$2035", emptyStrings())
        ,
        /** $2036: V */
        $2036("2036", "$2036", emptyStrings())
        ,
        /** $2037: W */
        $2037("2037", "$2037", emptyStrings())
        ,
        /** $2038: X */
        $2038("2038", "$2038", emptyStrings())
        ,
        /** $2039: Y */
        $2039("2039", "$2039", emptyStrings())
        ,
        /** $2040: Z */
        $2040("2040", "$2040", emptyStrings())
        ;
        private static final Map<String, Productmarkptn> _codeClsMap = new HashMap<String, Productmarkptn>();
        private static final Map<String, Productmarkptn> _nameClsMap = new HashMap<String, Productmarkptn>();
        static {
            for (Productmarkptn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Productmarkptn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Productmarkptn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productmarkptn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Productmarkptn) { return OptionalThing.of((Productmarkptn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productmarkptn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Productmarkptn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Productmarkptn) { return (Productmarkptn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Productmarkptn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Productmarkptn> listAll() {
            return new ArrayList<Productmarkptn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Productmarkptn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Productmarkptn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Productmarkptn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Productmarkptn> clsList = new ArrayList<Productmarkptn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Productmarkptn> groupOf(String groupName) {
            return new ArrayList<Productmarkptn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製造記号パターン（BATJ）
     */
    public enum Productmarkptnbatj implements CDef {
        /** $2001: 1 */
        $2001("2001", "$2001", emptyStrings())
        ,
        /** $2002: 2 */
        $2002("2002", "$2002", emptyStrings())
        ,
        /** $2003: 3 */
        $2003("2003", "$2003", emptyStrings())
        ,
        /** $2004: 4 */
        $2004("2004", "$2004", emptyStrings())
        ,
        /** $2005: 5 */
        $2005("2005", "$2005", emptyStrings())
        ,
        /** $2006: 6 */
        $2006("2006", "$2006", emptyStrings())
        ,
        /** $2007: 7 */
        $2007("2007", "$2007", emptyStrings())
        ,
        /** $2008: 8 */
        $2008("2008", "$2008", emptyStrings())
        ,
        /** $2009: 9 */
        $2009("2009", "$2009", emptyStrings())
        ,
        /** $2010: 0 */
        $2010("2010", "$2010", emptyStrings())
        ,
        /** $2011: 1 */
        $2011("2011", "$2011", emptyStrings())
        ,
        /** $2012: 2 */
        $2012("2012", "$2012", emptyStrings())
        ,
        /** $2013: 3 */
        $2013("2013", "$2013", emptyStrings())
        ,
        /** $2014: 4 */
        $2014("2014", "$2014", emptyStrings())
        ,
        /** $2015: 5 */
        $2015("2015", "$2015", emptyStrings())
        ,
        /** $2016: 6 */
        $2016("2016", "$2016", emptyStrings())
        ,
        /** $2017: 7 */
        $2017("2017", "$2017", emptyStrings())
        ,
        /** $2018: 8 */
        $2018("2018", "$2018", emptyStrings())
        ,
        /** $2019: 9 */
        $2019("2019", "$2019", emptyStrings())
        ,
        /** $2020: 0 */
        $2020("2020", "$2020", emptyStrings())
        ,
        /** $2021: 1 */
        $2021("2021", "$2021", emptyStrings())
        ,
        /** $2022: 2 */
        $2022("2022", "$2022", emptyStrings())
        ,
        /** $2023: 3 */
        $2023("2023", "$2023", emptyStrings())
        ,
        /** $2024: 4 */
        $2024("2024", "$2024", emptyStrings())
        ,
        /** $2025: 5 */
        $2025("2025", "$2025", emptyStrings())
        ,
        /** $2026: 6 */
        $2026("2026", "$2026", emptyStrings())
        ,
        /** $2027: 7 */
        $2027("2027", "$2027", emptyStrings())
        ,
        /** $2028: 8 */
        $2028("2028", "$2028", emptyStrings())
        ,
        /** $2029: 9 */
        $2029("2029", "$2029", emptyStrings())
        ,
        /** $2030: 0 */
        $2030("2030", "$2030", emptyStrings())
        ,
        /** $2031: 1 */
        $2031("2031", "$2031", emptyStrings())
        ,
        /** $2032: 2 */
        $2032("2032", "$2032", emptyStrings())
        ,
        /** $2033: 3 */
        $2033("2033", "$2033", emptyStrings())
        ,
        /** $2034: 4 */
        $2034("2034", "$2034", emptyStrings())
        ,
        /** $2035: 5 */
        $2035("2035", "$2035", emptyStrings())
        ,
        /** $2036: 6 */
        $2036("2036", "$2036", emptyStrings())
        ,
        /** $2037: 7 */
        $2037("2037", "$2037", emptyStrings())
        ,
        /** $2038: 8 */
        $2038("2038", "$2038", emptyStrings())
        ,
        /** $2039: 9 */
        $2039("2039", "$2039", emptyStrings())
        ,
        /** $2040: 0 */
        $2040("2040", "$2040", emptyStrings())
        ;
        private static final Map<String, Productmarkptnbatj> _codeClsMap = new HashMap<String, Productmarkptnbatj>();
        private static final Map<String, Productmarkptnbatj> _nameClsMap = new HashMap<String, Productmarkptnbatj>();
        static {
            for (Productmarkptnbatj value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Productmarkptnbatj(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Productmarkptnbatj; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productmarkptnbatj> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Productmarkptnbatj) { return OptionalThing.of((Productmarkptnbatj)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productmarkptnbatj> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Productmarkptnbatj codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Productmarkptnbatj) { return (Productmarkptnbatj)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Productmarkptnbatj nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Productmarkptnbatj> listAll() {
            return new ArrayList<Productmarkptnbatj>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Productmarkptnbatj> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Productmarkptnbatj." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Productmarkptnbatj> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Productmarkptnbatj> clsList = new ArrayList<Productmarkptnbatj>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Productmarkptnbatj> groupOf(String groupName) {
            return new ArrayList<Productmarkptnbatj>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製造記号月コード
     */
    public enum Productmarkmonth implements CDef {
        /** $01: A */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: B */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: C */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: D */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: E */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: F */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: G */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: H */
        $08("08", "$08", emptyStrings())
        ,
        /** $09: I */
        $09("09", "$09", emptyStrings())
        ,
        /** $10: J */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: K */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: L */
        $12("12", "$12", emptyStrings())
        ;
        private static final Map<String, Productmarkmonth> _codeClsMap = new HashMap<String, Productmarkmonth>();
        private static final Map<String, Productmarkmonth> _nameClsMap = new HashMap<String, Productmarkmonth>();
        static {
            for (Productmarkmonth value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Productmarkmonth(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Productmarkmonth; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productmarkmonth> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Productmarkmonth) { return OptionalThing.of((Productmarkmonth)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productmarkmonth> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Productmarkmonth codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Productmarkmonth) { return (Productmarkmonth)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Productmarkmonth nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Productmarkmonth> listAll() {
            return new ArrayList<Productmarkmonth>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Productmarkmonth> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Productmarkmonth." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Productmarkmonth> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Productmarkmonth> clsList = new ArrayList<Productmarkmonth>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Productmarkmonth> groupOf(String groupName) {
            return new ArrayList<Productmarkmonth>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 賞味期限月数
     */
    public enum Limitdatemonth implements CDef {
        /** $1: 9 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Limitdatemonth> _codeClsMap = new HashMap<String, Limitdatemonth>();
        private static final Map<String, Limitdatemonth> _nameClsMap = new HashMap<String, Limitdatemonth>();
        static {
            for (Limitdatemonth value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Limitdatemonth(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Limitdatemonth; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Limitdatemonth> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Limitdatemonth) { return OptionalThing.of((Limitdatemonth)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Limitdatemonth> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Limitdatemonth codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Limitdatemonth) { return (Limitdatemonth)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Limitdatemonth nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Limitdatemonth> listAll() {
            return new ArrayList<Limitdatemonth>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Limitdatemonth> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Limitdatemonth." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Limitdatemonth> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Limitdatemonth> clsList = new ArrayList<Limitdatemonth>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Limitdatemonth> groupOf(String groupName) {
            return new ArrayList<Limitdatemonth>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当可能賞味期限残月数
     */
    public enum Alclimitdatemonth implements CDef {
        /** $1: 2 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Alclimitdatemonth> _codeClsMap = new HashMap<String, Alclimitdatemonth>();
        private static final Map<String, Alclimitdatemonth> _nameClsMap = new HashMap<String, Alclimitdatemonth>();
        static {
            for (Alclimitdatemonth value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Alclimitdatemonth(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Alclimitdatemonth; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Alclimitdatemonth> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Alclimitdatemonth) { return OptionalThing.of((Alclimitdatemonth)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Alclimitdatemonth> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Alclimitdatemonth codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Alclimitdatemonth) { return (Alclimitdatemonth)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Alclimitdatemonth nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Alclimitdatemonth> listAll() {
            return new ArrayList<Alclimitdatemonth>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Alclimitdatemonth> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Alclimitdatemonth." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Alclimitdatemonth> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Alclimitdatemonth> clsList = new ArrayList<Alclimitdatemonth>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Alclimitdatemonth> groupOf(String groupName) {
            return new ArrayList<Alclimitdatemonth>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ラベルレイアウトマスタ
     */
    public enum Labellayoutmaster implements CDef {
        /** $SG408R: ラベルプリンタ */
        $SG408R("SG408R", "$SG408R", emptyStrings())
        ,
        /** $PT408e: ラベルプリンタ（ポータル） */
        $PT408e("PT408e", "$PT408e", emptyStrings())
        ;
        private static final Map<String, Labellayoutmaster> _codeClsMap = new HashMap<String, Labellayoutmaster>();
        private static final Map<String, Labellayoutmaster> _nameClsMap = new HashMap<String, Labellayoutmaster>();
        static {
            for (Labellayoutmaster value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Labellayoutmaster(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Labellayoutmaster; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Labellayoutmaster> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Labellayoutmaster) { return OptionalThing.of((Labellayoutmaster)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Labellayoutmaster> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Labellayoutmaster codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Labellayoutmaster) { return (Labellayoutmaster)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Labellayoutmaster nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Labellayoutmaster> listAll() {
            return new ArrayList<Labellayoutmaster>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Labellayoutmaster> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Labellayoutmaster." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Labellayoutmaster> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Labellayoutmaster> clsList = new ArrayList<Labellayoutmaster>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Labellayoutmaster> groupOf(String groupName) {
            return new ArrayList<Labellayoutmaster>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 輸送形態
     */
    public enum Trafficpattern implements CDef {
        /** $2020: トラック１０ｔ */
        $2020("2020", "$2020", emptyStrings())
        ,
        /** $2060: トラック  ４ｔ */
        $2060("2060", "$2060", emptyStrings())
        ,
        /** $3010: コンテナＰ */
        $3010("3010", "$3010", emptyStrings())
        ,
        /** $3510: コンテナ３１ｆｔ　 */
        $3510("3510", "$3510", emptyStrings())
        ,
        /** $4021: 海上コンテナ５ｔ */
        $4021("4021", "$4021", emptyStrings())
        ,
        /** $4031: 海上コンテナ１０ｔ */
        $4031("4031", "$4031", emptyStrings())
        ,
        /** $4081: 海上トレーラ */
        $4081("4081", "$4081", emptyStrings())
        ,
        /** $5011: 路線　バラ */
        $5011("5011", "$5011", emptyStrings())
        ,
        /** $5020: 路線　パレ */
        $5020("5020", "$5020", emptyStrings())
        ,
        /** $5050: Ａｉｒ便 */
        $5050("5050", "$5050", emptyStrings())
        ,
        /** $5060: 宅配便 */
        $5060("5060", "$5060", emptyStrings())
        ,
        /** $8021: 巡回 東京-王子 */
        $8021("8021", "$8021", emptyStrings())
        ,
        /** $8022: 巡回 千葉-王子 */
        $8022("8022", "$8022", emptyStrings())
        ,
        /** $8023: 巡回 千葉-東京 */
        $8023("8023", "$8023", emptyStrings())
        ,
        /** $8024: 巡回千葉-東京-王子 */
        $8024("8024", "$8024", emptyStrings())
        ,
        /** $8025: 巡回千葉-東京-王子 10 */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8054: 巡回-神戸-大阪-泉大津 */
        $8054("8054", "$8054", emptyStrings())
        ,
        /** $8055: 巡回-神戸-大阪-泉大津 10 */
        $8055("8055", "$8055", emptyStrings())
        ,
        /** $8056: 巡回-神戸-大阪 */
        $8056("8056", "$8056", emptyStrings())
        ,
        /** $8057: 巡回-神戸-泉大津 */
        $8057("8057", "$8057", emptyStrings())
        ,
        /** $8058: 巡回-泉大津-大阪 */
        $8058("8058", "$8058", emptyStrings())
        ;
        private static final Map<String, Trafficpattern> _codeClsMap = new HashMap<String, Trafficpattern>();
        private static final Map<String, Trafficpattern> _nameClsMap = new HashMap<String, Trafficpattern>();
        static {
            for (Trafficpattern value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Trafficpattern(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Trafficpattern; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Trafficpattern> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Trafficpattern) { return OptionalThing.of((Trafficpattern)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Trafficpattern> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Trafficpattern codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Trafficpattern) { return (Trafficpattern)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Trafficpattern nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Trafficpattern> listAll() {
            return new ArrayList<Trafficpattern>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Trafficpattern> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Trafficpattern." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Trafficpattern> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Trafficpattern> clsList = new ArrayList<Trafficpattern>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Trafficpattern> groupOf(String groupName) {
            return new ArrayList<Trafficpattern>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * たばこ区分
     */
    public enum Cgrid implements CDef {
        /** $01hsphsp: 紙巻 */
        $01hsphsp("01\u0020\u0020", "$01hsphsp", emptyStrings())
        ,
        /** $02hsphsp: 刻み */
        $02hsphsp("02\u0020\u0020", "$02hsphsp", emptyStrings())
        ,
        /** $03hsphsp: パイプ */
        $03hsphsp("03\u0020\u0020", "$03hsphsp", emptyStrings())
        ,
        /** $04hsphsp: 葉巻 */
        $04hsphsp("04\u0020\u0020", "$04hsphsp", emptyStrings())
        ,
        /** $05hsphsp: 嗅ぎたばこ */
        $05hsphsp("05\u0020\u0020", "$05hsphsp", emptyStrings())
        ,
        /** $06hsphsp: かみたばこ */
        $06hsphsp("06\u0020\u0020", "$06hsphsp", emptyStrings())
        ,
        /** $11hsphsp: 第１種本則分 */
        $11hsphsp("11\u0020\u0020", "$11hsphsp", emptyStrings())
        ,
        /** $12hsphsp: 第２種 */
        $12hsphsp("12\u0020\u0020", "$12hsphsp", emptyStrings())
        ,
        /** $13hsphsp: 第３種 */
        $13hsphsp("13\u0020\u0020", "$13hsphsp", emptyStrings())
        ,
        /** $14hsphsp: 第４種 */
        $14hsphsp("14\u0020\u0020", "$14hsphsp", emptyStrings())
        ,
        /** $15hsphsp: 第１種暫定分 */
        $15hsphsp("15\u0020\u0020", "$15hsphsp", emptyStrings())
        ,
        /** $20hsphsp: かみ用 */
        $20hsphsp("20\u0020\u0020", "$20hsphsp", emptyStrings())
        ,
        /** $30hsphsp: かぎ用 */
        $30hsphsp("30\u0020\u0020", "$30hsphsp", emptyStrings())
        ,
        /** $99hsphsp: その他 */
        $99hsphsp("99\u0020\u0020", "$99hsphsp", emptyStrings())
        ;
        private static final Map<String, Cgrid> _codeClsMap = new HashMap<String, Cgrid>();
        private static final Map<String, Cgrid> _nameClsMap = new HashMap<String, Cgrid>();
        static {
            for (Cgrid value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Cgrid(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Cgrid; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cgrid> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Cgrid) { return OptionalThing.of((Cgrid)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cgrid> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Cgrid codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Cgrid) { return (Cgrid)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Cgrid nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Cgrid> listAll() {
            return new ArrayList<Cgrid>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Cgrid> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Cgrid." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Cgrid> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Cgrid> clsList = new ArrayList<Cgrid>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Cgrid> groupOf(String groupName) {
            return new ArrayList<Cgrid>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 帳票名
     */
    public enum Reportname implements CDef {
        /** $tsnH_ReceivePlanREPORT4: 格納先予定リスト */
        $tsnH_ReceivePlanREPORT4("tsnH_ReceivePlanREPORT4", "$tsnH_ReceivePlanREPORT4", emptyStrings())
        ,
        /** $tsnH_PalletLabelREPORT2: パレットはり紙作成 */
        $tsnH_PalletLabelREPORT2("tsnH_PalletLabelREPORT2", "$tsnH_PalletLabelREPORT2", emptyStrings())
        ,
        /** $tsnH_InventoryREPORT2: 在庫調査指示リスト */
        $tsnH_InventoryREPORT2("tsnH_InventoryREPORT2", "$tsnH_InventoryREPORT2", emptyStrings())
        ,
        /** $tsnH_InvDifREPORT2: 在庫調査差異リスト */
        $tsnH_InvDifREPORT2("tsnH_InvDifREPORT2", "$tsnH_InvDifREPORT2", emptyStrings())
        ,
        /** $tsnH_InvListREPORT: ロット別在庫表 */
        $tsnH_InvListREPORT("tsnH_InvListREPORT", "$tsnH_InvListREPORT", emptyStrings())
        ,
        /** $tsnH_ALCENTRYREPORT2: 棚出引当不能リスト */
        $tsnH_ALCENTRYREPORT2("tsnH_ALCENTRYREPORT2", "$tsnH_ALCENTRYREPORT2", emptyStrings())
        ,
        /** $tsnH_SOListREPORT2: 棚出リスト(単品) */
        $tsnH_SOListREPORT2("tsnH_SOListREPORT2", "$tsnH_SOListREPORT2", emptyStrings())
        ,
        /** $tsnH_SOListREPORT1: 棚出リスト(端数) */
        $tsnH_SOListREPORT1("tsnH_SOListREPORT1", "$tsnH_SOListREPORT1", emptyStrings())
        ,
        /** $tsnH_SOListREPORT6: 積込リスト */
        $tsnH_SOListREPORT6("tsnH_SOListREPORT6", "$tsnH_SOListREPORT6", emptyStrings())
        ,
        /** $tsnH_SOListREPORT5: 仕分場受入検品リスト */
        $tsnH_SOListREPORT5("tsnH_SOListREPORT5", "$tsnH_SOListREPORT5", emptyStrings())
        ,
        /** $tsnH_SOListREPORT3: パレット明細（単品） */
        $tsnH_SOListREPORT3("tsnH_SOListREPORT3", "$tsnH_SOListREPORT3", emptyStrings())
        ,
        /** $tsnH_SOListREPORT4: パレット明細（端数） */
        $tsnH_SOListREPORT4("tsnH_SOListREPORT4", "$tsnH_SOListREPORT4", emptyStrings())
        ,
        /** $tsnH_SOListREPORT7: パレット内個体情報コード一覧 */
        $tsnH_SOListREPORT7("tsnH_SOListREPORT7", "$tsnH_SOListREPORT7", emptyStrings())
        ,
        /** $tsnH_TaxationProdAdjustReport: 国内免税 在庫照合リスト */
        $tsnH_TaxationProdAdjustReport("tsnH_TaxationProdAdjustReport", "$tsnH_TaxationProdAdjustReport", emptyStrings())
        ,
        /** $tsnH_SOCANCELPICKREPORT2: 棚出済リスト（単品） */
        $tsnH_SOCANCELPICKREPORT2("tsnH_SOCANCELPICKREPORT2", "$tsnH_SOCANCELPICKREPORT2", emptyStrings())
        ,
        /** $tsnH_SOCANCELPICKREPORT1: 棚出済リスト（端数） */
        $tsnH_SOCANCELPICKREPORT1("tsnH_SOCANCELPICKREPORT1", "$tsnH_SOCANCELPICKREPORT1", emptyStrings())
        ,
        /** $tsnH_SODivListREPORT: 段落とし指示書 */
        $tsnH_SODivListREPORT("tsnH_SODivListREPORT", "$tsnH_SODivListREPORT", emptyStrings())
        ,
        /** $tsnH_SODivPalletREPORT: パレット明細（段落とし・端数） */
        $tsnH_SODivPalletREPORT("tsnH_SODivPalletREPORT", "$tsnH_SODivPalletREPORT", emptyStrings())
        ,
        /** $tsnH_MvInventoryREPORT2: 在庫調査指示リスト（入出庫ロケのみ） */
        $tsnH_MvInventoryREPORT2("tsnH_MvInventoryREPORT2", "$tsnH_MvInventoryREPORT2", emptyStrings())
        ,
        /** $tsnH_ImportedProdAdjustReport: 輸入製品在庫照合リスト */
        $tsnH_ImportedProdAdjustReport("tsnH_ImportedProdAdjustReport", "$tsnH_ImportedProdAdjustReport", emptyStrings())
        ;
        private static final Map<String, Reportname> _codeClsMap = new HashMap<String, Reportname>();
        private static final Map<String, Reportname> _nameClsMap = new HashMap<String, Reportname>();
        static {
            for (Reportname value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Reportname(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Reportname; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Reportname> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Reportname) { return OptionalThing.of((Reportname)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Reportname> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Reportname codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Reportname) { return (Reportname)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Reportname nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Reportname> listAll() {
            return new ArrayList<Reportname>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Reportname> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Reportname." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Reportname> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Reportname> clsList = new ArrayList<Reportname>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Reportname> groupOf(String groupName) {
            return new ArrayList<Reportname>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 条件フラグ
     */
    public enum Jyokenflg implements CDef {
        /** $0: 差分 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全件表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Jyokenflg> _codeClsMap = new HashMap<String, Jyokenflg>();
        private static final Map<String, Jyokenflg> _nameClsMap = new HashMap<String, Jyokenflg>();
        static {
            for (Jyokenflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Jyokenflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Jyokenflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Jyokenflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Jyokenflg) { return OptionalThing.of((Jyokenflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Jyokenflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Jyokenflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Jyokenflg) { return (Jyokenflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Jyokenflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Jyokenflg> listAll() {
            return new ArrayList<Jyokenflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Jyokenflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Jyokenflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Jyokenflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Jyokenflg> clsList = new ArrayList<Jyokenflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Jyokenflg> groupOf(String groupName) {
            return new ArrayList<Jyokenflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 移行用お得意様コード
     */
    public enum Imshiptocode implements CDef {
        /** $01: ZZZZ */
        $01("01", "$01", emptyStrings())
        ;
        private static final Map<String, Imshiptocode> _codeClsMap = new HashMap<String, Imshiptocode>();
        private static final Map<String, Imshiptocode> _nameClsMap = new HashMap<String, Imshiptocode>();
        static {
            for (Imshiptocode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Imshiptocode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Imshiptocode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Imshiptocode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Imshiptocode) { return OptionalThing.of((Imshiptocode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Imshiptocode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Imshiptocode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Imshiptocode) { return (Imshiptocode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Imshiptocode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Imshiptocode> listAll() {
            return new ArrayList<Imshiptocode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Imshiptocode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Imshiptocode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Imshiptocode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Imshiptocode> clsList = new ArrayList<Imshiptocode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Imshiptocode> groupOf(String groupName) {
            return new ArrayList<Imshiptocode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ファイル関連情報
     */
    public enum Fileinfo implements CDef {
        /** $01: 代表QR出力バッチ */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: シンボル印刷ファイル送信 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 代表QRブランク画像 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: QRイメージ作成パス（DBサーバ） */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 代表QRイメージパス（APサーバ） */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 製品追跡カートン出庫保存日数 */
        $06("06", "$06", emptyStrings())
        ;
        private static final Map<String, Fileinfo> _codeClsMap = new HashMap<String, Fileinfo>();
        private static final Map<String, Fileinfo> _nameClsMap = new HashMap<String, Fileinfo>();
        static {
            for (Fileinfo value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Fileinfo(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Fileinfo; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fileinfo> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Fileinfo) { return OptionalThing.of((Fileinfo)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fileinfo> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Fileinfo codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Fileinfo) { return (Fileinfo)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Fileinfo nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Fileinfo> listAll() {
            return new ArrayList<Fileinfo>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Fileinfo> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Fileinfo." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Fileinfo> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Fileinfo> clsList = new ArrayList<Fileinfo>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Fileinfo> groupOf(String groupName) {
            return new ArrayList<Fileinfo>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出庫先変換マスタ
     */
    public enum Shiptocdchg implements CDef {
        /** $1006: 森本倉庫 */
        $1006("1006", "$1006", emptyStrings())
        ,
        /** $3001: tsn　大井倉庫 */
        $3001("3001", "$3001", emptyStrings())
        ,
        /** $3002: tsn　六甲倉庫 */
        $3002("3002", "$3002", emptyStrings())
        ,
        /** $3003: 渋沢倉庫 */
        $3003("3003", "$3003", emptyStrings())
        ,
        /** $3004: tsn　CAPセンター */
        $3004("3004", "$3004", emptyStrings())
        ,
        /** $3005: ケイヒン倉庫５Ｆ */
        $3005("3005", "$3005", emptyStrings())
        ,
        /** $3006: ケイヒン倉庫５Ｆ */
        $3006("3006", "$3006", emptyStrings())
        ,
        /** $3007: 森本倉庫 */
        $3007("3007", "$3007", emptyStrings())
        ,
        /** $3012: 丸運倉庫 */
        $3012("3012", "$3012", emptyStrings())
        ,
        /** $3013: ケイヒン倉庫２Ｆ */
        $3013("3013", "$3013", emptyStrings())
        ,
        /** $3014: 大井２号倉庫 */
        $3014("3014", "$3014", emptyStrings())
        ,
        /** $3020: tsn　大井倉庫 */
        $3020("3020", "$3020", emptyStrings())
        ,
        /** $3050: tsn　六甲倉庫 */
        $3050("3050", "$3050", emptyStrings())
        ,
        /** $3030: tsn　CAPセンター */
        $3030("3030", "$3030", emptyStrings())
        ,
        /** $4024: 渋沢倉庫 */
        $4024("4024", "$4024", emptyStrings())
        ,
        /** $4027: 大井２号倉庫 */
        $4027("4027", "$4027", emptyStrings())
        ,
        /** $4052: 森本倉庫 */
        $4052("4052", "$4052", emptyStrings())
        ,
        /** $4076: ケイヒン倉庫５Ｆ */
        $4076("4076", "$4076", emptyStrings())
        ,
        /** $4077: 丸運倉庫 */
        $4077("4077", "$4077", emptyStrings())
        ,
        /** $4078: ケイヒン倉庫２Ｆ */
        $4078("4078", "$4078", emptyStrings())
        ,
        /** $4079: ユニエックス倉庫 */
        $4079("4079", "$4079", emptyStrings())
        ,
        /** $4070: 内外日東倉庫 */
        $4070("4070", "$4070", emptyStrings())
        ,
        /** $4084: 澁澤倉庫　摩耶営業所 */
        $4084("4084", "$4084", emptyStrings())
        ,
        /** $4085: 日通南東京 */
        $4085("4085", "$4085", emptyStrings())
        ,
        /** $4044: 鈴与　倉庫 */
        $4044("4044", "$4044", emptyStrings())
        ,
        /** $4086: ケイヒン新お台場 */
        $4086("4086", "$4086", emptyStrings())
        ,
        /** $4087: 栗林運輸 */
        $4087("4087", "$4087", emptyStrings())
        ,
        /** $4089: 伊勢湾海運 */
        $4089("4089", "$4089", emptyStrings())
        ,
        /** $4090: 澁澤　ワールド */
        $4090("4090", "$4090", emptyStrings())
        ,
        /** $4091: ＹＣＣ */
        $4091("4091", "$4091", emptyStrings())
        ,
        /** $4116: 住友倉庫 */
        $4116("4116", "$4116", emptyStrings())
        ,
        /** $4120: 東京海貨倉庫 */
        $4120("4120", "$4120", emptyStrings())
        ;
        private static final Map<String, Shiptocdchg> _codeClsMap = new HashMap<String, Shiptocdchg>();
        private static final Map<String, Shiptocdchg> _nameClsMap = new HashMap<String, Shiptocdchg>();
        static {
            for (Shiptocdchg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Shiptocdchg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Shiptocdchg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Shiptocdchg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Shiptocdchg) { return OptionalThing.of((Shiptocdchg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Shiptocdchg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Shiptocdchg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Shiptocdchg) { return (Shiptocdchg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Shiptocdchg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Shiptocdchg> listAll() {
            return new ArrayList<Shiptocdchg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Shiptocdchg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Shiptocdchg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Shiptocdchg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Shiptocdchg> clsList = new ArrayList<Shiptocdchg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Shiptocdchg> groupOf(String groupName) {
            return new ArrayList<Shiptocdchg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 流通センターマスタ
     */
    public enum Tdwmscd implements CDef {
        /** $8351: 札幌支店 */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 釧路流通センター */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8036: 青森配送センター */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8037: 盛岡流通センター */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 仙台流通センター */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 水戸流通センター */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 宇都宮流通センター */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 高崎流通センター */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 埼玉流通センター */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 新座流通センター */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 千葉流通センター */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 羽田流通センター */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 東京支店 */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 神奈川流通センター */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 新潟流通センター */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 松本流通センター */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 金沢流通センター */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 浜松流通センター */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 名古屋支店 */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 大阪支店 */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 泉大津流通センター */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 神戸流通センター */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 米子流通センター */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 岡山流通センター */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 広島流通センター */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 高松流通センター */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 福岡支店 */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 小倉流通センター */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 鹿児島流通センター */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 沖縄流通センター */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8499: ＣＡＰ流通センター */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 京都流通センター */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 大井東センター */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 埼玉配送センター */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, Tdwmscd> _codeClsMap = new HashMap<String, Tdwmscd>();
        private static final Map<String, Tdwmscd> _nameClsMap = new HashMap<String, Tdwmscd>();
        static {
            for (Tdwmscd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Tdwmscd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Tdwmscd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tdwmscd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Tdwmscd) { return OptionalThing.of((Tdwmscd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tdwmscd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Tdwmscd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Tdwmscd) { return (Tdwmscd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Tdwmscd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Tdwmscd> listAll() {
            return new ArrayList<Tdwmscd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Tdwmscd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Tdwmscd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Tdwmscd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Tdwmscd> clsList = new ArrayList<Tdwmscd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Tdwmscd> groupOf(String groupName) {
            return new ArrayList<Tdwmscd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 受払データタイプ
     */
    public enum Inoutdatatype implements CDef {
        /** $ADJ: 滅却 */
        $ADJ("ADJ", "$ADJ", emptyStrings())
        ,
        /** $AMDFY: 属性一括変更 */
        $AMDFY("AMDFY", "$AMDFY", emptyStrings())
        ,
        /** $ITRNS: 品目振替 */
        $ITRNS("ITRNS", "$ITRNS", emptyStrings())
        ,
        /** $MDFY: 属性変更 */
        $MDFY("MDFY", "$MDFY", emptyStrings())
        ,
        /** $RCV: 入荷 */
        $RCV("RCV", "$RCV", emptyStrings())
        ,
        /** $SO: 出荷 */
        $SO("SO", "$SO", emptyStrings())
        ,
        /** $THROU: スルー */
        $THROU("THROU", "$THROU", emptyStrings())
        ,
        /** $TRANS: 名義変更 */
        $TRANS("TRANS", "$TRANS", emptyStrings())
        ,
        /** $VTRNS: 仮想名義変更 */
        $VTRNS("VTRNS", "$VTRNS", emptyStrings())
        ,
        /** $WMOVE: 倉庫間移動 */
        $WMOVE("WMOVE", "$WMOVE", emptyStrings())
        ,
        /** $WMRCV: 倉庫間移動入荷 */
        $WMRCV("WMRCV", "$WMRCV", emptyStrings())
        ,
        /** $WMSO: 倉庫間移動出荷 */
        $WMSO("WMSO", "$WMSO", emptyStrings())
        ,
        /** $SHIFT: 移行時出庫 */
        $SHIFT("SHIFT", "$SHIFT", emptyStrings())
        ;
        private static final Map<String, Inoutdatatype> _codeClsMap = new HashMap<String, Inoutdatatype>();
        private static final Map<String, Inoutdatatype> _nameClsMap = new HashMap<String, Inoutdatatype>();
        static {
            for (Inoutdatatype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Inoutdatatype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Inoutdatatype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inoutdatatype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Inoutdatatype) { return OptionalThing.of((Inoutdatatype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inoutdatatype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Inoutdatatype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Inoutdatatype) { return (Inoutdatatype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Inoutdatatype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Inoutdatatype> listAll() {
            return new ArrayList<Inoutdatatype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Inoutdatatype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Inoutdatatype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Inoutdatatype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Inoutdatatype> clsList = new ArrayList<Inoutdatatype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Inoutdatatype> groupOf(String groupName) {
            return new ArrayList<Inoutdatatype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷動き在庫調査対象期間
     */
    public enum Invmoveterm implements CDef {
        /** $1: 90 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Invmoveterm> _codeClsMap = new HashMap<String, Invmoveterm>();
        private static final Map<String, Invmoveterm> _nameClsMap = new HashMap<String, Invmoveterm>();
        static {
            for (Invmoveterm value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Invmoveterm(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Invmoveterm; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Invmoveterm> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Invmoveterm) { return OptionalThing.of((Invmoveterm)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Invmoveterm> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Invmoveterm codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Invmoveterm) { return (Invmoveterm)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Invmoveterm nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Invmoveterm> listAll() {
            return new ArrayList<Invmoveterm>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Invmoveterm> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Invmoveterm." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Invmoveterm> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Invmoveterm> clsList = new ArrayList<Invmoveterm>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Invmoveterm> groupOf(String groupName) {
            return new ArrayList<Invmoveterm>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * シンボル貼付システム送信用HULFTマスタ
     */
    public enum Symbolsendhulftmaster implements CDef {
        /** $TDPA2010: 銘柄テーブル（シンボル貼付システム）（大井）正 */
        $TDPA2010("TDPA2010", "$TDPA2010", emptyStrings())
        ,
        /** $TDPA201A: 銘柄テーブル（シンボル貼付システム）（大井）副 */
        $TDPA201A("TDPA201A", "$TDPA201A", emptyStrings())
        ,
        /** $TDPA2020: 銘柄テーブル（シンボル貼付システム）（六甲）正 */
        $TDPA2020("TDPA2020", "$TDPA2020", emptyStrings())
        ,
        /** $TDPA202A: 銘柄テーブル（シンボル貼付システム）（六甲）副 */
        $TDPA202A("TDPA202A", "$TDPA202A", emptyStrings())
        ,
        /** $TDPB5010: 入庫作業情報ファイル（大井）正 */
        $TDPB5010("TDPB5010", "$TDPB5010", emptyStrings())
        ,
        /** $TDPB501A: 入庫作業情報ファイル（大井）副 */
        $TDPB501A("TDPB501A", "$TDPB501A", emptyStrings())
        ,
        /** $TDPB5020: 入庫作業情報ファイル（六甲）正 */
        $TDPB5020("TDPB5020", "$TDPB5020", emptyStrings())
        ,
        /** $TDPB502A: 入庫作業情報ファイル（六甲）副 */
        $TDPB502A("TDPB502A", "$TDPB502A", emptyStrings())
        ;
        private static final Map<String, Symbolsendhulftmaster> _codeClsMap = new HashMap<String, Symbolsendhulftmaster>();
        private static final Map<String, Symbolsendhulftmaster> _nameClsMap = new HashMap<String, Symbolsendhulftmaster>();
        static {
            for (Symbolsendhulftmaster value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Symbolsendhulftmaster(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Symbolsendhulftmaster; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Symbolsendhulftmaster> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Symbolsendhulftmaster) { return OptionalThing.of((Symbolsendhulftmaster)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Symbolsendhulftmaster> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Symbolsendhulftmaster codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Symbolsendhulftmaster) { return (Symbolsendhulftmaster)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Symbolsendhulftmaster nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Symbolsendhulftmaster> listAll() {
            return new ArrayList<Symbolsendhulftmaster>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Symbolsendhulftmaster> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Symbolsendhulftmaster." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Symbolsendhulftmaster> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Symbolsendhulftmaster> clsList = new ArrayList<Symbolsendhulftmaster>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Symbolsendhulftmaster> groupOf(String groupName) {
            return new ArrayList<Symbolsendhulftmaster>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ログ出力フラグ
     */
    public enum Logflag implements CDef {
        /** $01: 1 */
        $01("01", "$01", emptyStrings())
        ;
        private static final Map<String, Logflag> _codeClsMap = new HashMap<String, Logflag>();
        private static final Map<String, Logflag> _nameClsMap = new HashMap<String, Logflag>();
        static {
            for (Logflag value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Logflag(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Logflag; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Logflag> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Logflag) { return OptionalThing.of((Logflag)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Logflag> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Logflag codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Logflag) { return (Logflag)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Logflag nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Logflag> listAll() {
            return new ArrayList<Logflag>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Logflag> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Logflag." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Logflag> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Logflag> clsList = new ArrayList<Logflag>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Logflag> groupOf(String groupName) {
            return new ArrayList<Logflag>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 詰合せ状態
     */
    public enum Assortmentsts implements CDef {
        /** $0 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 詰合せ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 詰合せ（在庫区分混合） */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Assortmentsts> _codeClsMap = new HashMap<String, Assortmentsts>();
        private static final Map<String, Assortmentsts> _nameClsMap = new HashMap<String, Assortmentsts>();
        static {
            for (Assortmentsts value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Assortmentsts(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Assortmentsts; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Assortmentsts> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Assortmentsts) { return OptionalThing.of((Assortmentsts)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Assortmentsts> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Assortmentsts codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Assortmentsts) { return (Assortmentsts)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Assortmentsts nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Assortmentsts> listAll() {
            return new ArrayList<Assortmentsts>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Assortmentsts> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Assortmentsts." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Assortmentsts> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Assortmentsts> clsList = new ArrayList<Assortmentsts>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Assortmentsts> groupOf(String groupName) {
            return new ArrayList<Assortmentsts>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 詰合せフラグ
     */
    public enum Assortmentflg implements CDef {
        /** $0 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 詰合せ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Assortmentflg> _codeClsMap = new HashMap<String, Assortmentflg>();
        private static final Map<String, Assortmentflg> _nameClsMap = new HashMap<String, Assortmentflg>();
        static {
            for (Assortmentflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Assortmentflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Assortmentflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Assortmentflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Assortmentflg) { return OptionalThing.of((Assortmentflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Assortmentflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Assortmentflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Assortmentflg) { return (Assortmentflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Assortmentflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Assortmentflg> listAll() {
            return new ArrayList<Assortmentflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Assortmentflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Assortmentflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Assortmentflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Assortmentflg> clsList = new ArrayList<Assortmentflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Assortmentflg> groupOf(String groupName) {
            return new ArrayList<Assortmentflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検索用詰合せ状態
     */
    public enum Aststsforsearch implements CDef {
        /** $0: 未 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Aststsforsearch> _codeClsMap = new HashMap<String, Aststsforsearch>();
        private static final Map<String, Aststsforsearch> _nameClsMap = new HashMap<String, Aststsforsearch>();
        static {
            for (Aststsforsearch value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Aststsforsearch(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Aststsforsearch; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Aststsforsearch> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Aststsforsearch) { return OptionalThing.of((Aststsforsearch)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Aststsforsearch> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Aststsforsearch codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Aststsforsearch) { return (Aststsforsearch)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Aststsforsearch nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Aststsforsearch> listAll() {
            return new ArrayList<Aststsforsearch>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Aststsforsearch> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Aststsforsearch." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Aststsforsearch> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Aststsforsearch> clsList = new ArrayList<Aststsforsearch>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Aststsforsearch> groupOf(String groupName) {
            return new ArrayList<Aststsforsearch>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * １次検査開始送信フラグ
     */
    public enum Firstexamsendflg implements CDef {
        /** $0: 未送信 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 送信中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 送信済 */
        $2("2", "$2", emptyStrings())
        ,
        /** $8: 送信保留中 */
        $8("8", "$8", emptyStrings())
        ,
        /** $9: 送信対象外 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, Firstexamsendflg> _codeClsMap = new HashMap<String, Firstexamsendflg>();
        private static final Map<String, Firstexamsendflg> _nameClsMap = new HashMap<String, Firstexamsendflg>();
        static {
            for (Firstexamsendflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Firstexamsendflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Firstexamsendflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Firstexamsendflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Firstexamsendflg) { return OptionalThing.of((Firstexamsendflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Firstexamsendflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Firstexamsendflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Firstexamsendflg) { return (Firstexamsendflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Firstexamsendflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Firstexamsendflg> listAll() {
            return new ArrayList<Firstexamsendflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Firstexamsendflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Firstexamsendflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Firstexamsendflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Firstexamsendflg> clsList = new ArrayList<Firstexamsendflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Firstexamsendflg> groupOf(String groupName) {
            return new ArrayList<Firstexamsendflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * MOS送信フラグ
     */
    public enum Mossendflg implements CDef {
        /** $0: 未送信 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ＭＯＳ送信済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Mossendflg> _codeClsMap = new HashMap<String, Mossendflg>();
        private static final Map<String, Mossendflg> _nameClsMap = new HashMap<String, Mossendflg>();
        static {
            for (Mossendflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Mossendflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Mossendflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Mossendflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Mossendflg) { return OptionalThing.of((Mossendflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Mossendflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Mossendflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Mossendflg) { return (Mossendflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Mossendflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Mossendflg> listAll() {
            return new ArrayList<Mossendflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Mossendflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Mossendflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Mossendflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Mossendflg> clsList = new ArrayList<Mossendflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Mossendflg> groupOf(String groupName) {
            return new ArrayList<Mossendflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケース作成区分
     */
    public enum Casecreatetype implements CDef {
        /** $50: インタフェース */
        $50("50", "$50", emptyStrings())
        ,
        /** $51: 受入検品 */
        $51("51", "$51", emptyStrings())
        ,
        /** $52: 検査 */
        $52("52", "$52", emptyStrings())
        ,
        /** $53: 検査取消 */
        $53("53", "$53", emptyStrings())
        ,
        /** $54: 仕分 */
        $54("54", "$54", emptyStrings())
        ,
        /** $55: 仕分結果登録 */
        $55("55", "$55", emptyStrings())
        ,
        /** $56: カートン詰合せ */
        $56("56", "$56", emptyStrings())
        ,
        /** $57: 仕分戻し */
        $57("57", "$57", emptyStrings())
        ,
        /** $58: 棚出取消 */
        $58("58", "$58", emptyStrings())
        ,
        /** $59: 段ボール交換 */
        $59("59", "$59", emptyStrings())
        ,
        /** $60: 画面登録 */
        $60("60", "$60", emptyStrings())
        ,
        /** $61: 簡易出庫 */
        $61("61", "$61", emptyStrings())
        ;
        private static final Map<String, Casecreatetype> _codeClsMap = new HashMap<String, Casecreatetype>();
        private static final Map<String, Casecreatetype> _nameClsMap = new HashMap<String, Casecreatetype>();
        static {
            for (Casecreatetype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Casecreatetype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Casecreatetype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Casecreatetype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Casecreatetype) { return OptionalThing.of((Casecreatetype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Casecreatetype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Casecreatetype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Casecreatetype) { return (Casecreatetype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Casecreatetype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Casecreatetype> listAll() {
            return new ArrayList<Casecreatetype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Casecreatetype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Casecreatetype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Casecreatetype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Casecreatetype> clsList = new ArrayList<Casecreatetype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Casecreatetype> groupOf(String groupName) {
            return new ArrayList<Casecreatetype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * MOS国産送信フラグ
     */
    public enum Mosjtsendflg implements CDef {
        /** $0: 未送信 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ＭＯＳ送信済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Mosjtsendflg> _codeClsMap = new HashMap<String, Mosjtsendflg>();
        private static final Map<String, Mosjtsendflg> _nameClsMap = new HashMap<String, Mosjtsendflg>();
        static {
            for (Mosjtsendflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Mosjtsendflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Mosjtsendflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Mosjtsendflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Mosjtsendflg) { return OptionalThing.of((Mosjtsendflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Mosjtsendflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Mosjtsendflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Mosjtsendflg) { return (Mosjtsendflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Mosjtsendflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Mosjtsendflg> listAll() {
            return new ArrayList<Mosjtsendflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Mosjtsendflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Mosjtsendflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Mosjtsendflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Mosjtsendflg> clsList = new ArrayList<Mosjtsendflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Mosjtsendflg> groupOf(String groupName) {
            return new ArrayList<Mosjtsendflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ＢＡＴ搬入依頼保管場所コード
     */
    public enum Batkeepwarehousecd implements CDef {
        /** $A101: A101 */
        $A101("A101", "$A101", emptyStrings())
        ,
        /** $A201: A201 */
        $A201("A201", "$A201", emptyStrings())
        ;
        private static final Map<String, Batkeepwarehousecd> _codeClsMap = new HashMap<String, Batkeepwarehousecd>();
        private static final Map<String, Batkeepwarehousecd> _nameClsMap = new HashMap<String, Batkeepwarehousecd>();
        static {
            for (Batkeepwarehousecd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Batkeepwarehousecd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Batkeepwarehousecd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Batkeepwarehousecd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Batkeepwarehousecd) { return OptionalThing.of((Batkeepwarehousecd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Batkeepwarehousecd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Batkeepwarehousecd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Batkeepwarehousecd) { return (Batkeepwarehousecd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Batkeepwarehousecd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Batkeepwarehousecd> listAll() {
            return new ArrayList<Batkeepwarehousecd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Batkeepwarehousecd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Batkeepwarehousecd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Batkeepwarehousecd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Batkeepwarehousecd> clsList = new ArrayList<Batkeepwarehousecd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Batkeepwarehousecd> groupOf(String groupName) {
            return new ArrayList<Batkeepwarehousecd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ＢＡＴ搬入依頼拠点コード
     */
    public enum Batwarehousecd implements CDef {
        /** $7010: JP11 */
        $7010("7010", "$7010", emptyStrings())
        ,
        /** $7020: JP12 */
        $7020("7020", "$7020", emptyStrings())
        ;
        private static final Map<String, Batwarehousecd> _codeClsMap = new HashMap<String, Batwarehousecd>();
        private static final Map<String, Batwarehousecd> _nameClsMap = new HashMap<String, Batwarehousecd>();
        static {
            for (Batwarehousecd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Batwarehousecd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Batwarehousecd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Batwarehousecd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Batwarehousecd) { return OptionalThing.of((Batwarehousecd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Batwarehousecd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Batwarehousecd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Batwarehousecd) { return (Batwarehousecd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Batwarehousecd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Batwarehousecd> listAll() {
            return new ArrayList<Batwarehousecd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Batwarehousecd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Batwarehousecd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Batwarehousecd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Batwarehousecd> clsList = new ArrayList<Batwarehousecd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Batwarehousecd> groupOf(String groupName) {
            return new ArrayList<Batwarehousecd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * データ作成フラグ
     */
    public enum Datamakeflg implements CDef {
        /** $0: 未作成 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 作成済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 作成不可 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Datamakeflg> _codeClsMap = new HashMap<String, Datamakeflg>();
        private static final Map<String, Datamakeflg> _nameClsMap = new HashMap<String, Datamakeflg>();
        static {
            for (Datamakeflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Datamakeflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Datamakeflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Datamakeflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Datamakeflg) { return OptionalThing.of((Datamakeflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Datamakeflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Datamakeflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Datamakeflg) { return (Datamakeflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Datamakeflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Datamakeflg> listAll() {
            return new ArrayList<Datamakeflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Datamakeflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Datamakeflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Datamakeflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Datamakeflg> clsList = new ArrayList<Datamakeflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Datamakeflg> groupOf(String groupName) {
            return new ArrayList<Datamakeflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 搬入実績データ数量単位
     */
    public enum Rcvresultqtytype implements CDef {
        /** $MIL: 1000 */
        $MIL("MIL", "$MIL", emptyStrings())
        ;
        private static final Map<String, Rcvresultqtytype> _codeClsMap = new HashMap<String, Rcvresultqtytype>();
        private static final Map<String, Rcvresultqtytype> _nameClsMap = new HashMap<String, Rcvresultqtytype>();
        static {
            for (Rcvresultqtytype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Rcvresultqtytype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Rcvresultqtytype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rcvresultqtytype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Rcvresultqtytype) { return OptionalThing.of((Rcvresultqtytype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rcvresultqtytype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Rcvresultqtytype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Rcvresultqtytype) { return (Rcvresultqtytype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Rcvresultqtytype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Rcvresultqtytype> listAll() {
            return new ArrayList<Rcvresultqtytype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Rcvresultqtytype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Rcvresultqtytype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Rcvresultqtytype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Rcvresultqtytype> clsList = new ArrayList<Rcvresultqtytype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Rcvresultqtytype> groupOf(String groupName) {
            return new ArrayList<Rcvresultqtytype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 品質検査実施フラグ
     */
    public enum Qualityexamflg implements CDef {
        /** $0: 未実施 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 実施済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Qualityexamflg> _codeClsMap = new HashMap<String, Qualityexamflg>();
        private static final Map<String, Qualityexamflg> _nameClsMap = new HashMap<String, Qualityexamflg>();
        static {
            for (Qualityexamflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Qualityexamflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Qualityexamflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Qualityexamflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Qualityexamflg) { return OptionalThing.of((Qualityexamflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Qualityexamflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Qualityexamflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Qualityexamflg) { return (Qualityexamflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Qualityexamflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Qualityexamflg> listAll() {
            return new ArrayList<Qualityexamflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Qualityexamflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Qualityexamflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Qualityexamflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Qualityexamflg> clsList = new ArrayList<Qualityexamflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Qualityexamflg> groupOf(String groupName) {
            return new ArrayList<Qualityexamflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * メーカーケースコード固定項目
     */
    public enum Makercasecodefixedvalue implements CDef {
        /** $BA01: ＢＡＴ固定項目１ */
        $BA01("BA01", "$BA01", emptyStrings())
        ,
        /** $BA02: ＢＡＴ固定項目２ */
        $BA02("BA02", "$BA02", emptyStrings())
        ,
        /** $BA03: ＢＡＴ固定項目３ */
        $BA03("BA03", "$BA03", emptyStrings())
        ;
        private static final Map<String, Makercasecodefixedvalue> _codeClsMap = new HashMap<String, Makercasecodefixedvalue>();
        private static final Map<String, Makercasecodefixedvalue> _nameClsMap = new HashMap<String, Makercasecodefixedvalue>();
        static {
            for (Makercasecodefixedvalue value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Makercasecodefixedvalue(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Makercasecodefixedvalue; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Makercasecodefixedvalue> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Makercasecodefixedvalue) { return OptionalThing.of((Makercasecodefixedvalue)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Makercasecodefixedvalue> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Makercasecodefixedvalue codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Makercasecodefixedvalue) { return (Makercasecodefixedvalue)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Makercasecodefixedvalue nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Makercasecodefixedvalue> listAll() {
            return new ArrayList<Makercasecodefixedvalue>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Makercasecodefixedvalue> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Makercasecodefixedvalue." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Makercasecodefixedvalue> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Makercasecodefixedvalue> clsList = new ArrayList<Makercasecodefixedvalue>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Makercasecodefixedvalue> groupOf(String groupName) {
            return new ArrayList<Makercasecodefixedvalue>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製造記号（国免）
     */
    public enum Productmarkjttaxfree implements CDef {
        /** $QA: QA */
        $QA("QA", "$QA", emptyStrings())
        ,
        /** $QB: QB */
        $QB("QB", "$QB", emptyStrings())
        ,
        /** $QC: QC */
        $QC("QC", "$QC", emptyStrings())
        ,
        /** $QD: QD */
        $QD("QD", "$QD", emptyStrings())
        ,
        /** $QE: QE */
        $QE("QE", "$QE", emptyStrings())
        ,
        /** $QF: QF */
        $QF("QF", "$QF", emptyStrings())
        ,
        /** $QG: QG */
        $QG("QG", "$QG", emptyStrings())
        ,
        /** $QH: QH */
        $QH("QH", "$QH", emptyStrings())
        ,
        /** $QI: QI */
        $QI("QI", "$QI", emptyStrings())
        ,
        /** $QJ: QJ */
        $QJ("QJ", "$QJ", emptyStrings())
        ,
        /** $QK: QK */
        $QK("QK", "$QK", emptyStrings())
        ,
        /** $QL: QL */
        $QL("QL", "$QL", emptyStrings())
        ,
        /** $RA: RA */
        $RA("RA", "$RA", emptyStrings())
        ,
        /** $RB: RB */
        $RB("RB", "$RB", emptyStrings())
        ,
        /** $RC: RC */
        $RC("RC", "$RC", emptyStrings())
        ,
        /** $RD: RD */
        $RD("RD", "$RD", emptyStrings())
        ,
        /** $RE: RE */
        $RE("RE", "$RE", emptyStrings())
        ,
        /** $RF: RF */
        $RF("RF", "$RF", emptyStrings())
        ,
        /** $RG: RG */
        $RG("RG", "$RG", emptyStrings())
        ,
        /** $RH: RH */
        $RH("RH", "$RH", emptyStrings())
        ,
        /** $RI: RI */
        $RI("RI", "$RI", emptyStrings())
        ,
        /** $RJ: RJ */
        $RJ("RJ", "$RJ", emptyStrings())
        ,
        /** $RK: RK */
        $RK("RK", "$RK", emptyStrings())
        ,
        /** $RL: RL */
        $RL("RL", "$RL", emptyStrings())
        ,
        /** $SA: SA */
        $SA("SA", "$SA", emptyStrings())
        ,
        /** $SB: SB */
        $SB("SB", "$SB", emptyStrings())
        ,
        /** $SC: SC */
        $SC("SC", "$SC", emptyStrings())
        ,
        /** $SD: SD */
        $SD("SD", "$SD", emptyStrings())
        ,
        /** $SE: SE */
        $SE("SE", "$SE", emptyStrings())
        ,
        /** $SF: SF */
        $SF("SF", "$SF", emptyStrings())
        ,
        /** $SG: SG */
        $SG("SG", "$SG", emptyStrings())
        ,
        /** $SH: SH */
        $SH("SH", "$SH", emptyStrings())
        ,
        /** $SI: SI */
        $SI("SI", "$SI", emptyStrings())
        ,
        /** $SJ: SJ */
        $SJ("SJ", "$SJ", emptyStrings())
        ,
        /** $SK: SK */
        $SK("SK", "$SK", emptyStrings())
        ,
        /** $SL: SL */
        $SL("SL", "$SL", emptyStrings())
        ,
        /** $TA: TA */
        $TA("TA", "$TA", emptyStrings())
        ,
        /** $TB: TB */
        $TB("TB", "$TB", emptyStrings())
        ,
        /** $TC: TC */
        $TC("TC", "$TC", emptyStrings())
        ,
        /** $TD: TD */
        $TD("TD", "$TD", emptyStrings())
        ,
        /** $TE: TE */
        $TE("TE", "$TE", emptyStrings())
        ,
        /** $TF: TF */
        $TF("TF", "$TF", emptyStrings())
        ,
        /** $TG: TG */
        $TG("TG", "$TG", emptyStrings())
        ,
        /** $TH: TH */
        $TH("TH", "$TH", emptyStrings())
        ,
        /** $TI: TI */
        $TI("TI", "$TI", emptyStrings())
        ,
        /** $TJ: TJ */
        $TJ("TJ", "$TJ", emptyStrings())
        ,
        /** $TK: TK */
        $TK("TK", "$TK", emptyStrings())
        ,
        /** $TL: TL */
        $TL("TL", "$TL", emptyStrings())
        ,
        /** $UA: UA */
        $UA("UA", "$UA", emptyStrings())
        ,
        /** $UB: UB */
        $UB("UB", "$UB", emptyStrings())
        ,
        /** $UC: UC */
        $UC("UC", "$UC", emptyStrings())
        ,
        /** $UD: UD */
        $UD("UD", "$UD", emptyStrings())
        ,
        /** $UE: UE */
        $UE("UE", "$UE", emptyStrings())
        ,
        /** $UF: UF */
        $UF("UF", "$UF", emptyStrings())
        ,
        /** $UG: UG */
        $UG("UG", "$UG", emptyStrings())
        ,
        /** $UH: UH */
        $UH("UH", "$UH", emptyStrings())
        ,
        /** $UI: UI */
        $UI("UI", "$UI", emptyStrings())
        ,
        /** $UJ: UJ */
        $UJ("UJ", "$UJ", emptyStrings())
        ,
        /** $UK: UK */
        $UK("UK", "$UK", emptyStrings())
        ,
        /** $UL: UL */
        $UL("UL", "$UL", emptyStrings())
        ,
        /** $VA: VA */
        $VA("VA", "$VA", emptyStrings())
        ,
        /** $VB: VB */
        $VB("VB", "$VB", emptyStrings())
        ,
        /** $VC: VC */
        $VC("VC", "$VC", emptyStrings())
        ,
        /** $VD: VD */
        $VD("VD", "$VD", emptyStrings())
        ,
        /** $VE: VE */
        $VE("VE", "$VE", emptyStrings())
        ,
        /** $VF: VF */
        $VF("VF", "$VF", emptyStrings())
        ,
        /** $VG: VG */
        $VG("VG", "$VG", emptyStrings())
        ,
        /** $VH: VH */
        $VH("VH", "$VH", emptyStrings())
        ,
        /** $VI: VI */
        $VI("VI", "$VI", emptyStrings())
        ,
        /** $VJ: VJ */
        $VJ("VJ", "$VJ", emptyStrings())
        ,
        /** $VK: VK */
        $VK("VK", "$VK", emptyStrings())
        ,
        /** $VL: VL */
        $VL("VL", "$VL", emptyStrings())
        ,
        /** $WA: WA */
        $WA("WA", "$WA", emptyStrings())
        ,
        /** $WB: WB */
        $WB("WB", "$WB", emptyStrings())
        ,
        /** $WC: WC */
        $WC("WC", "$WC", emptyStrings())
        ,
        /** $WD: WD */
        $WD("WD", "$WD", emptyStrings())
        ,
        /** $WE: WE */
        $WE("WE", "$WE", emptyStrings())
        ,
        /** $WF: WF */
        $WF("WF", "$WF", emptyStrings())
        ,
        /** $WG: WG */
        $WG("WG", "$WG", emptyStrings())
        ,
        /** $WH: WH */
        $WH("WH", "$WH", emptyStrings())
        ,
        /** $WI: WI */
        $WI("WI", "$WI", emptyStrings())
        ,
        /** $WJ: WJ */
        $WJ("WJ", "$WJ", emptyStrings())
        ,
        /** $WK: WK */
        $WK("WK", "$WK", emptyStrings())
        ,
        /** $WL: WL */
        $WL("WL", "$WL", emptyStrings())
        ,
        /** $XA: XA */
        $XA("XA", "$XA", emptyStrings())
        ,
        /** $XB: XB */
        $XB("XB", "$XB", emptyStrings())
        ,
        /** $XC: XC */
        $XC("XC", "$XC", emptyStrings())
        ,
        /** $XD: XD */
        $XD("XD", "$XD", emptyStrings())
        ,
        /** $XE: XE */
        $XE("XE", "$XE", emptyStrings())
        ,
        /** $XF: XF */
        $XF("XF", "$XF", emptyStrings())
        ,
        /** $XG: XG */
        $XG("XG", "$XG", emptyStrings())
        ,
        /** $XH: XH */
        $XH("XH", "$XH", emptyStrings())
        ,
        /** $XI: XI */
        $XI("XI", "$XI", emptyStrings())
        ,
        /** $XJ: XJ */
        $XJ("XJ", "$XJ", emptyStrings())
        ,
        /** $XK: XK */
        $XK("XK", "$XK", emptyStrings())
        ,
        /** $XL: XL */
        $XL("XL", "$XL", emptyStrings())
        ,
        /** $YA: YA */
        $YA("YA", "$YA", emptyStrings())
        ,
        /** $YB: YB */
        $YB("YB", "$YB", emptyStrings())
        ,
        /** $YC: YC */
        $YC("YC", "$YC", emptyStrings())
        ,
        /** $YD: YD */
        $YD("YD", "$YD", emptyStrings())
        ,
        /** $YE: YE */
        $YE("YE", "$YE", emptyStrings())
        ,
        /** $YF: YF */
        $YF("YF", "$YF", emptyStrings())
        ,
        /** $YG: YG */
        $YG("YG", "$YG", emptyStrings())
        ,
        /** $YH: YH */
        $YH("YH", "$YH", emptyStrings())
        ,
        /** $YI: YI */
        $YI("YI", "$YI", emptyStrings())
        ,
        /** $YJ: YJ */
        $YJ("YJ", "$YJ", emptyStrings())
        ,
        /** $YK: YK */
        $YK("YK", "$YK", emptyStrings())
        ,
        /** $YL: YL */
        $YL("YL", "$YL", emptyStrings())
        ,
        /** $ZA: ZA */
        $ZA("ZA", "$ZA", emptyStrings())
        ,
        /** $ZB: ZB */
        $ZB("ZB", "$ZB", emptyStrings())
        ,
        /** $ZC: ZC */
        $ZC("ZC", "$ZC", emptyStrings())
        ,
        /** $ZD: ZD */
        $ZD("ZD", "$ZD", emptyStrings())
        ,
        /** $ZE: ZE */
        $ZE("ZE", "$ZE", emptyStrings())
        ,
        /** $ZF: ZF */
        $ZF("ZF", "$ZF", emptyStrings())
        ,
        /** $ZG: ZG */
        $ZG("ZG", "$ZG", emptyStrings())
        ,
        /** $ZH: ZH */
        $ZH("ZH", "$ZH", emptyStrings())
        ,
        /** $ZI: ZI */
        $ZI("ZI", "$ZI", emptyStrings())
        ,
        /** $ZJ: ZJ */
        $ZJ("ZJ", "$ZJ", emptyStrings())
        ,
        /** $ZK: ZK */
        $ZK("ZK", "$ZK", emptyStrings())
        ,
        /** $ZL: ZL */
        $ZL("ZL", "$ZL", emptyStrings())
        ;
        private static final Map<String, Productmarkjttaxfree> _codeClsMap = new HashMap<String, Productmarkjttaxfree>();
        private static final Map<String, Productmarkjttaxfree> _nameClsMap = new HashMap<String, Productmarkjttaxfree>();
        static {
            for (Productmarkjttaxfree value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Productmarkjttaxfree(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Productmarkjttaxfree; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productmarkjttaxfree> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Productmarkjttaxfree) { return OptionalThing.of((Productmarkjttaxfree)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Productmarkjttaxfree> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Productmarkjttaxfree codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Productmarkjttaxfree) { return (Productmarkjttaxfree)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Productmarkjttaxfree nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Productmarkjttaxfree> listAll() {
            return new ArrayList<Productmarkjttaxfree>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Productmarkjttaxfree> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Productmarkjttaxfree." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Productmarkjttaxfree> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Productmarkjttaxfree> clsList = new ArrayList<Productmarkjttaxfree>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Productmarkjttaxfree> groupOf(String groupName) {
            return new ArrayList<Productmarkjttaxfree>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当不能リスト（記入用）帳票出力定義
     */
    public enum PrinterdefS011 implements CDef {
        /** $8351: 引当不能リスト（記入用）帳票出力定義（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 引当不能リスト（記入用）帳票出力定義（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 引当不能リスト（記入用）帳票出力定義（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 引当不能リスト（記入用）帳票出力定義（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 引当不能リスト（記入用）帳票出力定義（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 引当不能リスト（記入用）帳票出力定義（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 引当不能リスト（記入用）帳票出力定義（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 引当不能リスト（記入用）帳票出力定義（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 引当不能リスト（記入用）帳票出力定義（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 引当不能リスト（記入用）帳票出力定義（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 引当不能リスト（記入用）帳票出力定義（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 引当不能リスト（記入用）帳票出力定義（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 引当不能リスト（記入用）帳票出力定義（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 引当不能リスト（記入用）帳票出力定義（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 引当不能リスト（記入用）帳票出力定義（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 引当不能リスト（記入用）帳票出力定義（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 引当不能リスト（記入用）帳票出力定義（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 引当不能リスト（記入用）帳票出力定義（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 引当不能リスト（記入用）帳票出力定義（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 引当不能リスト（記入用）帳票出力定義（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 引当不能リスト（記入用）帳票出力定義（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 引当不能リスト（記入用）帳票出力定義（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 引当不能リスト（記入用）帳票出力定義（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 引当不能リスト（記入用）帳票出力定義（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 引当不能リスト（記入用）帳票出力定義（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 引当不能リスト（記入用）帳票出力定義（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 引当不能リスト（記入用）帳票出力定義（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 引当不能リスト（記入用）帳票出力定義（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 引当不能リスト（記入用）帳票出力定義（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 引当不能リスト（記入用）帳票出力定義（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 引当不能リスト（記入用）帳票出力定義（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 引当不能リスト（記入用）帳票出力定義（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 引当不能リスト（記入用）帳票出力定義（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 引当不能リスト（記入用）帳票出力定義（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefS011> _codeClsMap = new HashMap<String, PrinterdefS011>();
        private static final Map<String, PrinterdefS011> _nameClsMap = new HashMap<String, PrinterdefS011>();
        static {
            for (PrinterdefS011 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefS011(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefS011; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS011> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefS011) { return OptionalThing.of((PrinterdefS011)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS011> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS011 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefS011) { return (PrinterdefS011)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS011 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefS011> listAll() {
            return new ArrayList<PrinterdefS011>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefS011> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefS011." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefS011> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefS011> clsList = new ArrayList<PrinterdefS011>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefS011> groupOf(String groupName) {
            return new ArrayList<PrinterdefS011>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当不能リスト（実績用）帳票出力定義
     */
    public enum PrinterdefS012 implements CDef {
        /** $8351: 引当不能リスト（実績用）帳票出力定義（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 引当不能リスト（実績用）帳票出力定義（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 引当不能リスト（実績用）帳票出力定義（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 引当不能リスト（実績用）帳票出力定義（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 引当不能リスト（実績用）帳票出力定義（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 引当不能リスト（実績用）帳票出力定義（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 引当不能リスト（実績用）帳票出力定義（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 引当不能リスト（実績用）帳票出力定義（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 引当不能リスト（実績用）帳票出力定義（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 引当不能リスト（実績用）帳票出力定義（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 引当不能リスト（実績用）帳票出力定義（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 引当不能リスト（実績用）帳票出力定義（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 引当不能リスト（実績用）帳票出力定義（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 引当不能リスト（実績用）帳票出力定義（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 引当不能リスト（実績用）帳票出力定義（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 引当不能リスト（実績用）帳票出力定義（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 引当不能リスト（実績用）帳票出力定義（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 引当不能リスト（実績用）帳票出力定義（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 引当不能リスト（実績用）帳票出力定義（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 引当不能リスト（実績用）帳票出力定義（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 引当不能リスト（実績用）帳票出力定義（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 引当不能リスト（実績用）帳票出力定義（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 引当不能リスト（実績用）帳票出力定義（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 引当不能リスト（実績用）帳票出力定義（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 引当不能リスト（実績用）帳票出力定義（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 引当不能リスト（実績用）帳票出力定義（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 引当不能リスト（実績用）帳票出力定義（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 引当不能リスト（実績用）帳票出力定義（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 引当不能リスト（実績用）帳票出力定義（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 引当不能リスト（実績用）帳票出力定義（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 引当不能リスト（実績用）帳票出力定義（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 引当不能リスト（実績用）帳票出力定義（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 引当不能リスト（実績用）帳票出力定義（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 引当不能リスト（実績用）帳票出力定義（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefS012> _codeClsMap = new HashMap<String, PrinterdefS012>();
        private static final Map<String, PrinterdefS012> _nameClsMap = new HashMap<String, PrinterdefS012>();
        static {
            for (PrinterdefS012 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefS012(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefS012; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS012> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefS012) { return OptionalThing.of((PrinterdefS012)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS012> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS012 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefS012) { return (PrinterdefS012)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS012 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefS012> listAll() {
            return new ArrayList<PrinterdefS012>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefS012> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefS012." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefS012> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefS012> clsList = new ArrayList<PrinterdefS012>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefS012> groupOf(String groupName) {
            return new ArrayList<PrinterdefS012>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * パレットはり紙帳票出力定義（ＨＴ）
     */
    public enum PrinterdefN002 implements CDef {
        /** $8351: 受入検品パレットはり紙帳票出力定義（ＨＴ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 受入検品パレットはり紙帳票出力定義（ＨＴ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 受入検品パレットはり紙帳票出力定義（ＨＴ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 受入検品パレットはり紙帳票出力定義（ＨＴ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 受入検品パレットはり紙帳票出力定義（ＨＴ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 受入検品パレットはり紙帳票出力定義（ＨＴ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 受入検品パレットはり紙帳票出力定義（ＨＴ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 受入検品パレットはり紙帳票出力定義（ＨＴ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 受入検品パレットはり紙帳票出力定義（ＨＴ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 受入検品パレットはり紙帳票出力定義（ＨＴ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 受入検品パレットはり紙帳票出力定義（ＨＴ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 受入検品パレットはり紙帳票出力定義（ＨＴ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 受入検品パレットはり紙帳票出力定義（ＨＴ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 受入検品パレットはり紙帳票出力定義（ＨＴ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 受入検品パレットはり紙帳票出力定義（ＨＴ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 受入検品パレットはり紙帳票出力定義（ＨＴ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 受入検品パレットはり紙帳票出力定義（ＨＴ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 受入検品パレットはり紙帳票出力定義（ＨＴ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 受入検品パレットはり紙帳票出力定義（ＨＴ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 受入検品パレットはり紙帳票出力定義（ＨＴ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 受入検品パレットはり紙帳票出力定義（ＨＴ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 受入検品パレットはり紙帳票出力定義（ＨＴ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 受入検品パレットはり紙帳票出力定義（ＨＴ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 受入検品パレットはり紙帳票出力定義（ＨＴ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 受入検品パレットはり紙帳票出力定義（ＨＴ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 受入検品パレットはり紙帳票出力定義（ＨＴ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 受入検品パレットはり紙帳票出力定義（ＨＴ）（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 受入検品パレットはり紙帳票出力定義（ＨＴ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 受入検品パレットはり紙帳票出力定義（ＨＴ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 受入検品パレットはり紙帳票出力定義（ＨＴ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 受入検品パレットはり紙帳票出力定義（ＨＴ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 受入検品パレットはり紙帳票出力定義（ＨＴ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 受入検品パレットはり紙帳票出力定義（ＨＴ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 受入検品パレットはり紙帳票出力定義（ＨＴ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefN002> _codeClsMap = new HashMap<String, PrinterdefN002>();
        private static final Map<String, PrinterdefN002> _nameClsMap = new HashMap<String, PrinterdefN002>();
        static {
            for (PrinterdefN002 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefN002(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefN002; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefN002> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefN002) { return OptionalThing.of((PrinterdefN002)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefN002> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefN002 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefN002) { return (PrinterdefN002)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefN002 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefN002> listAll() {
            return new ArrayList<PrinterdefN002>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefN002> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefN002." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefN002> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefN002> clsList = new ArrayList<PrinterdefN002>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefN002> groupOf(String groupName) {
            return new ArrayList<PrinterdefN002>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 分割はい替パレットはり紙帳票出力定義（ＨＴ）
     */
    public enum PrinterdefZ005 implements CDef {
        /** $8351: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 分割はい替パレットはり紙帳票出力定義（ＨＴ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefZ005> _codeClsMap = new HashMap<String, PrinterdefZ005>();
        private static final Map<String, PrinterdefZ005> _nameClsMap = new HashMap<String, PrinterdefZ005>();
        static {
            for (PrinterdefZ005 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefZ005(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefZ005; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefZ005> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefZ005) { return OptionalThing.of((PrinterdefZ005)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefZ005> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefZ005 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefZ005) { return (PrinterdefZ005)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefZ005 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefZ005> listAll() {
            return new ArrayList<PrinterdefZ005>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefZ005> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefZ005." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefZ005> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefZ005> clsList = new ArrayList<PrinterdefZ005>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefZ005> groupOf(String groupName) {
            return new ArrayList<PrinterdefZ005>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕分補充区分
     */
    public enum Sortstockkbn implements CDef {
        /** $1: うしろ補充 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: まえ補充 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 取出 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Sortstockkbn> _codeClsMap = new HashMap<String, Sortstockkbn>();
        private static final Map<String, Sortstockkbn> _nameClsMap = new HashMap<String, Sortstockkbn>();
        static {
            for (Sortstockkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Sortstockkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Sortstockkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortstockkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Sortstockkbn) { return OptionalThing.of((Sortstockkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortstockkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Sortstockkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Sortstockkbn) { return (Sortstockkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Sortstockkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Sortstockkbn> listAll() {
            return new ArrayList<Sortstockkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Sortstockkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Sortstockkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Sortstockkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Sortstockkbn> clsList = new ArrayList<Sortstockkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Sortstockkbn> groupOf(String groupName) {
            return new ArrayList<Sortstockkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 追跡区分詳細
     */
    public enum Tracetypedt implements CDef {
        /** $0100: 基本数量 */
        $0100("0100", "$0100", emptyStrings())
        ,
        /** $0200: 保管場 */
        $0200("0200", "$0200", emptyStrings())
        ,
        /** $0300: 保管場（分割はい替） */
        $0300("0300", "$0300", emptyStrings())
        ,
        /** $04YY: 仕分場 */
        $04YY("04YY", "$04YY", emptyStrings())
        ,
        /** $0500: 引取場 */
        $0500("0500", "$0500", emptyStrings())
        ,
        /** $06YY: 山出し */
        $06YY("06YY", "$06YY", emptyStrings())
        ,
        /** $07YY: 山出し（カートン） */
        $07YY("07YY", "$07YY", emptyStrings())
        ,
        /** $0800: 画面修正 */
        $0800("0800", "$0800", emptyStrings())
        ,
        /** $0900: 補充 */
        $0900("0900", "$0900", emptyStrings())
        ,
        /** $1000: 取出 */
        $1000("1000", "$1000", emptyStrings())
        ,
        /** $1100: 仕分済 */
        $1100("1100", "$1100", emptyStrings())
        ,
        /** $1200: 仕分済（ケース単位出荷） */
        $1200("1200", "$1200", emptyStrings())
        ,
        /** $1300: 出荷済 */
        $1300("1300", "$1300", emptyStrings())
        ,
        /** $1400: 引取場出荷 */
        $1400("1400", "$1400", emptyStrings())
        ,
        /** $1500: 引取場解除 */
        $1500("1500", "$1500", emptyStrings())
        ,
        /** $1600: 製品移動（融通） */
        $1600("1600", "$1600", emptyStrings())
        ,
        /** $1700: 製品移動（その他） */
        $1700("1700", "$1700", emptyStrings())
        ,
        /** $1800: 前補充分割 */
        $1800("1800", "$1800", emptyStrings())
        ,
        /** $1900: 追跡不能 */
        $1900("1900", "$1900", emptyStrings())
        ,
        /** $2000: 製品移動（仕分場） */
        $2000("2000", "$2000", emptyStrings())
        ,
        /** $2100: 製品移動（引取場） */
        $2100("2100", "$2100", emptyStrings())
        ,
        /** $2200: 在庫調査補正 */
        $2200("2200", "$2200", emptyStrings())
        ,
        /** $2300: 仕分済（即時） */
        $2300("2300", "$2300", emptyStrings())
        ,
        /** $2400: 仕分場出荷 */
        $2400("2400", "$2400", emptyStrings())
        ,
        /** $2500: 製品移動（仕分場）出荷 */
        $2500("2500", "$2500", emptyStrings())
        ,
        /** $2600: 製品移動（引取場）出荷 */
        $2600("2600", "$2600", emptyStrings())
        ,
        /** $2700: 製品移動（融通）出荷 */
        $2700("2700", "$2700", emptyStrings())
        ,
        /** $2800: 製品移動（その他）出荷 */
        $2800("2800", "$2800", emptyStrings())
        ,
        /** $2900: 取出（引取場補充） */
        $2900("2900", "$2900", emptyStrings())
        ;
        private static final Map<String, Tracetypedt> _codeClsMap = new HashMap<String, Tracetypedt>();
        private static final Map<String, Tracetypedt> _nameClsMap = new HashMap<String, Tracetypedt>();
        static {
            for (Tracetypedt value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Tracetypedt(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Tracetypedt; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tracetypedt> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Tracetypedt) { return OptionalThing.of((Tracetypedt)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tracetypedt> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Tracetypedt codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Tracetypedt) { return (Tracetypedt)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Tracetypedt nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Tracetypedt> listAll() {
            return new ArrayList<Tracetypedt>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Tracetypedt> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Tracetypedt." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Tracetypedt> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Tracetypedt> clsList = new ArrayList<Tracetypedt>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Tracetypedt> groupOf(String groupName) {
            return new ArrayList<Tracetypedt>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ラック間製品移動確認リスト印刷区分
     */
    public enum Racklabelprflg implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Racklabelprflg> _codeClsMap = new HashMap<String, Racklabelprflg>();
        private static final Map<String, Racklabelprflg> _nameClsMap = new HashMap<String, Racklabelprflg>();
        static {
            for (Racklabelprflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Racklabelprflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Racklabelprflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Racklabelprflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Racklabelprflg) { return OptionalThing.of((Racklabelprflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Racklabelprflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Racklabelprflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Racklabelprflg) { return (Racklabelprflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Racklabelprflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Racklabelprflg> listAll() {
            return new ArrayList<Racklabelprflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Racklabelprflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Racklabelprflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Racklabelprflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Racklabelprflg> clsList = new ArrayList<Racklabelprflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Racklabelprflg> groupOf(String groupName) {
            return new ArrayList<Racklabelprflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）
     */
    public enum PrinterdefS0031 implements CDef {
        /** $8351: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefS0031> _codeClsMap = new HashMap<String, PrinterdefS0031>();
        private static final Map<String, PrinterdefS0031> _nameClsMap = new HashMap<String, PrinterdefS0031>();
        static {
            for (PrinterdefS0031 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefS0031(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefS0031; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS0031> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefS0031) { return OptionalThing.of((PrinterdefS0031)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS0031> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS0031 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefS0031) { return (PrinterdefS0031)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS0031 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefS0031> listAll() {
            return new ArrayList<PrinterdefS0031>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefS0031> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefS0031." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefS0031> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefS0031> clsList = new ArrayList<PrinterdefS0031>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefS0031> groupOf(String groupName) {
            return new ArrayList<PrinterdefS0031>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）
     */
    public enum PrinterdefS0032 implements CDef {
        /** $8351: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefS0032> _codeClsMap = new HashMap<String, PrinterdefS0032>();
        private static final Map<String, PrinterdefS0032> _nameClsMap = new HashMap<String, PrinterdefS0032>();
        static {
            for (PrinterdefS0032 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefS0032(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefS0032; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS0032> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefS0032) { return OptionalThing.of((PrinterdefS0032)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS0032> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS0032 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefS0032) { return (PrinterdefS0032)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS0032 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefS0032> listAll() {
            return new ArrayList<PrinterdefS0032>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefS0032> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefS0032." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefS0032> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefS0032> clsList = new ArrayList<PrinterdefS0032>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefS0032> groupOf(String groupName) {
            return new ArrayList<PrinterdefS0032>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）
     */
    public enum PrinterdefS0033 implements CDef {
        /** $8351: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefS0033> _codeClsMap = new HashMap<String, PrinterdefS0033>();
        private static final Map<String, PrinterdefS0033> _nameClsMap = new HashMap<String, PrinterdefS0033>();
        static {
            for (PrinterdefS0033 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefS0033(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefS0033; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS0033> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefS0033) { return OptionalThing.of((PrinterdefS0033)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS0033> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS0033 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefS0033) { return (PrinterdefS0033)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS0033 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefS0033> listAll() {
            return new ArrayList<PrinterdefS0033>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefS0033> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefS0033." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefS0033> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefS0033> clsList = new ArrayList<PrinterdefS0033>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefS0033> groupOf(String groupName) {
            return new ArrayList<PrinterdefS0033>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）
     */
    public enum PrinterdefS0034 implements CDef {
        /** $8351: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefS0034> _codeClsMap = new HashMap<String, PrinterdefS0034>();
        private static final Map<String, PrinterdefS0034> _nameClsMap = new HashMap<String, PrinterdefS0034>();
        static {
            for (PrinterdefS0034 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefS0034(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefS0034; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS0034> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefS0034) { return OptionalThing.of((PrinterdefS0034)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefS0034> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS0034 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefS0034) { return (PrinterdefS0034)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefS0034 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefS0034> listAll() {
            return new ArrayList<PrinterdefS0034>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefS0034> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefS0034." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefS0034> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefS0034> clsList = new ArrayList<PrinterdefS0034>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefS0034> groupOf(String groupName) {
            return new ArrayList<PrinterdefS0034>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 不明ケース判定
     */
    public enum Unknowncaselimit implements CDef {
        /** $MONTH: 不明ケース判定期間（月） */
        $MONTH("MONTH", "$MONTH", emptyStrings())
        ;
        private static final Map<String, Unknowncaselimit> _codeClsMap = new HashMap<String, Unknowncaselimit>();
        private static final Map<String, Unknowncaselimit> _nameClsMap = new HashMap<String, Unknowncaselimit>();
        static {
            for (Unknowncaselimit value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Unknowncaselimit(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Unknowncaselimit; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Unknowncaselimit> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Unknowncaselimit) { return OptionalThing.of((Unknowncaselimit)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Unknowncaselimit> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Unknowncaselimit codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Unknowncaselimit) { return (Unknowncaselimit)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Unknowncaselimit nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Unknowncaselimit> listAll() {
            return new ArrayList<Unknowncaselimit>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Unknowncaselimit> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Unknowncaselimit." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Unknowncaselimit> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Unknowncaselimit> clsList = new ArrayList<Unknowncaselimit>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Unknowncaselimit> groupOf(String groupName) {
            return new ArrayList<Unknowncaselimit>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕分場在庫区分
     */
    public enum Sortinvkbn implements CDef {
        /** $0: ラック内 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 仕分済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Sortinvkbn> _codeClsMap = new HashMap<String, Sortinvkbn>();
        private static final Map<String, Sortinvkbn> _nameClsMap = new HashMap<String, Sortinvkbn>();
        static {
            for (Sortinvkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Sortinvkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Sortinvkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortinvkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Sortinvkbn) { return OptionalThing.of((Sortinvkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortinvkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Sortinvkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Sortinvkbn) { return (Sortinvkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Sortinvkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Sortinvkbn> listAll() {
            return new ArrayList<Sortinvkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Sortinvkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Sortinvkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Sortinvkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Sortinvkbn> clsList = new ArrayList<Sortinvkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Sortinvkbn> groupOf(String groupName) {
            return new ArrayList<Sortinvkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 前後ケース数
     */
    public enum Cloudcasenum implements CDef {
        /** $01: 1ケース */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 2ケース */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 3ケース */
        $03("03", "$03", emptyStrings())
        ;
        private static final Map<String, Cloudcasenum> _codeClsMap = new HashMap<String, Cloudcasenum>();
        private static final Map<String, Cloudcasenum> _nameClsMap = new HashMap<String, Cloudcasenum>();
        static {
            for (Cloudcasenum value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Cloudcasenum(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Cloudcasenum; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cloudcasenum> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Cloudcasenum) { return OptionalThing.of((Cloudcasenum)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cloudcasenum> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Cloudcasenum codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Cloudcasenum) { return (Cloudcasenum)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Cloudcasenum nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Cloudcasenum> listAll() {
            return new ArrayList<Cloudcasenum>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Cloudcasenum> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Cloudcasenum." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Cloudcasenum> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Cloudcasenum> clsList = new ArrayList<Cloudcasenum>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Cloudcasenum> groupOf(String groupName) {
            return new ArrayList<Cloudcasenum>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷区分
     */
    public enum Pulltype implements CDef {
        /** $0: 補充済 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷対象外 */
        $1("1", "$1", emptyStrings())
        ,
        /** $3: 出荷処理中 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 仮補充 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 出荷済 */
        $5("5", "$5", emptyStrings())
        ,
        /** $9: 取出済 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, Pulltype> _codeClsMap = new HashMap<String, Pulltype>();
        private static final Map<String, Pulltype> _nameClsMap = new HashMap<String, Pulltype>();
        static {
            for (Pulltype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Pulltype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Pulltype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pulltype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Pulltype) { return OptionalThing.of((Pulltype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pulltype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Pulltype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Pulltype) { return (Pulltype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Pulltype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Pulltype> listAll() {
            return new ArrayList<Pulltype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Pulltype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Pulltype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Pulltype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Pulltype> clsList = new ArrayList<Pulltype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Pulltype> groupOf(String groupName) {
            return new ArrayList<Pulltype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保管場所
     */
    public enum Storageloc implements CDef {
        /** $00: 保管場 */
        $00("00", "$00", emptyStrings())
        ,
        /** $10: 山出し */
        $10("10", "$10", emptyStrings())
        ,
        /** $20: 仕分場 */
        $20("20", "$20", emptyStrings())
        ,
        /** $21: 山出し（製品移動） */
        $21("21", "$21", emptyStrings())
        ,
        /** $25: 取出済（仕分場） */
        $25("25", "$25", emptyStrings())
        ,
        /** $30: 引取場 */
        $30("30", "$30", emptyStrings())
        ,
        /** $35: 取出済（引取場） */
        $35("35", "$35", emptyStrings())
        ;
        private static final Map<String, Storageloc> _codeClsMap = new HashMap<String, Storageloc>();
        private static final Map<String, Storageloc> _nameClsMap = new HashMap<String, Storageloc>();
        static {
            for (Storageloc value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Storageloc(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Storageloc; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Storageloc> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Storageloc) { return OptionalThing.of((Storageloc)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Storageloc> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Storageloc codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Storageloc) { return (Storageloc)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Storageloc nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Storageloc> listAll() {
            return new ArrayList<Storageloc>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Storageloc> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Storageloc." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Storageloc> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Storageloc> clsList = new ArrayList<Storageloc>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Storageloc> groupOf(String groupName) {
            return new ArrayList<Storageloc>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * パレット追跡区分
     */
    public enum Pallettracetype implements CDef {
        /** $X000: 保管場 */
        $X000("X000", "$X000", emptyStrings())
        ,
        /** $X100: 保管場格納 */
        $X100("X100", "$X100", emptyStrings())
        ,
        /** $X2YY: 山出し（ケース） */
        $X2YY("X2YY", "$X2YY", emptyStrings())
        ,
        /** $X3YY: 山出し（カートン） */
        $X3YY("X3YY", "$X3YY", emptyStrings())
        ,
        /** $X4YY: 山出し（混在） */
        $X4YY("X4YY", "$X4YY", emptyStrings())
        ,
        /** $X5YY: 製品移動（ケース） */
        $X5YY("X5YY", "$X5YY", emptyStrings())
        ,
        /** $X6YY: 製品移動（カートン） */
        $X6YY("X6YY", "$X6YY", emptyStrings())
        ,
        /** $X7YY: 製品移動（混在） */
        $X7YY("X7YY", "$X7YY", emptyStrings())
        ,
        /** $X800: 分割はい替 */
        $X800("X800", "$X800", emptyStrings())
        ;
        private static final Map<String, Pallettracetype> _codeClsMap = new HashMap<String, Pallettracetype>();
        private static final Map<String, Pallettracetype> _nameClsMap = new HashMap<String, Pallettracetype>();
        static {
            for (Pallettracetype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Pallettracetype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Pallettracetype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pallettracetype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Pallettracetype) { return OptionalThing.of((Pallettracetype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pallettracetype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Pallettracetype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Pallettracetype) { return (Pallettracetype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Pallettracetype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Pallettracetype> listAll() {
            return new ArrayList<Pallettracetype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Pallettracetype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Pallettracetype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Pallettracetype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Pallettracetype> clsList = new ArrayList<Pallettracetype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Pallettracetype> groupOf(String groupName) {
            return new ArrayList<Pallettracetype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送信管理区分
     */
    public enum Datasendtype implements CDef {
        /** $0: 未送信 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 送信対象 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 送信済 */
        $2("2", "$2", emptyStrings())
        ,
        /** $9: 送信対象外 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, Datasendtype> _codeClsMap = new HashMap<String, Datasendtype>();
        private static final Map<String, Datasendtype> _nameClsMap = new HashMap<String, Datasendtype>();
        static {
            for (Datasendtype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Datasendtype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Datasendtype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Datasendtype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Datasendtype) { return OptionalThing.of((Datasendtype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Datasendtype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Datasendtype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Datasendtype) { return (Datasendtype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Datasendtype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Datasendtype> listAll() {
            return new ArrayList<Datasendtype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Datasendtype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Datasendtype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Datasendtype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Datasendtype> clsList = new ArrayList<Datasendtype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Datasendtype> groupOf(String groupName) {
            return new ArrayList<Datasendtype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 追跡情報作成状態
     */
    public enum Tracecreatests implements CDef {
        /** $0: 作成対象（分類前） */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 作成対象（倉庫内） */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 作成対象（仕分済） */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 作成対象（出荷済） */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 作成対象（融通済） */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 作成対象（その他） */
        $5("5", "$5", emptyStrings())
        ,
        /** $8: 対象外 */
        $8("8", "$8", emptyStrings())
        ,
        /** $9: 作成済 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, Tracecreatests> _codeClsMap = new HashMap<String, Tracecreatests>();
        private static final Map<String, Tracecreatests> _nameClsMap = new HashMap<String, Tracecreatests>();
        static {
            for (Tracecreatests value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Tracecreatests(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Tracecreatests; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tracecreatests> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Tracecreatests) { return OptionalThing.of((Tracecreatests)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tracecreatests> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Tracecreatests codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Tracecreatests) { return (Tracecreatests)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Tracecreatests nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Tracecreatests> listAll() {
            return new ArrayList<Tracecreatests>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Tracecreatests> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Tracecreatests." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Tracecreatests> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Tracecreatests> clsList = new ArrayList<Tracecreatests>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Tracecreatests> groupOf(String groupName) {
            return new ArrayList<Tracecreatests>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸契機
     */
    public enum Sortinvtiming implements CDef {
        /** $1: 開始 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 中間 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 終了 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Sortinvtiming> _codeClsMap = new HashMap<String, Sortinvtiming>();
        private static final Map<String, Sortinvtiming> _nameClsMap = new HashMap<String, Sortinvtiming>();
        static {
            for (Sortinvtiming value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Sortinvtiming(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Sortinvtiming; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortinvtiming> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Sortinvtiming) { return OptionalThing.of((Sortinvtiming)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortinvtiming> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Sortinvtiming codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Sortinvtiming) { return (Sortinvtiming)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Sortinvtiming nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Sortinvtiming> listAll() {
            return new ArrayList<Sortinvtiming>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Sortinvtiming> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Sortinvtiming." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Sortinvtiming> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Sortinvtiming> clsList = new ArrayList<Sortinvtiming>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Sortinvtiming> groupOf(String groupName) {
            return new ArrayList<Sortinvtiming>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケース補充先
     */
    public enum Casesupplytype implements CDef {
        /** $L1: L1 */
        $L1("L1", "$L1", emptyStrings())
        ,
        /** $L2: L2 */
        $L2("L2", "$L2", emptyStrings())
        ,
        /** $L3: L3 */
        $L3("L3", "$L3", emptyStrings())
        ,
        /** $L4: L4 */
        $L4("L4", "$L4", emptyStrings())
        ,
        /** $L5: L5 */
        $L5("L5", "$L5", emptyStrings())
        ,
        /** $L6: L6 */
        $L6("L6", "$L6", emptyStrings())
        ,
        /** $L7: L7 */
        $L7("L7", "$L7", emptyStrings())
        ,
        /** $L8: L8 */
        $L8("L8", "$L8", emptyStrings())
        ,
        /** $L9: L9 */
        $L9("L9", "$L9", emptyStrings())
        ,
        /** $B1: B1 */
        $B1("B1", "$B1", emptyStrings())
        ,
        /** $B2: B2 */
        $B2("B2", "$B2", emptyStrings())
        ,
        /** $B3: B3 */
        $B3("B3", "$B3", emptyStrings())
        ,
        /** $B4: B4 */
        $B4("B4", "$B4", emptyStrings())
        ,
        /** $B5: B5 */
        $B5("B5", "$B5", emptyStrings())
        ,
        /** $B6: B6 */
        $B6("B6", "$B6", emptyStrings())
        ,
        /** $B7: B7 */
        $B7("B7", "$B7", emptyStrings())
        ,
        /** $B8: B8 */
        $B8("B8", "$B8", emptyStrings())
        ,
        /** $B9: B9 */
        $B9("B9", "$B9", emptyStrings())
        ,
        /** $9903: 引取場 */
        $9903("9903", "$9903", emptyStrings())
        ;
        private static final Map<String, Casesupplytype> _codeClsMap = new HashMap<String, Casesupplytype>();
        private static final Map<String, Casesupplytype> _nameClsMap = new HashMap<String, Casesupplytype>();
        static {
            for (Casesupplytype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Casesupplytype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Casesupplytype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Casesupplytype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Casesupplytype) { return OptionalThing.of((Casesupplytype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Casesupplytype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Casesupplytype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Casesupplytype) { return (Casesupplytype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Casesupplytype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Casesupplytype> listAll() {
            return new ArrayList<Casesupplytype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Casesupplytype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Casesupplytype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Casesupplytype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Casesupplytype> clsList = new ArrayList<Casesupplytype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Casesupplytype> groupOf(String groupName) {
            return new ArrayList<Casesupplytype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 輸入在庫調査有無
     */
    public enum Importumu implements CDef {
        /** $8351: 輸入在庫調査有無（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 輸入在庫調査有無（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 輸入在庫調査有無（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 輸入在庫調査有無（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 輸入在庫調査有無（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 輸入在庫調査有無（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 輸入在庫調査有無（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 輸入在庫調査有無（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 輸入在庫調査有無（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 輸入在庫調査有無（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 輸入在庫調査有無（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 輸入在庫調査有無（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 輸入在庫調査有無（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 輸入在庫調査有無（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 輸入在庫調査有無（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 輸入在庫調査有無（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 輸入在庫調査有無（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 輸入在庫調査有無（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 輸入在庫調査有無（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 輸入在庫調査有無（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 輸入在庫調査有無（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 輸入在庫調査有無（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 輸入在庫調査有無（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 輸入在庫調査有無（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 輸入在庫調査有無（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 輸入在庫調査有無（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 輸入在庫調査有無（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 輸入在庫調査有無（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 輸入在庫調査有無（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 輸入在庫調査有無（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 輸入在庫調査有無（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 輸入在庫調査有無（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 輸入在庫調査有無（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 輸入在庫調査有無（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, Importumu> _codeClsMap = new HashMap<String, Importumu>();
        private static final Map<String, Importumu> _nameClsMap = new HashMap<String, Importumu>();
        static {
            for (Importumu value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Importumu(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Importumu; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Importumu> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Importumu) { return OptionalThing.of((Importumu)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Importumu> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Importumu codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Importumu) { return (Importumu)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Importumu nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Importumu> listAll() {
            return new ArrayList<Importumu>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Importumu> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Importumu." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Importumu> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Importumu> clsList = new ArrayList<Importumu>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Importumu> groupOf(String groupName) {
            return new ArrayList<Importumu>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * はり紙検品スキャン可否フラグ
     */
    public enum Traceshiftflg implements CDef {
        /** $8351: はり紙検品スキャン可否フラグ（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: はり紙検品スキャン可否フラグ（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: はり紙検品スキャン可否フラグ（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: はり紙検品スキャン可否フラグ（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: はり紙検品スキャン可否フラグ（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: はり紙検品スキャン可否フラグ（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: はり紙検品スキャン可否フラグ（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: はり紙検品スキャン可否フラグ（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: はり紙検品スキャン可否フラグ（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: はり紙検品スキャン可否フラグ（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: はり紙検品スキャン可否フラグ（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: はり紙検品スキャン可否フラグ（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: はり紙検品スキャン可否フラグ（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: はり紙検品スキャン可否フラグ（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: はり紙検品スキャン可否フラグ（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: はり紙検品スキャン可否フラグ（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: はり紙検品スキャン可否フラグ（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: はり紙検品スキャン可否フラグ（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: はり紙検品スキャン可否フラグ（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: はり紙検品スキャン可否フラグ（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: はり紙検品スキャン可否フラグ（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: はり紙検品スキャン可否フラグ（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: はり紙検品スキャン可否フラグ（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: はり紙検品スキャン可否フラグ（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: はり紙検品スキャン可否フラグ（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: はり紙検品スキャン可否フラグ（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: はり紙検品スキャン可否フラグ（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: はり紙検品スキャン可否フラグ（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: はり紙検品スキャン可否フラグ（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: はり紙検品スキャン可否フラグ（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: はり紙検品スキャン可否フラグ（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: はり紙検品スキャン可否フラグ（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: はり紙検品スキャン可否フラグ（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: はり紙検品スキャン可否フラグ（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, Traceshiftflg> _codeClsMap = new HashMap<String, Traceshiftflg>();
        private static final Map<String, Traceshiftflg> _nameClsMap = new HashMap<String, Traceshiftflg>();
        static {
            for (Traceshiftflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Traceshiftflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Traceshiftflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Traceshiftflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Traceshiftflg) { return OptionalThing.of((Traceshiftflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Traceshiftflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Traceshiftflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Traceshiftflg) { return (Traceshiftflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Traceshiftflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Traceshiftflg> listAll() {
            return new ArrayList<Traceshiftflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Traceshiftflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Traceshiftflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Traceshiftflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Traceshiftflg> clsList = new ArrayList<Traceshiftflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Traceshiftflg> groupOf(String groupName) {
            return new ArrayList<Traceshiftflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 輸送形態コード
     */
    public enum Shtypecd implements CDef {
        /** $2020: トラック１０ｔ */
        $2020("2020", "$2020", emptyStrings())
        ,
        /** $2060: トラック  ４ｔ */
        $2060("2060", "$2060", emptyStrings())
        ,
        /** $3010: コンテナＰ */
        $3010("3010", "$3010", emptyStrings())
        ,
        /** $3510: コンテナ３１ｆｔ */
        $3510("3510", "$3510", emptyStrings())
        ,
        /** $4021: 海上コンテナ５ｔ */
        $4021("4021", "$4021", emptyStrings())
        ,
        /** $4031: 海上コンテナ１０ｔ */
        $4031("4031", "$4031", emptyStrings())
        ,
        /** $4081: 海上トレーラ */
        $4081("4081", "$4081", emptyStrings())
        ,
        /** $5011: 路線　バラ */
        $5011("5011", "$5011", emptyStrings())
        ,
        /** $5020: 路線　パレ */
        $5020("5020", "$5020", emptyStrings())
        ,
        /** $5050: Ａｉｒ便 */
        $5050("5050", "$5050", emptyStrings())
        ,
        /** $5060: 宅配便 */
        $5060("5060", "$5060", emptyStrings())
        ,
        /** $8021: 巡回 東京-王子 */
        $8021("8021", "$8021", emptyStrings())
        ,
        /** $8022: 巡回 千葉-王子 */
        $8022("8022", "$8022", emptyStrings())
        ,
        /** $8023: 巡回 千葉-東京 */
        $8023("8023", "$8023", emptyStrings())
        ,
        /** $8024: 巡回千葉-東京-王子 */
        $8024("8024", "$8024", emptyStrings())
        ,
        /** $8025: 巡回千葉-東京-王子 10 */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8054: 巡回-神戸-大阪-泉大津 */
        $8054("8054", "$8054", emptyStrings())
        ,
        /** $8055: 巡回-神戸-大阪-泉大津 10 */
        $8055("8055", "$8055", emptyStrings())
        ,
        /** $8056: 巡回-神戸-大阪 */
        $8056("8056", "$8056", emptyStrings())
        ,
        /** $8057: 巡回-神戸-泉大津 */
        $8057("8057", "$8057", emptyStrings())
        ,
        /** $8058: 巡回-泉大津-大阪 */
        $8058("8058", "$8058", emptyStrings())
        ;
        private static final Map<String, Shtypecd> _codeClsMap = new HashMap<String, Shtypecd>();
        private static final Map<String, Shtypecd> _nameClsMap = new HashMap<String, Shtypecd>();
        static {
            for (Shtypecd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Shtypecd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Shtypecd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Shtypecd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Shtypecd) { return OptionalThing.of((Shtypecd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Shtypecd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Shtypecd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Shtypecd) { return (Shtypecd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Shtypecd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Shtypecd> listAll() {
            return new ArrayList<Shtypecd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Shtypecd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Shtypecd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Shtypecd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Shtypecd> clsList = new ArrayList<Shtypecd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Shtypecd> groupOf(String groupName) {
            return new ArrayList<Shtypecd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 輸入元コード
     */
    public enum Allocpolicy implements CDef {
        /** $1: ＰＭ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ＢＡＴ */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Allocpolicy> _codeClsMap = new HashMap<String, Allocpolicy>();
        private static final Map<String, Allocpolicy> _nameClsMap = new HashMap<String, Allocpolicy>();
        static {
            for (Allocpolicy value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Allocpolicy(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Allocpolicy; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Allocpolicy> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Allocpolicy) { return OptionalThing.of((Allocpolicy)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Allocpolicy> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Allocpolicy codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Allocpolicy) { return (Allocpolicy)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Allocpolicy nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Allocpolicy> listAll() {
            return new ArrayList<Allocpolicy>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Allocpolicy> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Allocpolicy." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Allocpolicy> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Allocpolicy> clsList = new ArrayList<Allocpolicy>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Allocpolicy> groupOf(String groupName) {
            return new ArrayList<Allocpolicy>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 返送先拠点コード
     */
    public enum Rtncompanyname implements CDef {
        /** $A000: （国産）大井商品処理センター */
        $A000("A000", "$A000", emptyStrings())
        ,
        /** $0001: 大井保税センター */
        $0001("0001", "$0001", emptyStrings())
        ,
        /** $0000: （空白） */
        $0000("0000", "$0000", emptyStrings())
        ;
        private static final Map<String, Rtncompanyname> _codeClsMap = new HashMap<String, Rtncompanyname>();
        private static final Map<String, Rtncompanyname> _nameClsMap = new HashMap<String, Rtncompanyname>();
        static {
            for (Rtncompanyname value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Rtncompanyname(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Rtncompanyname; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rtncompanyname> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Rtncompanyname) { return OptionalThing.of((Rtncompanyname)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rtncompanyname> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Rtncompanyname codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Rtncompanyname) { return (Rtncompanyname)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Rtncompanyname nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Rtncompanyname> listAll() {
            return new ArrayList<Rtncompanyname>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Rtncompanyname> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Rtncompanyname." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Rtncompanyname> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Rtncompanyname> clsList = new ArrayList<Rtncompanyname>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Rtncompanyname> groupOf(String groupName) {
            return new ArrayList<Rtncompanyname>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 開差有無
     */
    public enum Opendiff implements CDef {
        /** $0: 開差有 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 開差無 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Opendiff> _codeClsMap = new HashMap<String, Opendiff>();
        private static final Map<String, Opendiff> _nameClsMap = new HashMap<String, Opendiff>();
        static {
            for (Opendiff value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Opendiff(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Opendiff; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Opendiff> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Opendiff) { return OptionalThing.of((Opendiff)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Opendiff> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Opendiff codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Opendiff) { return (Opendiff)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Opendiff nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Opendiff> listAll() {
            return new ArrayList<Opendiff>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Opendiff> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Opendiff." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Opendiff> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Opendiff> clsList = new ArrayList<Opendiff>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Opendiff> groupOf(String groupName) {
            return new ArrayList<Opendiff>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫有無
     */
    public enum ItemcdlookupAvailableflg implements CDef {
        /** $0: 無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ItemcdlookupAvailableflg> _codeClsMap = new HashMap<String, ItemcdlookupAvailableflg>();
        private static final Map<String, ItemcdlookupAvailableflg> _nameClsMap = new HashMap<String, ItemcdlookupAvailableflg>();
        static {
            for (ItemcdlookupAvailableflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ItemcdlookupAvailableflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ItemcdlookupAvailableflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItemcdlookupAvailableflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ItemcdlookupAvailableflg) { return OptionalThing.of((ItemcdlookupAvailableflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItemcdlookupAvailableflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ItemcdlookupAvailableflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ItemcdlookupAvailableflg) { return (ItemcdlookupAvailableflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ItemcdlookupAvailableflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ItemcdlookupAvailableflg> listAll() {
            return new ArrayList<ItemcdlookupAvailableflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ItemcdlookupAvailableflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ItemcdlookupAvailableflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ItemcdlookupAvailableflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ItemcdlookupAvailableflg> clsList = new ArrayList<ItemcdlookupAvailableflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ItemcdlookupAvailableflg> groupOf(String groupName) {
            return new ArrayList<ItemcdlookupAvailableflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 融通山出しリスト印刷区分
     */
    public enum Flexpickprflg implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 変更済 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Flexpickprflg> _codeClsMap = new HashMap<String, Flexpickprflg>();
        private static final Map<String, Flexpickprflg> _nameClsMap = new HashMap<String, Flexpickprflg>();
        static {
            for (Flexpickprflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Flexpickprflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Flexpickprflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flexpickprflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Flexpickprflg) { return OptionalThing.of((Flexpickprflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flexpickprflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Flexpickprflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Flexpickprflg) { return (Flexpickprflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Flexpickprflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Flexpickprflg> listAll() {
            return new ArrayList<Flexpickprflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Flexpickprflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Flexpickprflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Flexpickprflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Flexpickprflg> clsList = new ArrayList<Flexpickprflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Flexpickprflg> groupOf(String groupName) {
            return new ArrayList<Flexpickprflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業実績拡張マスタ
     */
    public enum WorkmasterExp implements CDef {
        /** $HK001L01: ログイン */
        $HK001L01("HK001L01", "$HK001L01", emptyStrings())
        ,
        /** $HK003L01: ログイン */
        $HK003L01("HK003L01", "$HK003L01", emptyStrings())
        ,
        /** $HN002L01: ログアウト確認 */
        $HN002L01("HN002L01", "$HN002L01", emptyStrings())
        ,
        /** $HN002L02: 受入検品 */
        $HN002L02("HN002L02", "$HN002L02", emptyStrings())
        ,
        /** $HN003L01: 受入検品 */
        $HN003L01("HN003L01", "$HN003L01", emptyStrings())
        ,
        /** $HN003L02: はり紙検品 */
        $HN003L02("HN003L02", "$HN003L02", emptyStrings())
        ,
        /** $HN001L01: はり紙検品 */
        $HN001L01("HN001L01", "$HN001L01", emptyStrings())
        ,
        /** $HN001L02: 入庫格納 */
        $HN001L02("HN001L02", "$HN001L02", emptyStrings())
        ,
        /** $HN001L03: 入庫格納 */
        $HN001L03("HN001L03", "$HN001L03", emptyStrings())
        ,
        /** $HN004L01: 入庫格納 */
        $HN004L01("HN004L01", "$HN004L01", emptyStrings())
        ,
        /** $HN004L02: ケース検品 */
        $HN004L02("HN004L02", "$HN004L02", emptyStrings())
        ,
        /** $HS001L01: ケース検品 */
        $HS001L01("HS001L01", "$HS001L01", emptyStrings())
        ,
        /** $HS001L02: 山出し作業 */
        $HS001L02("HS001L02", "$HS001L02", emptyStrings())
        ,
        /** $HS002L01: 山出し作業 */
        $HS002L01("HS002L01", "$HS002L01", emptyStrings())
        ,
        /** $HS002L02: 製品移動 */
        $HS002L02("HS002L02", "$HS002L02", emptyStrings())
        ,
        /** $HS003L01: 製品移動 */
        $HS003L01("HS003L01", "$HS003L01", emptyStrings())
        ,
        /** $HS003L02: 引継検品 */
        $HS003L02("HS003L02", "$HS003L02", emptyStrings())
        ,
        /** $HS004L01: 引継検品 */
        $HS004L01("HS004L01", "$HS004L01", emptyStrings())
        ,
        /** $HS004L02: ケース単位出荷 */
        $HS004L02("HS004L02", "$HS004L02", emptyStrings())
        ,
        /** $HS004L03: ケース単位出荷 */
        $HS004L03("HS004L03", "$HS004L03", emptyStrings())
        ,
        /** $HS004L04: ケース単位出荷 */
        $HS004L04("HS004L04", "$HS004L04", emptyStrings())
        ,
        /** $HZ002L01: ケース単位出荷 */
        $HZ002L01("HZ002L01", "$HZ002L01", emptyStrings())
        ,
        /** $HZ002L02: 保管場在庫照会 */
        $HZ002L02("HZ002L02", "$HZ002L02", emptyStrings())
        ,
        /** $HZ009L01: 保管場在庫照会 */
        $HZ009L01("HZ009L01", "$HZ009L01", emptyStrings())
        ,
        /** $HZ009L02: ケース情報照会 */
        $HZ009L02("HZ009L02", "$HZ009L02", emptyStrings())
        ,
        /** $HZ003L01: ケース情報照会 */
        $HZ003L01("HZ003L01", "$HZ003L01", emptyStrings())
        ,
        /** $HZ003L02: はい替 */
        $HZ003L02("HZ003L02", "$HZ003L02", emptyStrings())
        ,
        /** $HZ005L01: はい替 */
        $HZ005L01("HZ005L01", "$HZ005L01", emptyStrings())
        ,
        /** $HZ005L02: 分割はい替 */
        $HZ005L02("HZ005L02", "$HZ005L02", emptyStrings())
        ,
        /** $HZ001L01: 分割はい替 */
        $HZ001L01("HZ001L01", "$HZ001L01", emptyStrings())
        ,
        /** $HZ001L02: 保管場在庫調査 */
        $HZ001L02("HZ001L02", "$HZ001L02", emptyStrings())
        ,
        /** $HZ001L03: 保管場在庫調査 */
        $HZ001L03("HZ001L03", "$HZ001L03", emptyStrings())
        ,
        /** $HZ001L04: 保管場在庫調査 */
        $HZ001L04("HZ001L04", "$HZ001L04", emptyStrings())
        ,
        /** $HZ008L01: 保管場在庫調査 */
        $HZ008L01("HZ008L01", "$HZ008L01", emptyStrings())
        ,
        /** $HZ008L02: 引取場在庫調査 */
        $HZ008L02("HZ008L02", "$HZ008L02", emptyStrings())
        ,
        /** $HZ004L01: 引取場在庫調査 */
        $HZ004L01("HZ004L01", "$HZ004L01", emptyStrings())
        ,
        /** $HZ004L02: 仕分場在庫調査 */
        $HZ004L02("HZ004L02", "$HZ004L02", emptyStrings())
        ,
        /** $HZ007L01: 仕分場在庫調査 */
        $HZ007L01("HZ007L01", "$HZ007L01", emptyStrings())
        ,
        /** $HZ007L02: 国税還付品在庫調査 */
        $HZ007L02("HZ007L02", "$HZ007L02", emptyStrings())
        ,
        /** $HZ006L01: 国税還付品在庫調査 */
        $HZ006L01("HZ006L01", "$HZ006L01", emptyStrings())
        ,
        /** $HZ006L02: かし品在庫調査 */
        $HZ006L02("HZ006L02", "$HZ006L02", emptyStrings())
        ,
        /** $HW001L01: かし品在庫調査 */
        $HW001L01("HW001L01", "$HW001L01", emptyStrings())
        ,
        /** $HW001L02: うしろ補充 */
        $HW001L02("HW001L02", "$HW001L02", emptyStrings())
        ,
        /** $HW002L01: うしろ補充 */
        $HW002L01("HW002L01", "$HW002L01", emptyStrings())
        ,
        /** $HW002L02: まえ補充 */
        $HW002L02("HW002L02", "$HW002L02", emptyStrings())
        ,
        /** $HW002L03: まえ補充 */
        $HW002L03("HW002L03", "$HW002L03", emptyStrings())
        ,
        /** $HW003L01: まえ補充 */
        $HW003L01("HW003L01", "$HW003L01", emptyStrings())
        ,
        /** $HW003L02: 取出 */
        $HW003L02("HW003L02", "$HW003L02", emptyStrings())
        ,
        /** $HW003L03: 取出 */
        $HW003L03("HW003L03", "$HW003L03", emptyStrings())
        ,
        /** $HT001L01: 取出 */
        $HT001L01("HT001L01", "$HT001L01", emptyStrings())
        ,
        /** $HT001L02: 引取場受入登録 */
        $HT001L02("HT001L02", "$HT001L02", emptyStrings())
        ,
        /** $HT002L01: 引取場受入登録 */
        $HT002L01("HT002L01", "$HT002L01", emptyStrings())
        ,
        /** $HT002L02: 引取場受入解除 */
        $HT002L02("HT002L02", "$HT002L02", emptyStrings())
        ,
        /** $TH002L01: 引取場受入解除 */
        $TH002L01("TH002L01", "$TH002L01", emptyStrings())
        ,
        /** $TH002L02: 返品業務 */
        $TH002L02("TH002L02", "$TH002L02", emptyStrings())
        ;
        private static final Map<String, WorkmasterExp> _codeClsMap = new HashMap<String, WorkmasterExp>();
        private static final Map<String, WorkmasterExp> _nameClsMap = new HashMap<String, WorkmasterExp>();
        static {
            for (WorkmasterExp value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkmasterExp(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkmasterExp; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkmasterExp> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkmasterExp) { return OptionalThing.of((WorkmasterExp)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkmasterExp> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkmasterExp codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkmasterExp) { return (WorkmasterExp)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkmasterExp nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkmasterExp> listAll() {
            return new ArrayList<WorkmasterExp>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkmasterExp> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkmasterExp." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkmasterExp> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkmasterExp> clsList = new ArrayList<WorkmasterExp>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkmasterExp> groupOf(String groupName) {
            return new ArrayList<WorkmasterExp>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業実績区分
     */
    public enum Tasktype implements CDef {
        /** $HN: 入庫管理 */
        $HN("HN", "$HN", emptyStrings())
        ,
        /** $HS: 山出し管理 */
        $HS("HS", "$HS", emptyStrings())
        ,
        /** $HZ: 在庫管理 */
        $HZ("HZ", "$HZ", emptyStrings())
        ,
        /** $HC: 在庫調査 */
        $HC("HC", "$HC", emptyStrings())
        ,
        /** $HW: 仕分場管理 */
        $HW("HW", "$HW", emptyStrings())
        ,
        /** $HT: 引取場管理 */
        $HT("HT", "$HT", emptyStrings())
        ,
        /** $TH: 返品管理 */
        $TH("TH", "$TH", emptyStrings())
        ;
        private static final Map<String, Tasktype> _codeClsMap = new HashMap<String, Tasktype>();
        private static final Map<String, Tasktype> _nameClsMap = new HashMap<String, Tasktype>();
        static {
            for (Tasktype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Tasktype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Tasktype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tasktype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Tasktype) { return OptionalThing.of((Tasktype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tasktype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Tasktype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Tasktype) { return (Tasktype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Tasktype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Tasktype> listAll() {
            return new ArrayList<Tasktype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Tasktype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Tasktype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Tasktype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Tasktype> clsList = new ArrayList<Tasktype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Tasktype> groupOf(String groupName) {
            return new ArrayList<Tasktype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業実績区分詳細
     */
    public enum Tasktypedetail implements CDef {
        /** $HN002L01: 受入検品 */
        $HN002L01("HN002L01", "$HN002L01", emptyStrings())
        ,
        /** $HN003L01: はり紙検品 */
        $HN003L01("HN003L01", "$HN003L01", emptyStrings())
        ,
        /** $HN001L01: 入庫格納 */
        $HN001L01("HN001L01", "$HN001L01", emptyStrings())
        ,
        /** $HN004L01: ケース検品 */
        $HN004L01("HN004L01", "$HN004L01", emptyStrings())
        ,
        /** $HS001L01: 山出し作業 */
        $HS001L01("HS001L01", "$HS001L01", emptyStrings())
        ,
        /** $HS002L01: 製品移動 */
        $HS002L01("HS002L01", "$HS002L01", emptyStrings())
        ,
        /** $HS004L01: ケース単位出荷 */
        $HS004L01("HS004L01", "$HS004L01", emptyStrings())
        ,
        /** $HZ009L01: ケース情報照会 */
        $HZ009L01("HZ009L01", "$HZ009L01", emptyStrings())
        ,
        /** $HZ003L01: はい替 */
        $HZ003L01("HZ003L01", "$HZ003L01", emptyStrings())
        ,
        /** $HZ001L01: 保管場在庫調査 */
        $HZ001L01("HZ001L01", "$HZ001L01", emptyStrings())
        ,
        /** $HZ008L01: 引取場在庫調査 */
        $HZ008L01("HZ008L01", "$HZ008L01", emptyStrings())
        ,
        /** $HZ004L01: 仕分場在庫調査 */
        $HZ004L01("HZ004L01", "$HZ004L01", emptyStrings())
        ,
        /** $HZ007L01: 国税還付品在庫調査 */
        $HZ007L01("HZ007L01", "$HZ007L01", emptyStrings())
        ,
        /** $HZ006L01: かし品在庫調査 */
        $HZ006L01("HZ006L01", "$HZ006L01", emptyStrings())
        ,
        /** $HW001L01: うしろ補充 */
        $HW001L01("HW001L01", "$HW001L01", emptyStrings())
        ,
        /** $HW002L01: まえ補充 */
        $HW002L01("HW002L01", "$HW002L01", emptyStrings())
        ,
        /** $HW003L01: 取出 */
        $HW003L01("HW003L01", "$HW003L01", emptyStrings())
        ,
        /** $HT001L01: 引取場受入登録 */
        $HT001L01("HT001L01", "$HT001L01", emptyStrings())
        ,
        /** $HT002L01: 引取場受入解除 */
        $HT002L01("HT002L01", "$HT002L01", emptyStrings())
        ,
        /** $TH002L01: 返品業務 */
        $TH002L01("TH002L01", "$TH002L01", emptyStrings())
        ;
        private static final Map<String, Tasktypedetail> _codeClsMap = new HashMap<String, Tasktypedetail>();
        private static final Map<String, Tasktypedetail> _nameClsMap = new HashMap<String, Tasktypedetail>();
        static {
            for (Tasktypedetail value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Tasktypedetail(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Tasktypedetail; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tasktypedetail> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Tasktypedetail) { return OptionalThing.of((Tasktypedetail)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Tasktypedetail> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Tasktypedetail codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Tasktypedetail) { return (Tasktypedetail)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Tasktypedetail nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Tasktypedetail> listAll() {
            return new ArrayList<Tasktypedetail>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Tasktypedetail> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Tasktypedetail." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Tasktypedetail> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Tasktypedetail> clsList = new ArrayList<Tasktypedetail>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Tasktypedetail> groupOf(String groupName) {
            return new ArrayList<Tasktypedetail>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 融通山出しスキャン可否フラグ
     */
    public enum Yztraceshiftflg implements CDef {
        /** $8351: 融通山出しスキャン可否フラグ（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 融通山出しスキャン可否フラグ（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 融通山出しスキャン可否フラグ（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 融通山出しスキャン可否フラグ（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 融通山出しスキャン可否フラグ（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 融通山出しスキャン可否フラグ（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 融通山出しスキャン可否フラグ（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 融通山出しスキャン可否フラグ（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 融通山出しスキャン可否フラグ（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 融通山出しスキャン可否フラグ（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 融通山出しスキャン可否フラグ（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 融通山出しスキャン可否フラグ（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 融通山出しスキャン可否フラグ（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 融通山出しスキャン可否フラグ（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 融通山出しスキャン可否フラグ（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 融通山出しスキャン可否フラグ（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 融通山出しスキャン可否フラグ（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 融通山出しスキャン可否フラグ（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 融通山出しスキャン可否フラグ（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 融通山出しスキャン可否フラグ（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 融通山出しスキャン可否フラグ（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 融通山出しスキャン可否フラグ（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 融通山出しスキャン可否フラグ（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 融通山出しスキャン可否フラグ（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 融通山出しスキャン可否フラグ（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8042: 融通山出しスキャン可否フラグ（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8318: 融通山出しスキャン可否フラグ（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8025: 融通山出しスキャン可否フラグ（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 融通山出しスキャン可否フラグ（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 融通山出しスキャン可否フラグ（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 融通山出しスキャン可否フラグ（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 融通山出しスキャン可否フラグ（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 融通山出しスキャン可否フラグ（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 融通山出しスキャン可否フラグ（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, Yztraceshiftflg> _codeClsMap = new HashMap<String, Yztraceshiftflg>();
        private static final Map<String, Yztraceshiftflg> _nameClsMap = new HashMap<String, Yztraceshiftflg>();
        static {
            for (Yztraceshiftflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Yztraceshiftflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Yztraceshiftflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Yztraceshiftflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Yztraceshiftflg) { return OptionalThing.of((Yztraceshiftflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Yztraceshiftflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Yztraceshiftflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Yztraceshiftflg) { return (Yztraceshiftflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Yztraceshiftflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Yztraceshiftflg> listAll() {
            return new ArrayList<Yztraceshiftflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Yztraceshiftflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Yztraceshiftflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Yztraceshiftflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Yztraceshiftflg> clsList = new ArrayList<Yztraceshiftflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Yztraceshiftflg> groupOf(String groupName) {
            return new ArrayList<Yztraceshiftflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 社員コード検索区分
     */
    public enum Workercdsearchtype implements CDef {
        /** $WORKER: 作業実績 */
        $WORKER("WORKER", "$WORKER", emptyStrings())
        ,
        /** $USER: 登録ユーザ */
        $USER("USER", "$USER", emptyStrings())
        ;
        private static final Map<String, Workercdsearchtype> _codeClsMap = new HashMap<String, Workercdsearchtype>();
        private static final Map<String, Workercdsearchtype> _nameClsMap = new HashMap<String, Workercdsearchtype>();
        static {
            for (Workercdsearchtype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Workercdsearchtype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Workercdsearchtype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Workercdsearchtype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Workercdsearchtype) { return OptionalThing.of((Workercdsearchtype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Workercdsearchtype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Workercdsearchtype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Workercdsearchtype) { return (Workercdsearchtype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Workercdsearchtype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Workercdsearchtype> listAll() {
            return new ArrayList<Workercdsearchtype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Workercdsearchtype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Workercdsearchtype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Workercdsearchtype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Workercdsearchtype> clsList = new ArrayList<Workercdsearchtype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Workercdsearchtype> groupOf(String groupName) {
            return new ArrayList<Workercdsearchtype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）
     */
    public enum PrinterdefZ004 implements CDef {
        /** $8351: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefZ004> _codeClsMap = new HashMap<String, PrinterdefZ004>();
        private static final Map<String, PrinterdefZ004> _nameClsMap = new HashMap<String, PrinterdefZ004>();
        static {
            for (PrinterdefZ004 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefZ004(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefZ004; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefZ004> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefZ004) { return OptionalThing.of((PrinterdefZ004)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefZ004> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefZ004 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefZ004) { return (PrinterdefZ004)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefZ004 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefZ004> listAll() {
            return new ArrayList<PrinterdefZ004>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefZ004> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefZ004." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefZ004> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefZ004> clsList = new ArrayList<PrinterdefZ004>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefZ004> groupOf(String groupName) {
            return new ArrayList<PrinterdefZ004>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（ＨＴ）
     */
    public enum PrinterdefZ008 implements CDef {
        /** $8351: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefZ008> _codeClsMap = new HashMap<String, PrinterdefZ008>();
        private static final Map<String, PrinterdefZ008> _nameClsMap = new HashMap<String, PrinterdefZ008>();
        static {
            for (PrinterdefZ008 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefZ008(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefZ008; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefZ008> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefZ008) { return OptionalThing.of((PrinterdefZ008)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefZ008> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefZ008 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefZ008) { return (PrinterdefZ008)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefZ008 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefZ008> listAll() {
            return new ArrayList<PrinterdefZ008>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefZ008> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefZ008." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefZ008> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefZ008> clsList = new ArrayList<PrinterdefZ008>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefZ008> groupOf(String groupName) {
            return new ArrayList<PrinterdefZ008>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 山出し先名称
     */
    public enum Pickdistname implements CDef {
        /** $L1: L1 */
        $L1("L1", "$L1", emptyStrings())
        ,
        /** $L2: L2 */
        $L2("L2", "$L2", emptyStrings())
        ,
        /** $L3: L3 */
        $L3("L3", "$L3", emptyStrings())
        ,
        /** $L4: L4 */
        $L4("L4", "$L4", emptyStrings())
        ,
        /** $L5: L5 */
        $L5("L5", "$L5", emptyStrings())
        ,
        /** $L6: L6 */
        $L6("L6", "$L6", emptyStrings())
        ,
        /** $L7: L7 */
        $L7("L7", "$L7", emptyStrings())
        ,
        /** $L8: L8 */
        $L8("L8", "$L8", emptyStrings())
        ,
        /** $L9: L9 */
        $L9("L9", "$L9", emptyStrings())
        ,
        /** $B1: B1 */
        $B1("B1", "$B1", emptyStrings())
        ,
        /** $B2: B2 */
        $B2("B2", "$B2", emptyStrings())
        ,
        /** $B3: B3 */
        $B3("B3", "$B3", emptyStrings())
        ,
        /** $B4: B4 */
        $B4("B4", "$B4", emptyStrings())
        ,
        /** $B5: B5 */
        $B5("B5", "$B5", emptyStrings())
        ,
        /** $99: ケース */
        $99("99", "$99", emptyStrings())
        ,
        /** $9903: 引取場 */
        $9903("9903", "$9903", emptyStrings())
        ,
        /** $9905: 融通 */
        $9905("9905", "$9905", emptyStrings())
        ,
        /** $9910: その他 */
        $9910("9910", "$9910", emptyStrings())
        ,
        /** $_: （ラインブロック） */
        $_("_", "$_", emptyStrings())
        ;
        private static final Map<String, Pickdistname> _codeClsMap = new HashMap<String, Pickdistname>();
        private static final Map<String, Pickdistname> _nameClsMap = new HashMap<String, Pickdistname>();
        static {
            for (Pickdistname value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Pickdistname(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Pickdistname; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pickdistname> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Pickdistname) { return OptionalThing.of((Pickdistname)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pickdistname> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Pickdistname codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Pickdistname) { return (Pickdistname)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Pickdistname nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Pickdistname> listAll() {
            return new ArrayList<Pickdistname>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Pickdistname> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Pickdistname." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Pickdistname> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Pickdistname> clsList = new ArrayList<Pickdistname>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Pickdistname> groupOf(String groupName) {
            return new ArrayList<Pickdistname>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製品追跡移行フラグ
     */
    public enum Traceswitchflg implements CDef {
        /** $8351: 製品追跡移行フラグ（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 製品追跡移行フラグ（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 製品追跡移行フラグ（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 製品追跡移行フラグ（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 製品追跡移行フラグ（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 製品追跡移行フラグ（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 製品追跡移行フラグ（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 製品追跡移行フラグ（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 製品追跡移行フラグ（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 製品追跡移行フラグ（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 製品追跡移行フラグ（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 製品追跡移行フラグ（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 製品追跡移行フラグ（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 製品追跡移行フラグ（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 製品追跡移行フラグ（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 製品追跡移行フラグ（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 製品追跡移行フラグ（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 製品追跡移行フラグ（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 製品追跡移行フラグ（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 製品追跡移行フラグ（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 製品追跡移行フラグ（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 製品追跡移行フラグ（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 製品追跡移行フラグ（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 製品追跡移行フラグ（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 製品追跡移行フラグ（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 製品追跡移行フラグ（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 製品追跡移行フラグ（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 製品追跡移行フラグ（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 製品追跡移行フラグ（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 製品追跡移行フラグ（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 製品追跡移行フラグ（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 製品追跡移行フラグ（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 製品追跡移行フラグ（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 製品追跡移行フラグ（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, Traceswitchflg> _codeClsMap = new HashMap<String, Traceswitchflg>();
        private static final Map<String, Traceswitchflg> _nameClsMap = new HashMap<String, Traceswitchflg>();
        static {
            for (Traceswitchflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Traceswitchflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Traceswitchflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Traceswitchflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Traceswitchflg) { return OptionalThing.of((Traceswitchflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Traceswitchflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Traceswitchflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Traceswitchflg) { return (Traceswitchflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Traceswitchflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Traceswitchflg> listAll() {
            return new ArrayList<Traceswitchflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Traceswitchflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Traceswitchflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Traceswitchflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Traceswitchflg> clsList = new ArrayList<Traceswitchflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Traceswitchflg> groupOf(String groupName) {
            return new ArrayList<Traceswitchflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ラベル区分
     */
    public enum Lblkbn implements CDef {
        /** $0000: 通常 */
        $0000("0000", "$0000", emptyStrings())
        ,
        /** $9999: 詰合せ */
        $9999("9999", "$9999", emptyStrings())
        ;
        private static final Map<String, Lblkbn> _codeClsMap = new HashMap<String, Lblkbn>();
        private static final Map<String, Lblkbn> _nameClsMap = new HashMap<String, Lblkbn>();
        static {
            for (Lblkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Lblkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Lblkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Lblkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Lblkbn) { return OptionalThing.of((Lblkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Lblkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Lblkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Lblkbn) { return (Lblkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Lblkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Lblkbn> listAll() {
            return new ArrayList<Lblkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Lblkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Lblkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Lblkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Lblkbn> clsList = new ArrayList<Lblkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Lblkbn> groupOf(String groupName) {
            return new ArrayList<Lblkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 詰合せ区分
     */
    public enum Assortkbn implements CDef {
        /** $0: 詰合せ（国産） */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 詰合せ（輸入） */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Assortkbn> _codeClsMap = new HashMap<String, Assortkbn>();
        private static final Map<String, Assortkbn> _nameClsMap = new HashMap<String, Assortkbn>();
        static {
            for (Assortkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Assortkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Assortkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Assortkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Assortkbn) { return OptionalThing.of((Assortkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Assortkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Assortkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Assortkbn) { return (Assortkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Assortkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Assortkbn> listAll() {
            return new ArrayList<Assortkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Assortkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Assortkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Assortkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Assortkbn> clsList = new ArrayList<Assortkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Assortkbn> groupOf(String groupName) {
            return new ArrayList<Assortkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ダミーケースコード
     */
    public enum Dmycasecd implements CDef {
        /** $MACHINENO: 号機 */
        $MACHINENO("MACHINENO", "$MACHINENO", emptyStrings())
        ;
        private static final Map<String, Dmycasecd> _codeClsMap = new HashMap<String, Dmycasecd>();
        private static final Map<String, Dmycasecd> _nameClsMap = new HashMap<String, Dmycasecd>();
        static {
            for (Dmycasecd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Dmycasecd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Dmycasecd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Dmycasecd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Dmycasecd) { return OptionalThing.of((Dmycasecd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Dmycasecd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Dmycasecd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Dmycasecd) { return (Dmycasecd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Dmycasecd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Dmycasecd> listAll() {
            return new ArrayList<Dmycasecd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Dmycasecd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Dmycasecd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Dmycasecd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Dmycasecd> clsList = new ArrayList<Dmycasecd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Dmycasecd> groupOf(String groupName) {
            return new ArrayList<Dmycasecd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 不適品ラベル削除区分
     */
    public enum Baditemdelkbn implements CDef {
        /** $1: 登録 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 削除済 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, Baditemdelkbn> _codeClsMap = new HashMap<String, Baditemdelkbn>();
        private static final Map<String, Baditemdelkbn> _nameClsMap = new HashMap<String, Baditemdelkbn>();
        static {
            for (Baditemdelkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Baditemdelkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Baditemdelkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Baditemdelkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Baditemdelkbn) { return OptionalThing.of((Baditemdelkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Baditemdelkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Baditemdelkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Baditemdelkbn) { return (Baditemdelkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Baditemdelkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Baditemdelkbn> listAll() {
            return new ArrayList<Baditemdelkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Baditemdelkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Baditemdelkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Baditemdelkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Baditemdelkbn> clsList = new ArrayList<Baditemdelkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Baditemdelkbn> groupOf(String groupName) {
            return new ArrayList<Baditemdelkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最大検索件数
     */
    public enum Selectlimit implements CDef {
        /** $TraceConfirmationViewForm: 製品追跡情報確認 */
        $TraceConfirmationViewForm("TraceConfirmationViewForm", "$TraceConfirmationViewForm", emptyStrings())
        ,
        /** $TraceInquiryViewForm: 製品追跡情報照会 */
        $TraceInquiryViewForm("TraceInquiryViewForm", "$TraceInquiryViewForm", emptyStrings())
        ,
        /** $TraceSendTransactionForm: 製品追跡情報送信 */
        $TraceSendTransactionForm("TraceSendTransactionForm", "$TraceSendTransactionForm", emptyStrings())
        ,
        /** $AssortOrderViewForm: さしず実績照会 */
        $AssortOrderViewForm("AssortOrderViewForm", "$AssortOrderViewForm", emptyStrings())
        ;
        private static final Map<String, Selectlimit> _codeClsMap = new HashMap<String, Selectlimit>();
        private static final Map<String, Selectlimit> _nameClsMap = new HashMap<String, Selectlimit>();
        static {
            for (Selectlimit value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Selectlimit(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Selectlimit; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Selectlimit> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Selectlimit) { return OptionalThing.of((Selectlimit)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Selectlimit> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Selectlimit codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Selectlimit) { return (Selectlimit)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Selectlimit nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Selectlimit> listAll() {
            return new ArrayList<Selectlimit>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Selectlimit> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Selectlimit." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Selectlimit> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Selectlimit> clsList = new ArrayList<Selectlimit>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Selectlimit> groupOf(String groupName) {
            return new ArrayList<Selectlimit>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）
     */
    public enum PrinterdefW001 implements CDef {
        /** $8351: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8042: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（小倉） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8044: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8025: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefW001> _codeClsMap = new HashMap<String, PrinterdefW001>();
        private static final Map<String, PrinterdefW001> _nameClsMap = new HashMap<String, PrinterdefW001>();
        static {
            for (PrinterdefW001 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefW001(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefW001; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefW001> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefW001) { return OptionalThing.of((PrinterdefW001)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefW001> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefW001 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefW001) { return (PrinterdefW001)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefW001 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefW001> listAll() {
            return new ArrayList<PrinterdefW001>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefW001> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefW001." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefW001> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefW001> clsList = new ArrayList<PrinterdefW001>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefW001> groupOf(String groupName) {
            return new ArrayList<PrinterdefW001>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）
     */
    public enum PrinterdefW002 implements CDef {
        /** $8351: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8042: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（小倉） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8044: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8025: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefW002> _codeClsMap = new HashMap<String, PrinterdefW002>();
        private static final Map<String, PrinterdefW002> _nameClsMap = new HashMap<String, PrinterdefW002>();
        static {
            for (PrinterdefW002 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefW002(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefW002; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefW002> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefW002) { return OptionalThing.of((PrinterdefW002)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefW002> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefW002 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefW002) { return (PrinterdefW002)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefW002 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefW002> listAll() {
            return new ArrayList<PrinterdefW002>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefW002> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefW002." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefW002> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefW002> clsList = new ArrayList<PrinterdefW002>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefW002> groupOf(String groupName) {
            return new ArrayList<PrinterdefW002>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 決算たな卸月
     */
    public enum Settlementinvmonth implements CDef {
        /** $02: ２月 */
        $02("02", "$02", emptyStrings())
        ,
        /** $09: ９月 */
        $09("09", "$09", emptyStrings())
        ;
        private static final Map<String, Settlementinvmonth> _codeClsMap = new HashMap<String, Settlementinvmonth>();
        private static final Map<String, Settlementinvmonth> _nameClsMap = new HashMap<String, Settlementinvmonth>();
        static {
            for (Settlementinvmonth value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Settlementinvmonth(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Settlementinvmonth; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Settlementinvmonth> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Settlementinvmonth) { return OptionalThing.of((Settlementinvmonth)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Settlementinvmonth> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Settlementinvmonth codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Settlementinvmonth) { return (Settlementinvmonth)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Settlementinvmonth nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Settlementinvmonth> listAll() {
            return new ArrayList<Settlementinvmonth>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Settlementinvmonth> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Settlementinvmonth." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Settlementinvmonth> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Settlementinvmonth> clsList = new ArrayList<Settlementinvmonth>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Settlementinvmonth> groupOf(String groupName) {
            return new ArrayList<Settlementinvmonth>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 融通指示登録ステータス
     */
    public enum Flexinstructsts implements CDef {
        /** $0: 未登録 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 登録済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Flexinstructsts> _codeClsMap = new HashMap<String, Flexinstructsts>();
        private static final Map<String, Flexinstructsts> _nameClsMap = new HashMap<String, Flexinstructsts>();
        static {
            for (Flexinstructsts value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Flexinstructsts(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Flexinstructsts; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flexinstructsts> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Flexinstructsts) { return OptionalThing.of((Flexinstructsts)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flexinstructsts> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Flexinstructsts codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Flexinstructsts) { return (Flexinstructsts)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Flexinstructsts nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Flexinstructsts> listAll() {
            return new ArrayList<Flexinstructsts>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Flexinstructsts> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Flexinstructsts." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Flexinstructsts> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Flexinstructsts> clsList = new ArrayList<Flexinstructsts>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Flexinstructsts> groupOf(String groupName) {
            return new ArrayList<Flexinstructsts>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 強制作成フラグ
     */
    public enum Compulsionflg implements CDef {
        /** $0: しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Compulsionflg> _codeClsMap = new HashMap<String, Compulsionflg>();
        private static final Map<String, Compulsionflg> _nameClsMap = new HashMap<String, Compulsionflg>();
        static {
            for (Compulsionflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Compulsionflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Compulsionflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Compulsionflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Compulsionflg) { return OptionalThing.of((Compulsionflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Compulsionflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Compulsionflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Compulsionflg) { return (Compulsionflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Compulsionflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Compulsionflg> listAll() {
            return new ArrayList<Compulsionflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Compulsionflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Compulsionflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Compulsionflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Compulsionflg> clsList = new ArrayList<Compulsionflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Compulsionflg> groupOf(String groupName) {
            return new ArrayList<Compulsionflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 月表示
     */
    public enum Displaymonth implements CDef {
        /** $0: 当月 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 当月前後１ヶ月 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 当月前後２ヶ月 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 当月前後３ヶ月 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 当月前後４ヶ月 */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, Displaymonth> _codeClsMap = new HashMap<String, Displaymonth>();
        private static final Map<String, Displaymonth> _nameClsMap = new HashMap<String, Displaymonth>();
        static {
            for (Displaymonth value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Displaymonth(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Displaymonth; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Displaymonth> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Displaymonth) { return OptionalThing.of((Displaymonth)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Displaymonth> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Displaymonth codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Displaymonth) { return (Displaymonth)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Displaymonth nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Displaymonth> listAll() {
            return new ArrayList<Displaymonth>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Displaymonth> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Displaymonth." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Displaymonth> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Displaymonth> clsList = new ArrayList<Displaymonth>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Displaymonth> groupOf(String groupName) {
            return new ArrayList<Displaymonth>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * り災品取扱区分（検索用）
     */
    public enum Sufferusagesearchflg implements CDef {
        /** $0: 未登録 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 登録済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 解除 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 未登録または登録済のみ表示 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Sufferusagesearchflg> _codeClsMap = new HashMap<String, Sufferusagesearchflg>();
        private static final Map<String, Sufferusagesearchflg> _nameClsMap = new HashMap<String, Sufferusagesearchflg>();
        static {
            for (Sufferusagesearchflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Sufferusagesearchflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Sufferusagesearchflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sufferusagesearchflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Sufferusagesearchflg) { return OptionalThing.of((Sufferusagesearchflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sufferusagesearchflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Sufferusagesearchflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Sufferusagesearchflg) { return (Sufferusagesearchflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Sufferusagesearchflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Sufferusagesearchflg> listAll() {
            return new ArrayList<Sufferusagesearchflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Sufferusagesearchflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Sufferusagesearchflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Sufferusagesearchflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Sufferusagesearchflg> clsList = new ArrayList<Sufferusagesearchflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Sufferusagesearchflg> groupOf(String groupName) {
            return new ArrayList<Sufferusagesearchflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 平置場基準在庫マスタ初期値
     */
    public enum Fltstdinv implements CDef {
        /** $00: 初期値 */
        $00("00", "$00", emptyStrings())
        ;
        private static final Map<String, Fltstdinv> _codeClsMap = new HashMap<String, Fltstdinv>();
        private static final Map<String, Fltstdinv> _nameClsMap = new HashMap<String, Fltstdinv>();
        static {
            for (Fltstdinv value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Fltstdinv(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Fltstdinv; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fltstdinv> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Fltstdinv) { return OptionalThing.of((Fltstdinv)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fltstdinv> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Fltstdinv codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Fltstdinv) { return (Fltstdinv)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Fltstdinv nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Fltstdinv> listAll() {
            return new ArrayList<Fltstdinv>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Fltstdinv> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Fltstdinv." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Fltstdinv> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Fltstdinv> clsList = new ArrayList<Fltstdinv>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Fltstdinv> groupOf(String groupName) {
            return new ArrayList<Fltstdinv>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 販物Ⅲ移行フラグ
     */
    public enum Cs3switchflg implements CDef {
        /** $8351: 販物Ⅲ移行フラグ（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 販物Ⅲ移行フラグ（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 販物Ⅲ移行フラグ（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 販物Ⅲ移行フラグ（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 販物Ⅲ移行フラグ（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 販物Ⅲ移行フラグ（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 販物Ⅲ移行フラグ（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 販物Ⅲ移行フラグ（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 販物Ⅲ移行フラグ（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 販物Ⅲ移行フラグ（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 販物Ⅲ移行フラグ（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 販物Ⅲ移行フラグ（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8044: 販物Ⅲ移行フラグ（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 販物Ⅲ移行フラグ（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 販物Ⅲ移行フラグ（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 販物Ⅲ移行フラグ（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 販物Ⅲ移行フラグ（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 販物Ⅲ移行フラグ（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 販物Ⅲ移行フラグ（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 販物Ⅲ移行フラグ（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 販物Ⅲ移行フラグ（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 販物Ⅲ移行フラグ（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 販物Ⅲ移行フラグ（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 販物Ⅲ移行フラグ（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 販物Ⅲ移行フラグ（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 販物Ⅲ移行フラグ（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8042: 販物Ⅲ移行フラグ（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8025: 販物Ⅲ移行フラグ（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 販物Ⅲ移行フラグ（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 販物Ⅲ移行フラグ（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 販物Ⅲ移行フラグ（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 販物Ⅲ移行フラグ（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 販物Ⅲ移行フラグ（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 販物Ⅲ移行フラグ（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, Cs3switchflg> _codeClsMap = new HashMap<String, Cs3switchflg>();
        private static final Map<String, Cs3switchflg> _nameClsMap = new HashMap<String, Cs3switchflg>();
        static {
            for (Cs3switchflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Cs3switchflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Cs3switchflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cs3switchflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Cs3switchflg) { return OptionalThing.of((Cs3switchflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cs3switchflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Cs3switchflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Cs3switchflg) { return (Cs3switchflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Cs3switchflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Cs3switchflg> listAll() {
            return new ArrayList<Cs3switchflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Cs3switchflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Cs3switchflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Cs3switchflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Cs3switchflg> clsList = new ArrayList<Cs3switchflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Cs3switchflg> groupOf(String groupName) {
            return new ArrayList<Cs3switchflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 過不足発生場所（不適品画面表示用）
     */
    public enum Inadequacyarea implements CDef {
        /** $4: 国税還付品置場 */
        $4("4", "$4", emptyStrings())
        ,
        /** $9: 返品場 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, Inadequacyarea> _codeClsMap = new HashMap<String, Inadequacyarea>();
        private static final Map<String, Inadequacyarea> _nameClsMap = new HashMap<String, Inadequacyarea>();
        static {
            for (Inadequacyarea value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Inadequacyarea(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Inadequacyarea; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inadequacyarea> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Inadequacyarea) { return OptionalThing.of((Inadequacyarea)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inadequacyarea> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Inadequacyarea codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Inadequacyarea) { return (Inadequacyarea)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Inadequacyarea nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Inadequacyarea> listAll() {
            return new ArrayList<Inadequacyarea>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Inadequacyarea> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Inadequacyarea." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Inadequacyarea> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Inadequacyarea> clsList = new ArrayList<Inadequacyarea>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Inadequacyarea> groupOf(String groupName) {
            return new ArrayList<Inadequacyarea>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送信フラグ
     */
    public enum Transmitflg implements CDef {
        /** $0: 未送信 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 送信中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 送信済 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Transmitflg> _codeClsMap = new HashMap<String, Transmitflg>();
        private static final Map<String, Transmitflg> _nameClsMap = new HashMap<String, Transmitflg>();
        static {
            for (Transmitflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Transmitflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Transmitflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Transmitflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Transmitflg) { return OptionalThing.of((Transmitflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Transmitflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Transmitflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Transmitflg) { return (Transmitflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Transmitflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Transmitflg> listAll() {
            return new ArrayList<Transmitflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Transmitflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Transmitflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Transmitflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Transmitflg> clsList = new ArrayList<Transmitflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Transmitflg> groupOf(String groupName) {
            return new ArrayList<Transmitflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 融通指示変更フラグ
     */
    public enum Flalterflg implements CDef {
        /** $0: 変更無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 変更有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Flalterflg> _codeClsMap = new HashMap<String, Flalterflg>();
        private static final Map<String, Flalterflg> _nameClsMap = new HashMap<String, Flalterflg>();
        static {
            for (Flalterflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Flalterflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Flalterflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flalterflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Flalterflg) { return OptionalThing.of((Flalterflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flalterflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Flalterflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Flalterflg) { return (Flalterflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Flalterflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Flalterflg> listAll() {
            return new ArrayList<Flalterflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Flalterflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Flalterflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Flalterflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Flalterflg> clsList = new ArrayList<Flalterflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Flalterflg> groupOf(String groupName) {
            return new ArrayList<Flalterflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫照会処理ステータス
     */
    public enum Invsts implements CDef {
        /** $100: 受信済 */
        $100("100", "$100", emptyStrings())
        ,
        /** $200: 照会完了 */
        $200("200", "$200", emptyStrings())
        ,
        /** $300: 照会不正 */
        $300("300", "$300", emptyStrings())
        ,
        /** $400: 送信済 */
        $400("400", "$400", emptyStrings())
        ;
        private static final Map<String, Invsts> _codeClsMap = new HashMap<String, Invsts>();
        private static final Map<String, Invsts> _nameClsMap = new HashMap<String, Invsts>();
        static {
            for (Invsts value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Invsts(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Invsts; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Invsts> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Invsts) { return OptionalThing.of((Invsts)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Invsts> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Invsts codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Invsts) { return (Invsts)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Invsts nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Invsts> listAll() {
            return new ArrayList<Invsts>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Invsts> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Invsts." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Invsts> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Invsts> clsList = new ArrayList<Invsts>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Invsts> groupOf(String groupName) {
            return new ArrayList<Invsts>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 同時実行ベース名
     */
    public enum Concurrentbase implements CDef {
        /** $8002_ASSORTORDER: さしず実績（8002） */
        $8002_ASSORTORDER("8002_ASSORTORDER", "$8002_ASSORTORDER", emptyStrings())
        ,
        /** $8004_ASSORTORDER: さしず実績（8004） */
        $8004_ASSORTORDER("8004_ASSORTORDER", "$8004_ASSORTORDER", emptyStrings())
        ,
        /** $8005_ASSORTORDER: さしず実績（8005） */
        $8005_ASSORTORDER("8005_ASSORTORDER", "$8005_ASSORTORDER", emptyStrings())
        ,
        /** $8006_ASSORTORDER: さしず実績（8006） */
        $8006_ASSORTORDER("8006_ASSORTORDER", "$8006_ASSORTORDER", emptyStrings())
        ,
        /** $8009_ASSORTORDER: さしず実績（8009） */
        $8009_ASSORTORDER("8009_ASSORTORDER", "$8009_ASSORTORDER", emptyStrings())
        ,
        /** $8011_ASSORTORDER: さしず実績（8011） */
        $8011_ASSORTORDER("8011_ASSORTORDER", "$8011_ASSORTORDER", emptyStrings())
        ,
        /** $8012_ASSORTORDER: さしず実績（8012） */
        $8012_ASSORTORDER("8012_ASSORTORDER", "$8012_ASSORTORDER", emptyStrings())
        ,
        /** $8016_ASSORTORDER: さしず実績（8016） */
        $8016_ASSORTORDER("8016_ASSORTORDER", "$8016_ASSORTORDER", emptyStrings())
        ,
        /** $8017_ASSORTORDER: さしず実績（8017） */
        $8017_ASSORTORDER("8017_ASSORTORDER", "$8017_ASSORTORDER", emptyStrings())
        ,
        /** $8018_ASSORTORDER: さしず実績（8018） */
        $8018_ASSORTORDER("8018_ASSORTORDER", "$8018_ASSORTORDER", emptyStrings())
        ,
        /** $8019_ASSORTORDER: さしず実績（8019） */
        $8019_ASSORTORDER("8019_ASSORTORDER", "$8019_ASSORTORDER", emptyStrings())
        ,
        /** $8020_ASSORTORDER: さしず実績（8020） */
        $8020_ASSORTORDER("8020_ASSORTORDER", "$8020_ASSORTORDER", emptyStrings())
        ,
        /** $8025_ASSORTORDER: さしず実績（8025） */
        $8025_ASSORTORDER("8025_ASSORTORDER", "$8025_ASSORTORDER", emptyStrings())
        ,
        /** $8027_ASSORTORDER: さしず実績（8027） */
        $8027_ASSORTORDER("8027_ASSORTORDER", "$8027_ASSORTORDER", emptyStrings())
        ,
        /** $8034_ASSORTORDER: さしず実績（8034） */
        $8034_ASSORTORDER("8034_ASSORTORDER", "$8034_ASSORTORDER", emptyStrings())
        ,
        /** $8036_ASSORTORDER: さしず実績（8036） */
        $8036_ASSORTORDER("8036_ASSORTORDER", "$8036_ASSORTORDER", emptyStrings())
        ,
        /** $8037_ASSORTORDER: さしず実績（8037） */
        $8037_ASSORTORDER("8037_ASSORTORDER", "$8037_ASSORTORDER", emptyStrings())
        ,
        /** $8039_ASSORTORDER: さしず実績（8039） */
        $8039_ASSORTORDER("8039_ASSORTORDER", "$8039_ASSORTORDER", emptyStrings())
        ,
        /** $8042_ASSORTORDER: さしず実績（8042） */
        $8042_ASSORTORDER("8042_ASSORTORDER", "$8042_ASSORTORDER", emptyStrings())
        ,
        /** $8044_ASSORTORDER: さしず実績（8044） */
        $8044_ASSORTORDER("8044_ASSORTORDER", "$8044_ASSORTORDER", emptyStrings())
        ,
        /** $8045_ASSORTORDER: さしず実績（8045） */
        $8045_ASSORTORDER("8045_ASSORTORDER", "$8045_ASSORTORDER", emptyStrings())
        ,
        /** $8067_ASSORTORDER: さしず実績（8067） */
        $8067_ASSORTORDER("8067_ASSORTORDER", "$8067_ASSORTORDER", emptyStrings())
        ,
        /** $8075_ASSORTORDER: さしず実績（8075） */
        $8075_ASSORTORDER("8075_ASSORTORDER", "$8075_ASSORTORDER", emptyStrings())
        ,
        /** $8077_ASSORTORDER: さしず実績（8077） */
        $8077_ASSORTORDER("8077_ASSORTORDER", "$8077_ASSORTORDER", emptyStrings())
        ,
        /** $8318_ASSORTORDER: さしず実績（8318） */
        $8318_ASSORTORDER("8318_ASSORTORDER", "$8318_ASSORTORDER", emptyStrings())
        ,
        /** $8351_ASSORTORDER: さしず実績（8351） */
        $8351_ASSORTORDER("8351_ASSORTORDER", "$8351_ASSORTORDER", emptyStrings())
        ,
        /** $8352_ASSORTORDER: さしず実績（8352） */
        $8352_ASSORTORDER("8352_ASSORTORDER", "$8352_ASSORTORDER", emptyStrings())
        ,
        /** $8355_ASSORTORDER: さしず実績（8355） */
        $8355_ASSORTORDER("8355_ASSORTORDER", "$8355_ASSORTORDER", emptyStrings())
        ,
        /** $8356_ASSORTORDER: さしず実績（8356） */
        $8356_ASSORTORDER("8356_ASSORTORDER", "$8356_ASSORTORDER", emptyStrings())
        ,
        /** $8357_ASSORTORDER: さしず実績（8357） */
        $8357_ASSORTORDER("8357_ASSORTORDER", "$8357_ASSORTORDER", emptyStrings())
        ;
        private static final Map<String, Concurrentbase> _codeClsMap = new HashMap<String, Concurrentbase>();
        private static final Map<String, Concurrentbase> _nameClsMap = new HashMap<String, Concurrentbase>();
        static {
            for (Concurrentbase value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Concurrentbase(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Concurrentbase; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Concurrentbase> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Concurrentbase) { return OptionalThing.of((Concurrentbase)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Concurrentbase> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Concurrentbase codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Concurrentbase) { return (Concurrentbase)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Concurrentbase nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Concurrentbase> listAll() {
            return new ArrayList<Concurrentbase>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Concurrentbase> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Concurrentbase." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Concurrentbase> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Concurrentbase> clsList = new ArrayList<Concurrentbase>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Concurrentbase> groupOf(String groupName) {
            return new ArrayList<Concurrentbase>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 同時実行名
     */
    public enum Concurrentname implements CDef {
        /** $CONC_ASSORTORDER_LARGE: さしず実績（大規模拠点） */
        $CONC_ASSORTORDER_LARGE("CONC_ASSORTORDER_LARGE", "$CONC_ASSORTORDER_LARGE", emptyStrings())
        ,
        /** $CONC_ASSORTORDER_MIDDLE: さしず実績（中規模拠点） */
        $CONC_ASSORTORDER_MIDDLE("CONC_ASSORTORDER_MIDDLE", "$CONC_ASSORTORDER_MIDDLE", emptyStrings())
        ,
        /** $CONC_ASSORTORDER_SMALL: さしず実績（小規模拠点） */
        $CONC_ASSORTORDER_SMALL("CONC_ASSORTORDER_SMALL", "$CONC_ASSORTORDER_SMALL", emptyStrings())
        ,
        /** $CONC_ASSORTORDER_ALL: さしず実績（全拠点） */
        $CONC_ASSORTORDER_ALL("CONC_ASSORTORDER_ALL", "$CONC_ASSORTORDER_ALL", emptyStrings())
        ;
        private static final Map<String, Concurrentname> _codeClsMap = new HashMap<String, Concurrentname>();
        private static final Map<String, Concurrentname> _nameClsMap = new HashMap<String, Concurrentname>();
        static {
            for (Concurrentname value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Concurrentname(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Concurrentname; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Concurrentname> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Concurrentname) { return OptionalThing.of((Concurrentname)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Concurrentname> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Concurrentname codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Concurrentname) { return (Concurrentname)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Concurrentname nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Concurrentname> listAll() {
            return new ArrayList<Concurrentname>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Concurrentname> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Concurrentname." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Concurrentname> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Concurrentname> clsList = new ArrayList<Concurrentname>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Concurrentname> groupOf(String groupName) {
            return new ArrayList<Concurrentname>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケース単位出荷ステータス
     */
    public enum Caseshipstatus implements CDef {
        /** $0: 未作業 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 作業済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 作業済（さしず外） */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Caseshipstatus> _codeClsMap = new HashMap<String, Caseshipstatus>();
        private static final Map<String, Caseshipstatus> _nameClsMap = new HashMap<String, Caseshipstatus>();
        static {
            for (Caseshipstatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Caseshipstatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Caseshipstatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Caseshipstatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Caseshipstatus) { return OptionalThing.of((Caseshipstatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Caseshipstatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Caseshipstatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Caseshipstatus) { return (Caseshipstatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Caseshipstatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Caseshipstatus> listAll() {
            return new ArrayList<Caseshipstatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Caseshipstatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Caseshipstatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Caseshipstatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Caseshipstatus> clsList = new ArrayList<Caseshipstatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Caseshipstatus> groupOf(String groupName) {
            return new ArrayList<Caseshipstatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * NGP製品銘柄コード
     */
    public enum Ngpitemcd implements CDef {
        /** $MIN: NGP製品銘柄コード最小値 */
        $MIN("MIN", "$MIN", emptyStrings())
        ,
        /** $MAX: NGP製品銘柄コード最大値 */
        $MAX("MAX", "$MAX", emptyStrings())
        ;
        private static final Map<String, Ngpitemcd> _codeClsMap = new HashMap<String, Ngpitemcd>();
        private static final Map<String, Ngpitemcd> _nameClsMap = new HashMap<String, Ngpitemcd>();
        static {
            for (Ngpitemcd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Ngpitemcd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Ngpitemcd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Ngpitemcd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Ngpitemcd) { return OptionalThing.of((Ngpitemcd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Ngpitemcd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Ngpitemcd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Ngpitemcd) { return (Ngpitemcd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Ngpitemcd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Ngpitemcd> listAll() {
            return new ArrayList<Ngpitemcd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Ngpitemcd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Ngpitemcd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Ngpitemcd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Ngpitemcd> clsList = new ArrayList<Ngpitemcd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Ngpitemcd> groupOf(String groupName) {
            return new ArrayList<Ngpitemcd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫凍結ロケーション
     */
    public enum Fzloccd implements CDef {
        /** $1: X-XX-XX */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Fzloccd> _codeClsMap = new HashMap<String, Fzloccd>();
        private static final Map<String, Fzloccd> _nameClsMap = new HashMap<String, Fzloccd>();
        static {
            for (Fzloccd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Fzloccd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Fzloccd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fzloccd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Fzloccd) { return OptionalThing.of((Fzloccd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fzloccd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Fzloccd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Fzloccd) { return (Fzloccd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Fzloccd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Fzloccd> listAll() {
            return new ArrayList<Fzloccd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Fzloccd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Fzloccd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Fzloccd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Fzloccd> clsList = new ArrayList<Fzloccd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Fzloccd> groupOf(String groupName) {
            return new ArrayList<Fzloccd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 拠点別仕分場在庫区分
     */
    public enum Whsortinvkbn implements CDef {
        /** $0: ラック内 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 仕分済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 出荷済 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 取出済 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Whsortinvkbn> _codeClsMap = new HashMap<String, Whsortinvkbn>();
        private static final Map<String, Whsortinvkbn> _nameClsMap = new HashMap<String, Whsortinvkbn>();
        static {
            for (Whsortinvkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Whsortinvkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Whsortinvkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Whsortinvkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Whsortinvkbn) { return OptionalThing.of((Whsortinvkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Whsortinvkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Whsortinvkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Whsortinvkbn) { return (Whsortinvkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Whsortinvkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Whsortinvkbn> listAll() {
            return new ArrayList<Whsortinvkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Whsortinvkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Whsortinvkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Whsortinvkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Whsortinvkbn> clsList = new ArrayList<Whsortinvkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Whsortinvkbn> groupOf(String groupName) {
            return new ArrayList<Whsortinvkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 同期印刷帳票コード
     */
    public enum Syncreportform implements CDef {
        /** $tsn_TracePicklistSyncREPORT2: 山出しリスト（同期印刷） */
        $tsn_TracePicklistSyncREPORT2("tsn_TracePicklistSyncREPORT2", "$tsn_TracePicklistSyncREPORT2", emptyStrings())
        ;
        private static final Map<String, Syncreportform> _codeClsMap = new HashMap<String, Syncreportform>();
        private static final Map<String, Syncreportform> _nameClsMap = new HashMap<String, Syncreportform>();
        static {
            for (Syncreportform value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Syncreportform(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Syncreportform; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Syncreportform> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Syncreportform) { return OptionalThing.of((Syncreportform)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Syncreportform> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Syncreportform codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Syncreportform) { return (Syncreportform)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Syncreportform nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Syncreportform> listAll() {
            return new ArrayList<Syncreportform>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Syncreportform> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Syncreportform." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Syncreportform> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Syncreportform> clsList = new ArrayList<Syncreportform>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Syncreportform> groupOf(String groupName) {
            return new ArrayList<Syncreportform>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕分場在庫調査対象外拠点コード
     */
    public enum Sortwarehousecd implements CDef {
        /** $8460: 大井東センター */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 埼玉配送センター */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, Sortwarehousecd> _codeClsMap = new HashMap<String, Sortwarehousecd>();
        private static final Map<String, Sortwarehousecd> _nameClsMap = new HashMap<String, Sortwarehousecd>();
        static {
            for (Sortwarehousecd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Sortwarehousecd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Sortwarehousecd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortwarehousecd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Sortwarehousecd) { return OptionalThing.of((Sortwarehousecd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortwarehousecd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Sortwarehousecd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Sortwarehousecd) { return (Sortwarehousecd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Sortwarehousecd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Sortwarehousecd> listAll() {
            return new ArrayList<Sortwarehousecd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Sortwarehousecd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Sortwarehousecd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Sortwarehousecd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Sortwarehousecd> clsList = new ArrayList<Sortwarehousecd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Sortwarehousecd> groupOf(String groupName) {
            return new ArrayList<Sortwarehousecd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保税拠点コード
     */
    public enum Hozeiwarehousecd implements CDef {
        /** $7010: 大井保税センター */
        $7010("7010", "$7010", emptyStrings())
        ,
        /** $7020: 六甲保税センター */
        $7020("7020", "$7020", emptyStrings())
        ;
        private static final Map<String, Hozeiwarehousecd> _codeClsMap = new HashMap<String, Hozeiwarehousecd>();
        private static final Map<String, Hozeiwarehousecd> _nameClsMap = new HashMap<String, Hozeiwarehousecd>();
        static {
            for (Hozeiwarehousecd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Hozeiwarehousecd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Hozeiwarehousecd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Hozeiwarehousecd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Hozeiwarehousecd) { return OptionalThing.of((Hozeiwarehousecd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Hozeiwarehousecd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Hozeiwarehousecd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Hozeiwarehousecd) { return (Hozeiwarehousecd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Hozeiwarehousecd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Hozeiwarehousecd> listAll() {
            return new ArrayList<Hozeiwarehousecd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Hozeiwarehousecd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Hozeiwarehousecd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Hozeiwarehousecd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Hozeiwarehousecd> clsList = new ArrayList<Hozeiwarehousecd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Hozeiwarehousecd> groupOf(String groupName) {
            return new ArrayList<Hozeiwarehousecd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 返品検品帳票出力定義（ＴＰＣ）
     */
    public enum PrinterdefH002 implements CDef {
        /** $8351: 返品検品帳票出力定義（ＴＰＣ）（札幌用） */
        $8351("8351", "$8351", emptyStrings())
        ,
        /** $8075: 返品検品帳票出力定義（ＴＰＣ）（釧路用） */
        $8075("8075", "$8075", emptyStrings())
        ,
        /** $8037: 返品検品帳票出力定義（ＴＰＣ）（盛岡用） */
        $8037("8037", "$8037", emptyStrings())
        ,
        /** $8002: 返品検品帳票出力定義（ＴＰＣ）（仙台用） */
        $8002("8002", "$8002", emptyStrings())
        ,
        /** $8004: 返品検品帳票出力定義（ＴＰＣ）（水戸用） */
        $8004("8004", "$8004", emptyStrings())
        ,
        /** $8005: 返品検品帳票出力定義（ＴＰＣ）（宇都宮用） */
        $8005("8005", "$8005", emptyStrings())
        ,
        /** $8006: 返品検品帳票出力定義（ＴＰＣ）（高崎用） */
        $8006("8006", "$8006", emptyStrings())
        ,
        /** $8034: 返品検品帳票出力定義（ＴＰＣ）（埼玉用） */
        $8034("8034", "$8034", emptyStrings())
        ,
        /** $8009: 返品検品帳票出力定義（ＴＰＣ）（新座用） */
        $8009("8009", "$8009", emptyStrings())
        ,
        /** $8356: 返品検品帳票出力定義（ＴＰＣ）（千葉用） */
        $8356("8356", "$8356", emptyStrings())
        ,
        /** $8352: 返品検品帳票出力定義（ＴＰＣ）（羽田用） */
        $8352("8352", "$8352", emptyStrings())
        ,
        /** $8357: 返品検品帳票出力定義（ＴＰＣ）（東京用） */
        $8357("8357", "$8357", emptyStrings())
        ,
        /** $8042: 返品検品帳票出力定義（ＴＰＣ）（小倉用） */
        $8042("8042", "$8042", emptyStrings())
        ,
        /** $8044: 返品検品帳票出力定義（ＴＰＣ）（神奈川用） */
        $8044("8044", "$8044", emptyStrings())
        ,
        /** $8039: 返品検品帳票出力定義（ＴＰＣ）（新潟用） */
        $8039("8039", "$8039", emptyStrings())
        ,
        /** $8077: 返品検品帳票出力定義（ＴＰＣ）（松本用） */
        $8077("8077", "$8077", emptyStrings())
        ,
        /** $8012: 返品検品帳票出力定義（ＴＰＣ）（金沢用） */
        $8012("8012", "$8012", emptyStrings())
        ,
        /** $8045: 返品検品帳票出力定義（ＴＰＣ）（浜松用） */
        $8045("8045", "$8045", emptyStrings())
        ,
        /** $8011: 返品検品帳票出力定義（ＴＰＣ）（名古屋用） */
        $8011("8011", "$8011", emptyStrings())
        ,
        /** $8355: 返品検品帳票出力定義（ＴＰＣ）（大阪用） */
        $8355("8355", "$8355", emptyStrings())
        ,
        /** $8067: 返品検品帳票出力定義（ＴＰＣ）（泉大津用） */
        $8067("8067", "$8067", emptyStrings())
        ,
        /** $8016: 返品検品帳票出力定義（ＴＰＣ）（神戸用） */
        $8016("8016", "$8016", emptyStrings())
        ,
        /** $8018: 返品検品帳票出力定義（ＴＰＣ）（米子用） */
        $8018("8018", "$8018", emptyStrings())
        ,
        /** $8017: 返品検品帳票出力定義（ＴＰＣ）（岡山用） */
        $8017("8017", "$8017", emptyStrings())
        ,
        /** $8019: 返品検品帳票出力定義（ＴＰＣ）（広島用） */
        $8019("8019", "$8019", emptyStrings())
        ,
        /** $8020: 返品検品帳票出力定義（ＴＰＣ）（高松用） */
        $8020("8020", "$8020", emptyStrings())
        ,
        /** $8318: 返品検品帳票出力定義（ＴＰＣ）（福岡用） */
        $8318("8318", "$8318", emptyStrings())
        ,
        /** $8025: 返品検品帳票出力定義（ＴＰＣ）（鹿児島用） */
        $8025("8025", "$8025", emptyStrings())
        ,
        /** $8027: 返品検品帳票出力定義（ＴＰＣ）（沖縄用） */
        $8027("8027", "$8027", emptyStrings())
        ,
        /** $8036: 返品検品帳票出力定義（ＴＰＣ）（青森用） */
        $8036("8036", "$8036", emptyStrings())
        ,
        /** $8499: 返品検品帳票出力定義（ＴＰＣ）（ＣＡＰ用） */
        $8499("8499", "$8499", emptyStrings())
        ,
        /** $8359: 返品検品帳票出力定義（ＴＰＣ）（京都用） */
        $8359("8359", "$8359", emptyStrings())
        ,
        /** $8460: 返品検品帳票出力定義（ＴＰＣ）（大井東用） */
        $8460("8460", "$8460", emptyStrings())
        ,
        /** $8010: 返品検品帳票出力定義（ＴＰＣ）（埼玉配送用） */
        $8010("8010", "$8010", emptyStrings())
        ;
        private static final Map<String, PrinterdefH002> _codeClsMap = new HashMap<String, PrinterdefH002>();
        private static final Map<String, PrinterdefH002> _nameClsMap = new HashMap<String, PrinterdefH002>();
        static {
            for (PrinterdefH002 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrinterdefH002(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrinterdefH002; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefH002> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrinterdefH002) { return OptionalThing.of((PrinterdefH002)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrinterdefH002> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefH002 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrinterdefH002) { return (PrinterdefH002)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrinterdefH002 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrinterdefH002> listAll() {
            return new ArrayList<PrinterdefH002>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrinterdefH002> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrinterdefH002." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrinterdefH002> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrinterdefH002> clsList = new ArrayList<PrinterdefH002>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrinterdefH002> groupOf(String groupName) {
            return new ArrayList<PrinterdefH002>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 帳票フォーム表示名称
     */
    public enum Reportformname implements CDef {
        /** $tsn_AdoptInvDifREPORT2: 引取場在庫調査差異リスト */
        $tsn_AdoptInvDifREPORT2("tsn_AdoptInvDifREPORT2", "$tsn_AdoptInvDifREPORT2", emptyStrings())
        ,
        /** $tsn_AdoptInvREPORT2: 引取場在庫調査指示リスト */
        $tsn_AdoptInvREPORT2("tsn_AdoptInvREPORT2", "$tsn_AdoptInvREPORT2", emptyStrings())
        ,
        /** $tsn_AdoptPackedDifREPORT2: 製造年月日調査逆転リスト（引取場） */
        $tsn_AdoptPackedDifREPORT2("tsn_AdoptPackedDifREPORT2", "$tsn_AdoptPackedDifREPORT2", emptyStrings())
        ,
        /** $tsn_AlcActualREPORT2: 引当不能リスト（実績用） */
        $tsn_AlcActualREPORT2("tsn_AlcActualREPORT2", "$tsn_AlcActualREPORT2", emptyStrings())
        ,
        /** $tsn_AlcEntryREPORT2: 引当不能リスト（記入用） */
        $tsn_AlcEntryREPORT2("tsn_AlcEntryREPORT2", "$tsn_AlcEntryREPORT2", emptyStrings())
        ,
        /** $tsn_BadItemCaseLabelREPORT2: 不適品ラベル */
        $tsn_BadItemCaseLabelREPORT2("tsn_BadItemCaseLabelREPORT2", "$tsn_BadItemCaseLabelREPORT2", emptyStrings())
        ,
        /** $tsn_BadItemCaseListREPORT2: 不適品ラベル作成枚数確認リスト */
        $tsn_BadItemCaseListREPORT2("tsn_BadItemCaseListREPORT2", "$tsn_BadItemCaseListREPORT2", emptyStrings())
        ,
        /** $tsn_BadItemDiffListREPORT2: 不適品ラベル差異リスト */
        $tsn_BadItemDiffListREPORT2("tsn_BadItemDiffListREPORT2", "$tsn_BadItemDiffListREPORT2", emptyStrings())
        ,
        /** $tsn_BusinessTimeChartREPORT2: 業務別タイムチャート */
        $tsn_BusinessTimeChartREPORT2("tsn_BusinessTimeChartREPORT2", "$tsn_BusinessTimeChartREPORT2", emptyStrings())
        ,
        /** $tsn_CaseLabelREPORT2: ケースはり紙 */
        $tsn_CaseLabelREPORT2("tsn_CaseLabelREPORT2", "$tsn_CaseLabelREPORT2", emptyStrings())
        ,
        /** $tsn_FlexPickListREPORT2: 融通山出しリスト */
        $tsn_FlexPickListREPORT2("tsn_FlexPickListREPORT2", "$tsn_FlexPickListREPORT2", emptyStrings())
        ,
        /** $tsn_GdItmInvEntDmREPORT2: 適品たな卸確認リスト（国産たばこ） */
        $tsn_GdItmInvEntDmREPORT2("tsn_GdItmInvEntDmREPORT2", "$tsn_GdItmInvEntDmREPORT2", emptyStrings())
        ,
        /** $tsn_GdItmInvEntFrREPORT2: 適品たな卸確認リスト（輸入たばこ） */
        $tsn_GdItmInvEntFrREPORT2("tsn_GdItmInvEntFrREPORT2", "$tsn_GdItmInvEntFrREPORT2", emptyStrings())
        ,
        /** $tsn_GdItmInvntryDmREPORT2: 適品たな卸表（国産たばこ） */
        $tsn_GdItmInvntryDmREPORT2("tsn_GdItmInvntryDmREPORT2", "$tsn_GdItmInvntryDmREPORT2", emptyStrings())
        ,
        /** $tsn_GdItmInvntryFrREPORT2: 適品たな卸表（輸入たばこ） */
        $tsn_GdItmInvntryFrREPORT2("tsn_GdItmInvntryFrREPORT2", "$tsn_GdItmInvntryFrREPORT2", emptyStrings())
        ,
        /** $tsn_GdItmStkInvDmREPORT2: 適品在庫調査確認リスト（国産たばこ） */
        $tsn_GdItmStkInvDmREPORT2("tsn_GdItmStkInvDmREPORT2", "$tsn_GdItmStkInvDmREPORT2", emptyStrings())
        ,
        /** $tsn_GdItmStkInvFrREPORT2: 適品在庫調査確認リスト（輸入たばこ） */
        $tsn_GdItmStkInvFrREPORT2("tsn_GdItmStkInvFrREPORT2", "$tsn_GdItmStkInvFrREPORT2", emptyStrings())
        ,
        /** $tsn_GdItmStockDmREPORT2: 適品在庫調査表（国産たばこ） */
        $tsn_GdItmStockDmREPORT2("tsn_GdItmStockDmREPORT2", "$tsn_GdItmStockDmREPORT2", emptyStrings())
        ,
        /** $tsn_GdItmStockFrREPORT2: 適品在庫調査表（輸入たばこ） */
        $tsn_GdItmStockFrREPORT2("tsn_GdItmStockFrREPORT2", "$tsn_GdItmStockFrREPORT2", emptyStrings())
        ,
        /** $tsn_GoodItemDiffREPORT2: 適品過不足報告書 */
        $tsn_GoodItemDiffREPORT2("tsn_GoodItemDiffREPORT2", "$tsn_GoodItemDiffREPORT2", emptyStrings())
        ,
        /** $tsn_GoodItemHisReREPORT2: 適品在庫過不足履歴簿 */
        $tsn_GoodItemHisReREPORT2("tsn_GoodItemHisReREPORT2", "$tsn_GoodItemHisReREPORT2", emptyStrings())
        ,
        /** $tsn_InvDifREPORT2: 保管場在庫調査差異リスト */
        $tsn_InvDifREPORT2("tsn_InvDifREPORT2", "$tsn_InvDifREPORT2", emptyStrings())
        ,
        /** $tsn_InventoryREPORT2: 保管場在庫調査指示リスト */
        $tsn_InventoryREPORT2("tsn_InventoryREPORT2", "$tsn_InventoryREPORT2", emptyStrings())
        ,
        /** $tsn_KasiInvDifREPORT2: かし品在庫調査差異リスト */
        $tsn_KasiInvDifREPORT2("tsn_KasiInvDifREPORT2", "$tsn_KasiInvDifREPORT2", emptyStrings())
        ,
        /** $tsn_KasiInvREPORT2: かし品在庫調査指示リスト */
        $tsn_KasiInvREPORT2("tsn_KasiInvREPORT2", "$tsn_KasiInvREPORT2", emptyStrings())
        ,
        /** $tsn_LineDiffrenceREPORT2: ライン間開差チェックリスト */
        $tsn_LineDiffrenceREPORT2("tsn_LineDiffrenceREPORT2", "$tsn_LineDiffrenceREPORT2", emptyStrings())
        ,
        /** $tsn_NoGdItmStkInvREPORT2: 不適品在庫調査表 */
        $tsn_NoGdItmStkInvREPORT2("tsn_NoGdItmStkInvREPORT2", "$tsn_NoGdItmStkInvREPORT2", emptyStrings())
        ,
        /** $tsn_NoGoodItemDiffDmREPORT2: 国産たばこ不適品過不足報告書 */
        $tsn_NoGoodItemDiffDmREPORT2("tsn_NoGoodItemDiffDmREPORT2", "$tsn_NoGoodItemDiffDmREPORT2", emptyStrings())
        ,
        /** $tsn_NoGoodItemDiffFrREPORT2: 輸入たばこ不適品過不足報告書 */
        $tsn_NoGoodItemDiffFrREPORT2("tsn_NoGoodItemDiffFrREPORT2", "$tsn_NoGoodItemDiffFrREPORT2", emptyStrings())
        ,
        /** $tsn_NoGoodItemHisReREPORT2: 不適品在庫過不足履歴簿 */
        $tsn_NoGoodItemHisReREPORT2("tsn_NoGoodItemHisReREPORT2", "$tsn_NoGoodItemHisReREPORT2", emptyStrings())
        ,
        /** $tsn_NsMonthChkREPORT2: 製品移動（月替り・デ変）確認リスト */
        $tsn_NsMonthChkREPORT2("tsn_NsMonthChkREPORT2", "$tsn_NsMonthChkREPORT2", emptyStrings())
        ,
        /** $tsn_PackedDifConfREPORT2: 製造年月日開差確認リスト */
        $tsn_PackedDifConfREPORT2("tsn_PackedDifConfREPORT2", "$tsn_PackedDifConfREPORT2", emptyStrings())
        ,
        /** $tsn_PackedListREPORT2: 製造年月日一覧表 */
        $tsn_PackedListREPORT2("tsn_PackedListREPORT2", "$tsn_PackedListREPORT2", emptyStrings())
        ,
        /** $tsn_PalletCatalogREPORT2: パレットはり紙一覧表 */
        $tsn_PalletCatalogREPORT2("tsn_PalletCatalogREPORT2", "$tsn_PalletCatalogREPORT2", emptyStrings())
        ,
        /** $tsn_PalletLabelREPORT2: パレットはり紙 */
        $tsn_PalletLabelREPORT2("tsn_PalletLabelREPORT2", "$tsn_PalletLabelREPORT2", emptyStrings())
        ,
        /** $tsn_PickCatalogREPORT2: 山出し一覧表 */
        $tsn_PickCatalogREPORT2("tsn_PickCatalogREPORT2", "$tsn_PickCatalogREPORT2", emptyStrings())
        ,
        /** $tsn_RackMoveListREPORT2: ラック間製品移動確認リスト */
        $tsn_RackMoveListREPORT2("tsn_RackMoveListREPORT2", "$tsn_RackMoveListREPORT2", emptyStrings())
        ,
        /** $tsn_RcvReverseMonREPORT2: 製造年月逆転リスト（入庫） */
        $tsn_RcvReverseMonREPORT2("tsn_RcvReverseMonREPORT2", "$tsn_RcvReverseMonREPORT2", emptyStrings())
        ,
        /** $tsn_RcvReverseREPORT2: 製造年月日逆転リスト（入庫） */
        $tsn_RcvReverseREPORT2("tsn_RcvReverseREPORT2", "$tsn_RcvReverseREPORT2", emptyStrings())
        ,
        /** $tsn_ReceivePlanREPORT2: 格納先予定リスト */
        $tsn_ReceivePlanREPORT2("tsn_ReceivePlanREPORT2", "$tsn_ReceivePlanREPORT2", emptyStrings())
        ,
        /** $tsn_ReverStockListREPORT2: 逆転補充リスト */
        $tsn_ReverStockListREPORT2("tsn_ReverStockListREPORT2", "$tsn_ReverStockListREPORT2", emptyStrings())
        ,
        /** $tsn_ReverseSOREPORT2: 製造年月日逆転リスト（山出し） */
        $tsn_ReverseSOREPORT2("tsn_ReverseSOREPORT2", "$tsn_ReverseSOREPORT2", emptyStrings())
        ,
        /** $tsn_RtnGoodItemListREPORT2: 返品適品チェックリスト */
        $tsn_RtnGoodItemListREPORT2("tsn_RtnGoodItemListREPORT2", "$tsn_RtnGoodItemListREPORT2", emptyStrings())
        ,
        /** $tsn_SortLocPackedDifREPORT2: 製造年月日調査逆転リスト（仕分場） */
        $tsn_SortLocPackedDifREPORT2("tsn_SortLocPackedDifREPORT2", "$tsn_SortLocPackedDifREPORT2", emptyStrings())
        ,
        /** $tsn_SortPackedDifREPORT2: ライン間開差チェックリスト（在庫調査） */
        $tsn_SortPackedDifREPORT2("tsn_SortPackedDifREPORT2", "$tsn_SortPackedDifREPORT2", emptyStrings())
        ,
        /** $tsn_TracePicklistREPORT2: 山出しリスト（再印刷） */
        $tsn_TracePicklistREPORT2("tsn_TracePicklistREPORT2", "$tsn_TracePicklistREPORT2", emptyStrings())
        ,
        /** $tsn_TracePicklistSyncREPORT2: 山出しリスト */
        $tsn_TracePicklistSyncREPORT2("tsn_TracePicklistSyncREPORT2", "$tsn_TracePicklistSyncREPORT2", emptyStrings())
        ,
        /** $tsn_TraceSortInvDifREPORT2: 仕分場在庫調査差異リスト */
        $tsn_TraceSortInvDifREPORT2("tsn_TraceSortInvDifREPORT2", "$tsn_TraceSortInvDifREPORT2", emptyStrings())
        ,
        /** $tsn_TraceSortInvREPORT2: 仕分場在庫調査指示リスト */
        $tsn_TraceSortInvREPORT2("tsn_TraceSortInvREPORT2", "$tsn_TraceSortInvREPORT2", emptyStrings())
        ,
        /** $tsn_WorkerTimeChartREPORT2: 作業者別タイムチャート */
        $tsn_WorkerTimeChartREPORT2("tsn_WorkerTimeChartREPORT2", "$tsn_WorkerTimeChartREPORT2", emptyStrings())
        ;
        private static final Map<String, Reportformname> _codeClsMap = new HashMap<String, Reportformname>();
        private static final Map<String, Reportformname> _nameClsMap = new HashMap<String, Reportformname>();
        static {
            for (Reportformname value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Reportformname(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Reportformname; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Reportformname> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Reportformname) { return OptionalThing.of((Reportformname)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Reportformname> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Reportformname codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Reportformname) { return (Reportformname)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Reportformname nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Reportformname> listAll() {
            return new ArrayList<Reportformname>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Reportformname> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Reportformname." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Reportformname> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Reportformname> clsList = new ArrayList<Reportformname>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Reportformname> groupOf(String groupName) {
            return new ArrayList<Reportformname>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 業務名称
     */
    public enum Taskname implements CDef {
        /** $PRINTERDEF_H002: 返品検品 */
        $PRINTERDEF_H002("PRINTERDEF_H002", "$PRINTERDEF_H002", emptyStrings())
        ,
        /** $PRINTERDEF_N002: 受入検品 */
        $PRINTERDEF_N002("PRINTERDEF_N002", "$PRINTERDEF_N002", emptyStrings())
        ,
        /** $PRINTERDEF_N004: ケース検品 */
        $PRINTERDEF_N004("PRINTERDEF_N004", "$PRINTERDEF_N004", emptyStrings())
        ,
        /** $PRINTERDEF_S001: 山出し作業 */
        $PRINTERDEF_S001("PRINTERDEF_S001", "$PRINTERDEF_S001", emptyStrings())
        ,
        /** $PRINTERDEF_S0031: 製品移動（仕分場） */
        $PRINTERDEF_S0031("PRINTERDEF_S0031", "$PRINTERDEF_S0031", emptyStrings())
        ,
        /** $PRINTERDEF_S0032: 製品移動（引取場） */
        $PRINTERDEF_S0032("PRINTERDEF_S0032", "$PRINTERDEF_S0032", emptyStrings())
        ,
        /** $PRINTERDEF_S0033: 製品移動（融通） */
        $PRINTERDEF_S0033("PRINTERDEF_S0033", "$PRINTERDEF_S0033", emptyStrings())
        ,
        /** $PRINTERDEF_S0034: 製品移動（その他） */
        $PRINTERDEF_S0034("PRINTERDEF_S0034", "$PRINTERDEF_S0034", emptyStrings())
        ,
        /** $PRINTERDEF_W001: うしろ補充 */
        $PRINTERDEF_W001("PRINTERDEF_W001", "$PRINTERDEF_W001", emptyStrings())
        ,
        /** $PRINTERDEF_W002: まえ補充 */
        $PRINTERDEF_W002("PRINTERDEF_W002", "$PRINTERDEF_W002", emptyStrings())
        ,
        /** $PRINTERDEF_W003: 取出 */
        $PRINTERDEF_W003("PRINTERDEF_W003", "$PRINTERDEF_W003", emptyStrings())
        ,
        /** $PRINTERDEF_Z004: 仕分場在庫調査 */
        $PRINTERDEF_Z004("PRINTERDEF_Z004", "$PRINTERDEF_Z004", emptyStrings())
        ,
        /** $PRINTERDEF_Z005: 分割はい替 */
        $PRINTERDEF_Z005("PRINTERDEF_Z005", "$PRINTERDEF_Z005", emptyStrings())
        ,
        /** $PRINTERDEF_Z008: 引取場在庫調査 */
        $PRINTERDEF_Z008("PRINTERDEF_Z008", "$PRINTERDEF_Z008", emptyStrings())
        ;
        private static final Map<String, Taskname> _codeClsMap = new HashMap<String, Taskname>();
        private static final Map<String, Taskname> _nameClsMap = new HashMap<String, Taskname>();
        static {
            for (Taskname value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Taskname(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Taskname; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Taskname> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Taskname) { return OptionalThing.of((Taskname)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Taskname> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Taskname codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Taskname) { return (Taskname)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Taskname nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Taskname> listAll() {
            return new ArrayList<Taskname>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Taskname> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Taskname." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Taskname> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Taskname> clsList = new ArrayList<Taskname>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Taskname> groupOf(String groupName) {
            return new ArrayList<Taskname>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 情報元区分
     */
    public enum Whinvkbn implements CDef {
        /** $0: 保管場 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: パレット移動履歴 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 仕分場 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 引取場 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Whinvkbn> _codeClsMap = new HashMap<String, Whinvkbn>();
        private static final Map<String, Whinvkbn> _nameClsMap = new HashMap<String, Whinvkbn>();
        static {
            for (Whinvkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Whinvkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Whinvkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Whinvkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Whinvkbn) { return OptionalThing.of((Whinvkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Whinvkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Whinvkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Whinvkbn) { return (Whinvkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Whinvkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Whinvkbn> listAll() {
            return new ArrayList<Whinvkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Whinvkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Whinvkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Whinvkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Whinvkbn> clsList = new ArrayList<Whinvkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Whinvkbn> groupOf(String groupName) {
            return new ArrayList<Whinvkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 拠点別在庫照会明細取得処理区分
     */
    public enum Procflg implements CDef {
        /** $0: 処理開始 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 登録 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 処理終了 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Procflg> _codeClsMap = new HashMap<String, Procflg>();
        private static final Map<String, Procflg> _nameClsMap = new HashMap<String, Procflg>();
        static {
            for (Procflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Procflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Procflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Procflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Procflg) { return OptionalThing.of((Procflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Procflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Procflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Procflg) { return (Procflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Procflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Procflg> listAll() {
            return new ArrayList<Procflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Procflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Procflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Procflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Procflg> clsList = new ArrayList<Procflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Procflg> groupOf(String groupName) {
            return new ArrayList<Procflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 銘柄区分
     */
    public enum SyhnKbn implements CDef {
        /** $A000: 国産 */
        $A000("A000", "$A000", emptyStrings())
        ,
        /** $0001: 輸入 */
        $0001("0001", "$0001", emptyStrings())
        ,
        /** $0000: 商品 */
        $0000("0000", "$0000", emptyStrings())
        ;
        private static final Map<String, SyhnKbn> _codeClsMap = new HashMap<String, SyhnKbn>();
        private static final Map<String, SyhnKbn> _nameClsMap = new HashMap<String, SyhnKbn>();
        static {
            for (SyhnKbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SyhnKbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SyhnKbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SyhnKbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SyhnKbn) { return OptionalThing.of((SyhnKbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SyhnKbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SyhnKbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SyhnKbn) { return (SyhnKbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SyhnKbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SyhnKbn> listAll() {
            return new ArrayList<SyhnKbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SyhnKbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SyhnKbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SyhnKbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SyhnKbn> clsList = new ArrayList<SyhnKbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SyhnKbn> groupOf(String groupName) {
            return new ArrayList<SyhnKbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * パレット種別
     */
    public enum Pallettype implements CDef {
        /** $0: 単品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 端数 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Pallettype> _codeClsMap = new HashMap<String, Pallettype>();
        private static final Map<String, Pallettype> _nameClsMap = new HashMap<String, Pallettype>();
        static {
            for (Pallettype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Pallettype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Pallettype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pallettype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Pallettype) { return OptionalThing.of((Pallettype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pallettype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Pallettype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Pallettype) { return (Pallettype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Pallettype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Pallettype> listAll() {
            return new ArrayList<Pallettype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Pallettype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Pallettype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Pallettype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Pallettype> clsList = new ArrayList<Pallettype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Pallettype> groupOf(String groupName) {
            return new ArrayList<Pallettype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫調査区分
     */
    public enum InventoryInstKbn implements CDef {
        /** $00: 保管場 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 仕分場(開始) */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 仕分場(中間) */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 仕分場(終了) */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 引取場 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: かし品 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 不適品 */
        $06("06", "$06", emptyStrings())
        ;
        private static final Map<String, InventoryInstKbn> _codeClsMap = new HashMap<String, InventoryInstKbn>();
        private static final Map<String, InventoryInstKbn> _nameClsMap = new HashMap<String, InventoryInstKbn>();
        static {
            for (InventoryInstKbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InventoryInstKbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InventoryInstKbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryInstKbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InventoryInstKbn) { return OptionalThing.of((InventoryInstKbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryInstKbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InventoryInstKbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InventoryInstKbn) { return (InventoryInstKbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InventoryInstKbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InventoryInstKbn> listAll() {
            return new ArrayList<InventoryInstKbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InventoryInstKbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InventoryInstKbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InventoryInstKbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InventoryInstKbn> clsList = new ArrayList<InventoryInstKbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InventoryInstKbn> groupOf(String groupName) {
            return new ArrayList<InventoryInstKbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出力帳票
     */
    public enum InventoryReport implements CDef {
        /** $00: 在庫調査表 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 適品過不足報告書 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 不適品過不足報告書 */
        $02("02", "$02", emptyStrings())
        ;
        private static final Map<String, InventoryReport> _codeClsMap = new HashMap<String, InventoryReport>();
        private static final Map<String, InventoryReport> _nameClsMap = new HashMap<String, InventoryReport>();
        static {
            for (InventoryReport value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InventoryReport(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InventoryReport; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryReport> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InventoryReport) { return OptionalThing.of((InventoryReport)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryReport> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InventoryReport codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InventoryReport) { return (InventoryReport)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InventoryReport nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InventoryReport> listAll() {
            return new ArrayList<InventoryReport>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InventoryReport> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InventoryReport." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InventoryReport> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InventoryReport> clsList = new ArrayList<InventoryReport>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InventoryReport> groupOf(String groupName) {
            return new ArrayList<InventoryReport>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 山出し完了区分
     */
    public enum Completeflg implements CDef {
        /** $0: 未完了 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 山出し作業完了 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 引継検品完了 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Completeflg> _codeClsMap = new HashMap<String, Completeflg>();
        private static final Map<String, Completeflg> _nameClsMap = new HashMap<String, Completeflg>();
        static {
            for (Completeflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Completeflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Completeflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Completeflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Completeflg) { return OptionalThing.of((Completeflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Completeflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Completeflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Completeflg) { return (Completeflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Completeflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Completeflg> listAll() {
            return new ArrayList<Completeflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Completeflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Completeflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Completeflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Completeflg> clsList = new ArrayList<Completeflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Completeflg> groupOf(String groupName) {
            return new ArrayList<Completeflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 特定品目ロケフラグ
     */
    public enum Oneitemonlyflg implements CDef {
        /** $0: 共用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 特定品目専用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Oneitemonlyflg> _codeClsMap = new HashMap<String, Oneitemonlyflg>();
        private static final Map<String, Oneitemonlyflg> _nameClsMap = new HashMap<String, Oneitemonlyflg>();
        static {
            for (Oneitemonlyflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Oneitemonlyflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Oneitemonlyflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Oneitemonlyflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Oneitemonlyflg) { return OptionalThing.of((Oneitemonlyflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Oneitemonlyflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Oneitemonlyflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Oneitemonlyflg) { return (Oneitemonlyflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Oneitemonlyflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Oneitemonlyflg> listAll() {
            return new ArrayList<Oneitemonlyflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Oneitemonlyflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Oneitemonlyflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Oneitemonlyflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Oneitemonlyflg> clsList = new ArrayList<Oneitemonlyflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Oneitemonlyflg> groupOf(String groupName) {
            return new ArrayList<Oneitemonlyflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 特定荷主ロケフラグ
     */
    public enum Oneowneronlyflg implements CDef {
        /** $0: 共用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 特定荷主専用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Oneowneronlyflg> _codeClsMap = new HashMap<String, Oneowneronlyflg>();
        private static final Map<String, Oneowneronlyflg> _nameClsMap = new HashMap<String, Oneowneronlyflg>();
        static {
            for (Oneowneronlyflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Oneowneronlyflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Oneowneronlyflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Oneowneronlyflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Oneowneronlyflg) { return OptionalThing.of((Oneowneronlyflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Oneowneronlyflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Oneowneronlyflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Oneowneronlyflg) { return (Oneowneronlyflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Oneowneronlyflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Oneowneronlyflg> listAll() {
            return new ArrayList<Oneowneronlyflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Oneowneronlyflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Oneowneronlyflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Oneowneronlyflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Oneowneronlyflg> clsList = new ArrayList<Oneowneronlyflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Oneowneronlyflg> groupOf(String groupName) {
            return new ArrayList<Oneowneronlyflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保管タイプ
     */
    public enum Picktype implements CDef {
        /** $CART: 台車 */
        $CART("CART", "$CART", emptyStrings())
        ,
        /** $CS: 中量棚ケース */
        $CS("CS", "$CS", emptyStrings())
        ,
        /** $FORK: フォーク */
        $FORK("FORK", "$FORK", emptyStrings())
        ,
        /** $NSRAK: ネスラック */
        $NSRAK("NSRAK", "$NSRAK", emptyStrings())
        ,
        /** $PIECE: 中量棚バラ */
        $PIECE("PIECE", "$PIECE", emptyStrings())
        ,
        /** $PLRAK: ＰＬラック */
        $PLRAK("PLRAK", "$PLRAK", emptyStrings())
        ,
        /** $UPPER: 中量棚上段 */
        $UPPER("UPPER", "$UPPER", emptyStrings())
        ,
        /** $ZN: ゾーン */
        $ZN("ZN", "$ZN", emptyStrings())
        ;
        private static final Map<String, Picktype> _codeClsMap = new HashMap<String, Picktype>();
        private static final Map<String, Picktype> _nameClsMap = new HashMap<String, Picktype>();
        static {
            for (Picktype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Picktype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Picktype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Picktype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Picktype) { return OptionalThing.of((Picktype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Picktype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Picktype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Picktype) { return (Picktype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Picktype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Picktype> listAll() {
            return new ArrayList<Picktype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Picktype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Picktype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Picktype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Picktype> clsList = new ArrayList<Picktype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Picktype> groupOf(String groupName) {
            return new ArrayList<Picktype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷タイプ
     */
    public enum Rcvtype implements CDef {
        /** $STD: 通常入荷 */
        $STD("STD", "$STD", emptyStrings())
        ,
        /** $RETUN: 返品 */
        $RETUN("RETUN", "$RETUN", emptyStrings())
        ,
        /** $RGET: 取替 */
        $RGET("RGET", "$RGET", emptyStrings())
        ,
        /** $RPAIR: 修理品 */
        $RPAIR("RPAIR", "$RPAIR", emptyStrings())
        ,
        /** $MVIN: 移動入庫 */
        $MVIN("MVIN", "$MVIN", emptyStrings())
        ,
        /** $ETC: その他 */
        $ETC("ETC", "$ETC", emptyStrings())
        ,
        /** $PDMVI: 加工製品入荷 */
        $PDMVI("PDMVI", "$PDMVI", emptyStrings())
        ;
        private static final Map<String, Rcvtype> _codeClsMap = new HashMap<String, Rcvtype>();
        private static final Map<String, Rcvtype> _nameClsMap = new HashMap<String, Rcvtype>();
        static {
            for (Rcvtype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Rcvtype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Rcvtype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rcvtype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Rcvtype) { return OptionalThing.of((Rcvtype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rcvtype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Rcvtype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Rcvtype) { return (Rcvtype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Rcvtype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Rcvtype> listAll() {
            return new ArrayList<Rcvtype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Rcvtype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Rcvtype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Rcvtype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Rcvtype> clsList = new ArrayList<Rcvtype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Rcvtype> groupOf(String groupName) {
            return new ArrayList<Rcvtype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 倉庫タイプ
     */
    public enum Slottype implements CDef {
        /** $A12: Ａ棟ネスラック１２ＰＬ */
        $A12("A12", "$A12", emptyStrings())
        ,
        /** $A15: Ａ棟ネスラック１５ＰＬ */
        $A15("A15", "$A15", emptyStrings())
        ,
        /** $B: Ａ棟ＰＬラック */
        $B("B", "$B", emptyStrings())
        ,
        /** $C: Ａ棟中量上段ＰＬ */
        $C("C", "$C", emptyStrings())
        ,
        /** $CASE: ケース単位 */
        $CASE("CASE", "$CASE", emptyStrings())
        ,
        /** $D: Ａ棟中量ケース */
        $D("D", "$D", emptyStrings())
        ,
        /** $E: Ｂ棟平置き */
        $E("E", "$E", emptyStrings())
        ,
        /** $F: Ｃ棟平置き */
        $F("F", "$F", emptyStrings())
        ,
        /** $FULLP: フルパレット */
        $FULLP("FULLP", "$FULLP", emptyStrings())
        ,
        /** $G: Ａ棟中量バラ */
        $G("G", "$G", emptyStrings())
        ,
        /** $PALET: 端数パレット */
        $PALET("PALET", "$PALET", emptyStrings())
        ,
        /** $PIECE: バラ単位 */
        $PIECE("PIECE", "$PIECE", emptyStrings())
        ;
        private static final Map<String, Slottype> _codeClsMap = new HashMap<String, Slottype>();
        private static final Map<String, Slottype> _nameClsMap = new HashMap<String, Slottype>();
        static {
            for (Slottype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Slottype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Slottype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Slottype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Slottype) { return OptionalThing.of((Slottype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Slottype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Slottype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Slottype) { return (Slottype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Slottype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Slottype> listAll() {
            return new ArrayList<Slottype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Slottype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Slottype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Slottype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Slottype> clsList = new ArrayList<Slottype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Slottype> groupOf(String groupName) {
            return new ArrayList<Slottype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * CAP選択
     */
    public enum Capselect implements CDef {
        /** $0: 全体 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: CAP製品除く */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Capselect> _codeClsMap = new HashMap<String, Capselect>();
        private static final Map<String, Capselect> _nameClsMap = new HashMap<String, Capselect>();
        static {
            for (Capselect value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Capselect(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Capselect; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Capselect> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Capselect) { return OptionalThing.of((Capselect)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Capselect> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Capselect codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Capselect) { return (Capselect)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Capselect nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Capselect> listAll() {
            return new ArrayList<Capselect>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Capselect> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Capselect." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Capselect> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Capselect> clsList = new ArrayList<Capselect>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Capselect> groupOf(String groupName) {
            return new ArrayList<Capselect>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * かし品・国税還付品区分
     */
    public enum Kashikokuzeikubn implements CDef {
        /** $0: かし品・国税還付品以外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: かし品 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 国税還付品 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Kashikokuzeikubn> _codeClsMap = new HashMap<String, Kashikokuzeikubn>();
        private static final Map<String, Kashikokuzeikubn> _nameClsMap = new HashMap<String, Kashikokuzeikubn>();
        static {
            for (Kashikokuzeikubn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Kashikokuzeikubn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Kashikokuzeikubn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Kashikokuzeikubn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Kashikokuzeikubn) { return OptionalThing.of((Kashikokuzeikubn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Kashikokuzeikubn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Kashikokuzeikubn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Kashikokuzeikubn) { return (Kashikokuzeikubn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Kashikokuzeikubn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Kashikokuzeikubn> listAll() {
            return new ArrayList<Kashikokuzeikubn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Kashikokuzeikubn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Kashikokuzeikubn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Kashikokuzeikubn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Kashikokuzeikubn> clsList = new ArrayList<Kashikokuzeikubn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Kashikokuzeikubn> groupOf(String groupName) {
            return new ArrayList<Kashikokuzeikubn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * さしず有無区分
     */
    public enum Instructflg implements CDef {
        /** $0: さしず有 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 製品移動 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Instructflg> _codeClsMap = new HashMap<String, Instructflg>();
        private static final Map<String, Instructflg> _nameClsMap = new HashMap<String, Instructflg>();
        static {
            for (Instructflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Instructflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Instructflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Instructflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Instructflg) { return OptionalThing.of((Instructflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Instructflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Instructflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Instructflg) { return (Instructflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Instructflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Instructflg> listAll() {
            return new ArrayList<Instructflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Instructflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Instructflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Instructflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Instructflg> clsList = new ArrayList<Instructflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Instructflg> groupOf(String groupName) {
            return new ArrayList<Instructflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * パレットはり紙出力方式
     */
    public enum Palleteoutputtype implements CDef {
        /** $0: 未設定 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 都度出力 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 一括出力 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Palleteoutputtype> _codeClsMap = new HashMap<String, Palleteoutputtype>();
        private static final Map<String, Palleteoutputtype> _nameClsMap = new HashMap<String, Palleteoutputtype>();
        static {
            for (Palleteoutputtype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Palleteoutputtype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Palleteoutputtype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Palleteoutputtype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Palleteoutputtype) { return OptionalThing.of((Palleteoutputtype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Palleteoutputtype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Palleteoutputtype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Palleteoutputtype) { return (Palleteoutputtype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Palleteoutputtype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Palleteoutputtype> listAll() {
            return new ArrayList<Palleteoutputtype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Palleteoutputtype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Palleteoutputtype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Palleteoutputtype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Palleteoutputtype> clsList = new ArrayList<Palleteoutputtype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Palleteoutputtype> groupOf(String groupName) {
            return new ArrayList<Palleteoutputtype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * パレット分割区分
     */
    public enum Palletecuttingkbn implements CDef {
        /** $0: 未分割 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 分割済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Palletecuttingkbn> _codeClsMap = new HashMap<String, Palletecuttingkbn>();
        private static final Map<String, Palletecuttingkbn> _nameClsMap = new HashMap<String, Palletecuttingkbn>();
        static {
            for (Palletecuttingkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Palletecuttingkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Palletecuttingkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Palletecuttingkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Palletecuttingkbn) { return OptionalThing.of((Palletecuttingkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Palletecuttingkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Palletecuttingkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Palletecuttingkbn) { return (Palletecuttingkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Palletecuttingkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Palletecuttingkbn> listAll() {
            return new ArrayList<Palletecuttingkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Palletecuttingkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Palletecuttingkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Palletecuttingkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Palletecuttingkbn> clsList = new ArrayList<Palletecuttingkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Palletecuttingkbn> groupOf(String groupName) {
            return new ArrayList<Palletecuttingkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * フロントラック判定コード
     */
    public enum Frontrackcd implements CDef {
        /** $D: フロントラック判定コード */
        $D("D", "$D", emptyStrings())
        ;
        private static final Map<String, Frontrackcd> _codeClsMap = new HashMap<String, Frontrackcd>();
        private static final Map<String, Frontrackcd> _nameClsMap = new HashMap<String, Frontrackcd>();
        static {
            for (Frontrackcd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Frontrackcd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Frontrackcd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Frontrackcd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Frontrackcd) { return OptionalThing.of((Frontrackcd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Frontrackcd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Frontrackcd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Frontrackcd) { return (Frontrackcd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Frontrackcd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Frontrackcd> listAll() {
            return new ArrayList<Frontrackcd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Frontrackcd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Frontrackcd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Frontrackcd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Frontrackcd> clsList = new ArrayList<Frontrackcd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Frontrackcd> groupOf(String groupName) {
            return new ArrayList<Frontrackcd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * り災品区分
     */
    public enum Sufferflg implements CDef {
        /** $0: り災品以外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: り災品 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Sufferflg> _codeClsMap = new HashMap<String, Sufferflg>();
        private static final Map<String, Sufferflg> _nameClsMap = new HashMap<String, Sufferflg>();
        static {
            for (Sufferflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Sufferflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Sufferflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sufferflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Sufferflg) { return OptionalThing.of((Sufferflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sufferflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Sufferflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Sufferflg) { return (Sufferflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Sufferflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Sufferflg> listAll() {
            return new ArrayList<Sufferflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Sufferflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Sufferflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Sufferflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Sufferflg> clsList = new ArrayList<Sufferflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Sufferflg> groupOf(String groupName) {
            return new ArrayList<Sufferflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 一致/不一致区分
     */
    public enum Unmatchflg implements CDef {
        /** $0: 一致 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 不一致 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Unmatchflg> _codeClsMap = new HashMap<String, Unmatchflg>();
        private static final Map<String, Unmatchflg> _nameClsMap = new HashMap<String, Unmatchflg>();
        static {
            for (Unmatchflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Unmatchflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Unmatchflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Unmatchflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Unmatchflg) { return OptionalThing.of((Unmatchflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Unmatchflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Unmatchflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Unmatchflg) { return (Unmatchflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Unmatchflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Unmatchflg> listAll() {
            return new ArrayList<Unmatchflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Unmatchflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Unmatchflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Unmatchflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Unmatchflg> clsList = new ArrayList<Unmatchflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Unmatchflg> groupOf(String groupName) {
            return new ArrayList<Unmatchflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当不能理由区分
     */
    public enum Alcimrsnflg implements CDef {
        /** $0: 正常 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 引当制御マスタ未登録 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 月替り・デ変マスタ未登録 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ライン間開差有り */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 月替／デザイン切替有り */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 在庫不足 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: カートン跨り */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, Alcimrsnflg> _codeClsMap = new HashMap<String, Alcimrsnflg>();
        private static final Map<String, Alcimrsnflg> _nameClsMap = new HashMap<String, Alcimrsnflg>();
        static {
            for (Alcimrsnflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Alcimrsnflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Alcimrsnflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Alcimrsnflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Alcimrsnflg) { return OptionalThing.of((Alcimrsnflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Alcimrsnflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Alcimrsnflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Alcimrsnflg) { return (Alcimrsnflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Alcimrsnflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Alcimrsnflg> listAll() {
            return new ArrayList<Alcimrsnflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Alcimrsnflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Alcimrsnflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Alcimrsnflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Alcimrsnflg> clsList = new ArrayList<Alcimrsnflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Alcimrsnflg> groupOf(String groupName) {
            return new ArrayList<Alcimrsnflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 過不足発生場所
     */
    public enum Manyfewoccurarea implements CDef {
        /** $1: 保管場 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 引取場 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: かし品置場 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 国税還付品置場 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 仕分場 */
        $5("5", "$5", emptyStrings())
        ,
        /** $9: 返品場 */
        $9("9", "$9", emptyStrings())
        ,
        /** $99: ‐（ハイフン） */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, Manyfewoccurarea> _codeClsMap = new HashMap<String, Manyfewoccurarea>();
        private static final Map<String, Manyfewoccurarea> _nameClsMap = new HashMap<String, Manyfewoccurarea>();
        static {
            for (Manyfewoccurarea value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Manyfewoccurarea(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Manyfewoccurarea; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Manyfewoccurarea> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Manyfewoccurarea) { return OptionalThing.of((Manyfewoccurarea)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Manyfewoccurarea> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Manyfewoccurarea codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Manyfewoccurarea) { return (Manyfewoccurarea)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Manyfewoccurarea nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Manyfewoccurarea> listAll() {
            return new ArrayList<Manyfewoccurarea>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Manyfewoccurarea> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Manyfewoccurarea." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Manyfewoccurarea> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Manyfewoccurarea> clsList = new ArrayList<Manyfewoccurarea>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Manyfewoccurarea> groupOf(String groupName) {
            return new ArrayList<Manyfewoccurarea>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 過不足発生場所（画面表示用）
     */
    public enum Manyfewoccurareadisp implements CDef {
        /** $1: 保管場 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 引取場 */
        $2("2", "$2", emptyStrings())
        ,
        /** $5: 仕分場 */
        $5("5", "$5", emptyStrings())
        ;
        private static final Map<String, Manyfewoccurareadisp> _codeClsMap = new HashMap<String, Manyfewoccurareadisp>();
        private static final Map<String, Manyfewoccurareadisp> _nameClsMap = new HashMap<String, Manyfewoccurareadisp>();
        static {
            for (Manyfewoccurareadisp value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Manyfewoccurareadisp(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Manyfewoccurareadisp; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Manyfewoccurareadisp> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Manyfewoccurareadisp) { return OptionalThing.of((Manyfewoccurareadisp)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Manyfewoccurareadisp> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Manyfewoccurareadisp codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Manyfewoccurareadisp) { return (Manyfewoccurareadisp)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Manyfewoccurareadisp nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Manyfewoccurareadisp> listAll() {
            return new ArrayList<Manyfewoccurareadisp>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Manyfewoccurareadisp> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Manyfewoccurareadisp." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Manyfewoccurareadisp> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Manyfewoccurareadisp> clsList = new ArrayList<Manyfewoccurareadisp>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Manyfewoccurareadisp> groupOf(String groupName) {
            return new ArrayList<Manyfewoccurareadisp>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 月替・デザイン切替区分
     */
    public enum Designchg implements CDef {
        /** $0: 通常品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 月替り品 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: デザイン切替 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 月替/デザイン切替 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: ライン間開差有り */
        $4("4", "$4", emptyStrings())
        ,
        /** $9: 取消数量入力 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, Designchg> _codeClsMap = new HashMap<String, Designchg>();
        private static final Map<String, Designchg> _nameClsMap = new HashMap<String, Designchg>();
        static {
            for (Designchg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Designchg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Designchg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Designchg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Designchg) { return OptionalThing.of((Designchg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Designchg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Designchg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Designchg) { return (Designchg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Designchg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Designchg> listAll() {
            return new ArrayList<Designchg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Designchg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Designchg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Designchg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Designchg> clsList = new ArrayList<Designchg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Designchg> groupOf(String groupName) {
            return new ArrayList<Designchg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 差異有無
     */
    public enum Differenceumu implements CDef {
        /** $0: 全体 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 差異有り */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Differenceumu> _codeClsMap = new HashMap<String, Differenceumu>();
        private static final Map<String, Differenceumu> _nameClsMap = new HashMap<String, Differenceumu>();
        static {
            for (Differenceumu value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Differenceumu(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Differenceumu; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Differenceumu> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Differenceumu) { return OptionalThing.of((Differenceumu)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Differenceumu> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Differenceumu codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Differenceumu) { return (Differenceumu)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Differenceumu nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Differenceumu> listAll() {
            return new ArrayList<Differenceumu>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Differenceumu> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Differenceumu." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Differenceumu> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Differenceumu> clsList = new ArrayList<Differenceumu>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Differenceumu> groupOf(String groupName) {
            return new ArrayList<Differenceumu>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫識別
     */
    public enum Stockdistinction implements CDef {
        /** $0: 適品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $9: 不適品 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, Stockdistinction> _codeClsMap = new HashMap<String, Stockdistinction>();
        private static final Map<String, Stockdistinction> _nameClsMap = new HashMap<String, Stockdistinction>();
        static {
            for (Stockdistinction value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Stockdistinction(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Stockdistinction; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Stockdistinction> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Stockdistinction) { return OptionalThing.of((Stockdistinction)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Stockdistinction> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Stockdistinction codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Stockdistinction) { return (Stockdistinction)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Stockdistinction nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Stockdistinction> listAll() {
            return new ArrayList<Stockdistinction>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Stockdistinction> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Stockdistinction." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Stockdistinction> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Stockdistinction> clsList = new ArrayList<Stockdistinction>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Stockdistinction> groupOf(String groupName) {
            return new ArrayList<Stockdistinction>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業マスタ
     */
    public enum Workmaster implements CDef {
        /** $HK001L01: ログイン */
        $HK001L01("HK001L01", "$HK001L01", emptyStrings())
        ,
        /** $HK003L01: ログアウト確認 */
        $HK003L01("HK003L01", "$HK003L01", emptyStrings())
        ,
        /** $HN002L01: 受入検品 */
        $HN002L01("HN002L01", "$HN002L01", emptyStrings())
        ,
        /** $HN002L02: 受入検品 */
        $HN002L02("HN002L02", "$HN002L02", emptyStrings())
        ,
        /** $HN003L01: はり紙検品 */
        $HN003L01("HN003L01", "$HN003L01", emptyStrings())
        ,
        /** $HN003L02: はり紙検品 */
        $HN003L02("HN003L02", "$HN003L02", emptyStrings())
        ,
        /** $HN001L01: 入庫格納 */
        $HN001L01("HN001L01", "$HN001L01", emptyStrings())
        ,
        /** $HN001L02: 入庫格納 */
        $HN001L02("HN001L02", "$HN001L02", emptyStrings())
        ,
        /** $HN001L03: 入庫格納 */
        $HN001L03("HN001L03", "$HN001L03", emptyStrings())
        ,
        /** $HS001L01: 山出し作業 */
        $HS001L01("HS001L01", "$HS001L01", emptyStrings())
        ,
        /** $HS001L02: 山出し作業 */
        $HS001L02("HS001L02", "$HS001L02", emptyStrings())
        ,
        /** $HS002L01: 製品移動 */
        $HS002L01("HS002L01", "$HS002L01", emptyStrings())
        ,
        /** $HS002L02: 製品移動 */
        $HS002L02("HS002L02", "$HS002L02", emptyStrings())
        ,
        /** $HS003L01: 引継検品 */
        $HS003L01("HS003L01", "$HS003L01", emptyStrings())
        ,
        /** $HS003L02: 引継検品 */
        $HS003L02("HS003L02", "$HS003L02", emptyStrings())
        ,
        /** $HZ002L01: 在庫照会 */
        $HZ002L01("HZ002L01", "$HZ002L01", emptyStrings())
        ,
        /** $HZ002L02: 在庫照会 */
        $HZ002L02("HZ002L02", "$HZ002L02", emptyStrings())
        ,
        /** $HZ003L01: はい替 */
        $HZ003L01("HZ003L01", "$HZ003L01", emptyStrings())
        ,
        /** $HZ003L02: はい替 */
        $HZ003L02("HZ003L02", "$HZ003L02", emptyStrings())
        ,
        /** $HZ005L01: はい替（分割） */
        $HZ005L01("HZ005L01", "$HZ005L01", emptyStrings())
        ,
        /** $HZ005L02: はい替（分割） */
        $HZ005L02("HZ005L02", "$HZ005L02", emptyStrings())
        ,
        /** $HZ001L01: 保管場在庫調査 */
        $HZ001L01("HZ001L01", "$HZ001L01", emptyStrings())
        ,
        /** $HZ001L02: 保管場在庫調査 */
        $HZ001L02("HZ001L02", "$HZ001L02", emptyStrings())
        ,
        /** $HZ008L01: 引取場在庫調査 */
        $HZ008L01("HZ008L01", "$HZ008L01", emptyStrings())
        ,
        /** $HZ008L02: 引取場在庫調査 */
        $HZ008L02("HZ008L02", "$HZ008L02", emptyStrings())
        ,
        /** $HZ004L01: 仕分場在庫調査 */
        $HZ004L01("HZ004L01", "$HZ004L01", emptyStrings())
        ,
        /** $HZ004L02: 仕分場在庫調査 */
        $HZ004L02("HZ004L02", "$HZ004L02", emptyStrings())
        ,
        /** $HZ007L01: 国税還付品在庫調査 */
        $HZ007L01("HZ007L01", "$HZ007L01", emptyStrings())
        ,
        /** $HZ007L02: 国税還付品在庫調査 */
        $HZ007L02("HZ007L02", "$HZ007L02", emptyStrings())
        ,
        /** $HZ006L01: かし品在庫調査 */
        $HZ006L01("HZ006L01", "$HZ006L01", emptyStrings())
        ,
        /** $HZ006L02: かし品在庫調査 */
        $HZ006L02("HZ006L02", "$HZ006L02", emptyStrings())
        ,
        /** $TH002L01: 返品業務 */
        $TH002L01("TH002L01", "$TH002L01", emptyStrings())
        ,
        /** $TH002L02: 返品業務 */
        $TH002L02("TH002L02", "$TH002L02", emptyStrings())
        ;
        private static final Map<String, Workmaster> _codeClsMap = new HashMap<String, Workmaster>();
        private static final Map<String, Workmaster> _nameClsMap = new HashMap<String, Workmaster>();
        static {
            for (Workmaster value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Workmaster(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Workmaster; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Workmaster> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Workmaster) { return OptionalThing.of((Workmaster)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Workmaster> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Workmaster codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Workmaster) { return (Workmaster)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Workmaster nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Workmaster> listAll() {
            return new ArrayList<Workmaster>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Workmaster> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Workmaster." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Workmaster> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Workmaster> clsList = new ArrayList<Workmaster>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Workmaster> groupOf(String groupName) {
            return new ArrayList<Workmaster>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 山出しタイプ
     */
    public enum Picklisttype implements CDef {
        /** $1: 補充さしず */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Picklisttype> _codeClsMap = new HashMap<String, Picklisttype>();
        private static final Map<String, Picklisttype> _nameClsMap = new HashMap<String, Picklisttype>();
        static {
            for (Picklisttype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Picklisttype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Picklisttype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Picklisttype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Picklisttype) { return OptionalThing.of((Picklisttype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Picklisttype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Picklisttype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Picklisttype) { return (Picklisttype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Picklisttype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Picklisttype> listAll() {
            return new ArrayList<Picklisttype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Picklisttype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Picklisttype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Picklisttype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Picklisttype> clsList = new ArrayList<Picklisttype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Picklisttype> groupOf(String groupName) {
            return new ArrayList<Picklisttype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕分場在庫区分
     */
    public enum Sortzaikbn implements CDef {
        /** $0: ラック内 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 仕分済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Sortzaikbn> _codeClsMap = new HashMap<String, Sortzaikbn>();
        private static final Map<String, Sortzaikbn> _nameClsMap = new HashMap<String, Sortzaikbn>();
        static {
            for (Sortzaikbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Sortzaikbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Sortzaikbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortzaikbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Sortzaikbn) { return OptionalThing.of((Sortzaikbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sortzaikbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Sortzaikbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Sortzaikbn) { return (Sortzaikbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Sortzaikbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Sortzaikbn> listAll() {
            return new ArrayList<Sortzaikbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Sortzaikbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Sortzaikbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Sortzaikbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Sortzaikbn> clsList = new ArrayList<Sortzaikbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Sortzaikbn> groupOf(String groupName) {
            return new ArrayList<Sortzaikbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕分単位
     */
    public enum Sorttype implements CDef {
        /** $L1: L1 */
        $L1("L1", "$L1", emptyStrings())
        ,
        /** $L2: L2 */
        $L2("L2", "$L2", emptyStrings())
        ,
        /** $L3: L3 */
        $L3("L3", "$L3", emptyStrings())
        ,
        /** $L4: L4 */
        $L4("L4", "$L4", emptyStrings())
        ,
        /** $L5: L5 */
        $L5("L5", "$L5", emptyStrings())
        ,
        /** $L6: L6 */
        $L6("L6", "$L6", emptyStrings())
        ,
        /** $L7: L7 */
        $L7("L7", "$L7", emptyStrings())
        ,
        /** $L8: L8 */
        $L8("L8", "$L8", emptyStrings())
        ,
        /** $L9: L9 */
        $L9("L9", "$L9", emptyStrings())
        ,
        /** $B1: B1 */
        $B1("B1", "$B1", emptyStrings())
        ,
        /** $B2: B2 */
        $B2("B2", "$B2", emptyStrings())
        ,
        /** $B3: B3 */
        $B3("B3", "$B3", emptyStrings())
        ,
        /** $B4: B4 */
        $B4("B4", "$B4", emptyStrings())
        ,
        /** $B5: B5 */
        $B5("B5", "$B5", emptyStrings())
        ,
        /** $99: ケース */
        $99("99", "$99", emptyStrings())
        ,
        /** $9903: 引取場 */
        $9903("9903", "$9903", emptyStrings())
        ,
        /** $9905: その他 */
        $9905("9905", "$9905", emptyStrings())
        ,
        /** $9910: 融通 */
        $9910("9910", "$9910", emptyStrings())
        ;
        private static final Map<String, Sorttype> _codeClsMap = new HashMap<String, Sorttype>();
        private static final Map<String, Sorttype> _nameClsMap = new HashMap<String, Sorttype>();
        static {
            for (Sorttype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Sorttype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Sorttype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sorttype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Sorttype) { return OptionalThing.of((Sorttype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Sorttype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Sorttype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Sorttype) { return (Sorttype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Sorttype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Sorttype> listAll() {
            return new ArrayList<Sorttype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Sorttype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Sorttype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Sorttype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Sorttype> clsList = new ArrayList<Sorttype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Sorttype> groupOf(String groupName) {
            return new ArrayList<Sorttype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 取引方法
     */
    public enum Exchgmethod implements CDef {
        /** $1: 直配 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 中継 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 宅配 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Exchgmethod> _codeClsMap = new HashMap<String, Exchgmethod>();
        private static final Map<String, Exchgmethod> _nameClsMap = new HashMap<String, Exchgmethod>();
        static {
            for (Exchgmethod value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Exchgmethod(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Exchgmethod; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Exchgmethod> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Exchgmethod) { return OptionalThing.of((Exchgmethod)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Exchgmethod> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Exchgmethod codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Exchgmethod) { return (Exchgmethod)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Exchgmethod nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Exchgmethod> listAll() {
            return new ArrayList<Exchgmethod>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Exchgmethod> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Exchgmethod." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Exchgmethod> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Exchgmethod> clsList = new ArrayList<Exchgmethod>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Exchgmethod> groupOf(String groupName) {
            return new ArrayList<Exchgmethod>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 状態コード
     */
    public enum Conditionflg implements CDef {
        /** $11: 適品 */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 不適品 */
        $12("12", "$12", emptyStrings())
        ,
        /** $13: 処分品 */
        $13("13", "$13", emptyStrings())
        ,
        /** $14: 虫害品 */
        $14("14", "$14", emptyStrings())
        ,
        /** $01: 完全品 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 内外装不良 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: つぶれ */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 虫害品 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 長期経過・販売不可品 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: り災品 */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 本数不良品 */
        $07("07", "$07", emptyStrings())
        ,
        /** $21: PM確認済 */
        $21("21", "$21", emptyStrings())
        ,
        /** $22: PM確認済(印無) */
        $22("22", "$22", emptyStrings())
        ,
        /** $23: PM未認印有 */
        $23("23", "$23", emptyStrings())
        ,
        /** $31: BAT確認済 */
        $31("31", "$31", emptyStrings())
        ,
        /** $32: BAT確認済(印無) */
        $32("32", "$32", emptyStrings())
        ;
        private static final Map<String, Conditionflg> _codeClsMap = new HashMap<String, Conditionflg>();
        private static final Map<String, Conditionflg> _nameClsMap = new HashMap<String, Conditionflg>();
        static {
            for (Conditionflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Conditionflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Conditionflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Conditionflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Conditionflg) { return OptionalThing.of((Conditionflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Conditionflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Conditionflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Conditionflg) { return (Conditionflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Conditionflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Conditionflg> listAll() {
            return new ArrayList<Conditionflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Conditionflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Conditionflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Conditionflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Conditionflg> clsList = new ArrayList<Conditionflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Conditionflg> groupOf(String groupName) {
            return new ArrayList<Conditionflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 数量調整未済区分
     */
    public enum Qtyadjustflg implements CDef {
        /** $0: 未調整 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 調整済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Qtyadjustflg> _codeClsMap = new HashMap<String, Qtyadjustflg>();
        private static final Map<String, Qtyadjustflg> _nameClsMap = new HashMap<String, Qtyadjustflg>();
        static {
            for (Qtyadjustflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Qtyadjustflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Qtyadjustflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Qtyadjustflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Qtyadjustflg) { return OptionalThing.of((Qtyadjustflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Qtyadjustflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Qtyadjustflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Qtyadjustflg) { return (Qtyadjustflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Qtyadjustflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Qtyadjustflg> listAll() {
            return new ArrayList<Qtyadjustflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Qtyadjustflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Qtyadjustflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Qtyadjustflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Qtyadjustflg> clsList = new ArrayList<Qtyadjustflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Qtyadjustflg> groupOf(String groupName) {
            return new ArrayList<Qtyadjustflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送受信区分
     */
    public enum Inoutcode implements CDef {
        /** $0: 受信 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 送信 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Inoutcode> _codeClsMap = new HashMap<String, Inoutcode>();
        private static final Map<String, Inoutcode> _nameClsMap = new HashMap<String, Inoutcode>();
        static {
            for (Inoutcode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Inoutcode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Inoutcode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inoutcode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Inoutcode) { return OptionalThing.of((Inoutcode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inoutcode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Inoutcode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Inoutcode) { return (Inoutcode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Inoutcode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Inoutcode> listAll() {
            return new ArrayList<Inoutcode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Inoutcode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Inoutcode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Inoutcode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Inoutcode> clsList = new ArrayList<Inoutcode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Inoutcode> groupOf(String groupName) {
            return new ArrayList<Inoutcode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸方法
     */
    public enum Inventorytype implements CDef {
        /** $ALL: 一斉 */
        $ALL("ALL", "$ALL", emptyStrings())
        ,
        /** $CYCLE: 循環 */
        $CYCLE("CYCLE", "$CYCLE", emptyStrings())
        ,
        /** $SELECT: 指定 */
        $SELECT("SELECT", "$SELECT", emptyStrings())
        ;
        private static final Map<String, Inventorytype> _codeClsMap = new HashMap<String, Inventorytype>();
        private static final Map<String, Inventorytype> _nameClsMap = new HashMap<String, Inventorytype>();
        static {
            for (Inventorytype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Inventorytype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Inventorytype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inventorytype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Inventorytype) { return OptionalThing.of((Inventorytype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inventorytype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Inventorytype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Inventorytype) { return (Inventorytype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Inventorytype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Inventorytype> listAll() {
            return new ArrayList<Inventorytype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Inventorytype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Inventorytype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Inventorytype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Inventorytype> clsList = new ArrayList<Inventorytype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Inventorytype> groupOf(String groupName) {
            return new ArrayList<Inventorytype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 注意喚起区分
     */
    public enum Attensionflg implements CDef {
        /** $0: 注意喚起なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 注意喚起あり */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Attensionflg> _codeClsMap = new HashMap<String, Attensionflg>();
        private static final Map<String, Attensionflg> _nameClsMap = new HashMap<String, Attensionflg>();
        static {
            for (Attensionflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Attensionflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Attensionflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Attensionflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Attensionflg) { return OptionalThing.of((Attensionflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Attensionflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Attensionflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Attensionflg) { return (Attensionflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Attensionflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Attensionflg> listAll() {
            return new ArrayList<Attensionflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Attensionflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Attensionflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Attensionflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Attensionflg> clsList = new ArrayList<Attensionflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Attensionflg> groupOf(String groupName) {
            return new ArrayList<Attensionflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 通常・異型品区分
     */
    public enum Formdiffflg implements CDef {
        /** $0: 通常品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 異型品 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Formdiffflg> _codeClsMap = new HashMap<String, Formdiffflg>();
        private static final Map<String, Formdiffflg> _nameClsMap = new HashMap<String, Formdiffflg>();
        static {
            for (Formdiffflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Formdiffflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Formdiffflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Formdiffflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Formdiffflg) { return OptionalThing.of((Formdiffflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Formdiffflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Formdiffflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Formdiffflg) { return (Formdiffflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Formdiffflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Formdiffflg> listAll() {
            return new ArrayList<Formdiffflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Formdiffflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Formdiffflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Formdiffflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Formdiffflg> clsList = new ArrayList<Formdiffflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Formdiffflg> groupOf(String groupName) {
            return new ArrayList<Formdiffflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 伝送区分
     */
    public enum Timingtype implements CDef {
        /** $0: 夜間 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 随時 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 早朝 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Timingtype> _codeClsMap = new HashMap<String, Timingtype>();
        private static final Map<String, Timingtype> _nameClsMap = new HashMap<String, Timingtype>();
        static {
            for (Timingtype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Timingtype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Timingtype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Timingtype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Timingtype) { return OptionalThing.of((Timingtype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Timingtype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Timingtype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Timingtype) { return (Timingtype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Timingtype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Timingtype> listAll() {
            return new ArrayList<Timingtype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Timingtype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Timingtype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Timingtype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Timingtype> clsList = new ArrayList<Timingtype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Timingtype> groupOf(String groupName) {
            return new ArrayList<Timingtype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 内外区分
     */
    public enum Fcflg implements CDef {
        /** $A000: 国産 */
        $A000("A000", "$A000", emptyStrings())
        ,
        /** $0001: 輸入 */
        $0001("0001", "$0001", emptyStrings())
        ;
        private static final Map<String, Fcflg> _codeClsMap = new HashMap<String, Fcflg>();
        private static final Map<String, Fcflg> _nameClsMap = new HashMap<String, Fcflg>();
        static {
            for (Fcflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Fcflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Fcflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fcflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Fcflg) { return OptionalThing.of((Fcflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fcflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Fcflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Fcflg) { return (Fcflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Fcflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Fcflg> listAll() {
            return new ArrayList<Fcflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Fcflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Fcflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Fcflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Fcflg> clsList = new ArrayList<Fcflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Fcflg> groupOf(String groupName) {
            return new ArrayList<Fcflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 日曜日フラグ
     */
    public enum SundayFlg implements CDef {
        /** $0: 日曜日以外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 日曜日 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SundayFlg> _codeClsMap = new HashMap<String, SundayFlg>();
        private static final Map<String, SundayFlg> _nameClsMap = new HashMap<String, SundayFlg>();
        static {
            for (SundayFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SundayFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SundayFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SundayFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SundayFlg) { return OptionalThing.of((SundayFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SundayFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SundayFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SundayFlg) { return (SundayFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SundayFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SundayFlg> listAll() {
            return new ArrayList<SundayFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SundayFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SundayFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SundayFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SundayFlg> clsList = new ArrayList<SundayFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SundayFlg> groupOf(String groupName) {
            return new ArrayList<SundayFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 複数製造月日区分
     */
    public enum Pluralproductionkbn implements CDef {
        /** $0: 複数製造月日無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 複数製造月日有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Pluralproductionkbn> _codeClsMap = new HashMap<String, Pluralproductionkbn>();
        private static final Map<String, Pluralproductionkbn> _nameClsMap = new HashMap<String, Pluralproductionkbn>();
        static {
            for (Pluralproductionkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Pluralproductionkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Pluralproductionkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pluralproductionkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Pluralproductionkbn) { return OptionalThing.of((Pluralproductionkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Pluralproductionkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Pluralproductionkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Pluralproductionkbn) { return (Pluralproductionkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Pluralproductionkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Pluralproductionkbn> listAll() {
            return new ArrayList<Pluralproductionkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Pluralproductionkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Pluralproductionkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Pluralproductionkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Pluralproductionkbn> clsList = new ArrayList<Pluralproductionkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Pluralproductionkbn> groupOf(String groupName) {
            return new ArrayList<Pluralproductionkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 返品／取替区分
     */
    public enum Changeflg implements CDef {
        /** $RETUN: 返品 */
        $RETUN("RETUN", "$RETUN", emptyStrings())
        ,
        /** $RGET: 取替 */
        $RGET("RGET", "$RGET", emptyStrings())
        ;
        private static final Map<String, Changeflg> _codeClsMap = new HashMap<String, Changeflg>();
        private static final Map<String, Changeflg> _nameClsMap = new HashMap<String, Changeflg>();
        static {
            for (Changeflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Changeflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Changeflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Changeflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Changeflg) { return OptionalThing.of((Changeflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Changeflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Changeflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Changeflg) { return (Changeflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Changeflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Changeflg> listAll() {
            return new ArrayList<Changeflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Changeflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Changeflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Changeflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Changeflg> clsList = new ArrayList<Changeflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Changeflg> groupOf(String groupName) {
            return new ArrayList<Changeflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 返品ステータス
     */
    public enum Rtnstatus implements CDef {
        /** $200: 検品前 */
        $200("200", "$200", emptyStrings())
        ,
        /** $250: 検品中 */
        $250("250", "$250", emptyStrings())
        ,
        /** $300: 検品済 */
        $300("300", "$300", emptyStrings())
        ,
        /** $400: 削除 */
        $400("400", "$400", emptyStrings())
        ,
        /** $500: 保留 */
        $500("500", "$500", emptyStrings())
        ,
        /** $750: 異常 */
        $750("750", "$750", emptyStrings())
        ,
        /** $790: 送信中 */
        $790("790", "$790", emptyStrings())
        ,
        /** $800: 送信済 */
        $800("800", "$800", emptyStrings())
        ;
        private static final Map<String, Rtnstatus> _codeClsMap = new HashMap<String, Rtnstatus>();
        private static final Map<String, Rtnstatus> _nameClsMap = new HashMap<String, Rtnstatus>();
        static {
            for (Rtnstatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Rtnstatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Rtnstatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rtnstatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Rtnstatus) { return OptionalThing.of((Rtnstatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rtnstatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Rtnstatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Rtnstatus) { return (Rtnstatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Rtnstatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Rtnstatus> listAll() {
            return new ArrayList<Rtnstatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Rtnstatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Rtnstatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Rtnstatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Rtnstatus> clsList = new ArrayList<Rtnstatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Rtnstatus> groupOf(String groupName) {
            return new ArrayList<Rtnstatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 返品検品ステータス
     */
    public enum Rtninspestatus implements CDef {
        /** $0000: 変化なし */
        $0000("0000", "$0000", emptyStrings())
        ,
        /** $0100: 修正 */
        $0100("0100", "$0100", emptyStrings())
        ,
        /** $0300: 追加 */
        $0300("0300", "$0300", emptyStrings())
        ,
        /** $0900: 削除 */
        $0900("0900", "$0900", emptyStrings())
        ;
        private static final Map<String, Rtninspestatus> _codeClsMap = new HashMap<String, Rtninspestatus>();
        private static final Map<String, Rtninspestatus> _nameClsMap = new HashMap<String, Rtninspestatus>();
        static {
            for (Rtninspestatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Rtninspestatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Rtninspestatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rtninspestatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Rtninspestatus) { return OptionalThing.of((Rtninspestatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rtninspestatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Rtninspestatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Rtninspestatus) { return (Rtninspestatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Rtninspestatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Rtninspestatus> listAll() {
            return new ArrayList<Rtninspestatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Rtninspestatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Rtninspestatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Rtninspestatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Rtninspestatus> clsList = new ArrayList<Rtninspestatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Rtninspestatus> groupOf(String groupName) {
            return new ArrayList<Rtninspestatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保管在庫区分
     */
    public enum Inventoryref implements CDef {
        /** $01: 保管場 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 仕分場 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 引取場 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: かし品 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 国税還付品 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 未入庫 */
        $06("06", "$06", emptyStrings())
        ;
        private static final Map<String, Inventoryref> _codeClsMap = new HashMap<String, Inventoryref>();
        private static final Map<String, Inventoryref> _nameClsMap = new HashMap<String, Inventoryref>();
        static {
            for (Inventoryref value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Inventoryref(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Inventoryref; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inventoryref> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Inventoryref) { return OptionalThing.of((Inventoryref)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inventoryref> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Inventoryref codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Inventoryref) { return (Inventoryref)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Inventoryref nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Inventoryref> listAll() {
            return new ArrayList<Inventoryref>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Inventoryref> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Inventoryref." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Inventoryref> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Inventoryref> clsList = new ArrayList<Inventoryref>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Inventoryref> groupOf(String groupName) {
            return new ArrayList<Inventoryref>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充区分
     */
    public enum Restockflg implements CDef {
        /** $1: 1 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 2 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 3 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Restockflg> _codeClsMap = new HashMap<String, Restockflg>();
        private static final Map<String, Restockflg> _nameClsMap = new HashMap<String, Restockflg>();
        static {
            for (Restockflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Restockflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Restockflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Restockflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Restockflg) { return OptionalThing.of((Restockflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Restockflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Restockflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Restockflg) { return (Restockflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Restockflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Restockflg> listAll() {
            return new ArrayList<Restockflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Restockflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Restockflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Restockflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Restockflg> clsList = new ArrayList<Restockflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Restockflg> groupOf(String groupName) {
            return new ArrayList<Restockflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 有効区分
     */
    public enum Validtype implements CDef {
        /** $0: 過去世代 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 適用世代 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 未来世代 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Validtype> _codeClsMap = new HashMap<String, Validtype>();
        private static final Map<String, Validtype> _nameClsMap = new HashMap<String, Validtype>();
        static {
            for (Validtype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Validtype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Validtype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Validtype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Validtype) { return OptionalThing.of((Validtype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Validtype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Validtype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Validtype) { return (Validtype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Validtype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Validtype> listAll() {
            return new ArrayList<Validtype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Validtype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Validtype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Validtype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Validtype> clsList = new ArrayList<Validtype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Validtype> groupOf(String groupName) {
            return new ArrayList<Validtype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 返品変更理由
     */
    public enum Rtnchangedivision implements CDef {
        /** $0: なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 数量変更 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 状態コード変更 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Rtnchangedivision> _codeClsMap = new HashMap<String, Rtnchangedivision>();
        private static final Map<String, Rtnchangedivision> _nameClsMap = new HashMap<String, Rtnchangedivision>();
        static {
            for (Rtnchangedivision value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Rtnchangedivision(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Rtnchangedivision; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rtnchangedivision> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Rtnchangedivision) { return OptionalThing.of((Rtnchangedivision)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Rtnchangedivision> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Rtnchangedivision codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Rtnchangedivision) { return (Rtnchangedivision)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Rtnchangedivision nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Rtnchangedivision> listAll() {
            return new ArrayList<Rtnchangedivision>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Rtnchangedivision> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Rtnchangedivision." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Rtnchangedivision> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Rtnchangedivision> clsList = new ArrayList<Rtnchangedivision>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Rtnchangedivision> groupOf(String groupName) {
            return new ArrayList<Rtnchangedivision>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 格納場所
     */
    public enum Storagearea implements CDef {
        /** $0: 指定無し（販物台帳） */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 仕分場、引取場のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Storagearea> _codeClsMap = new HashMap<String, Storagearea>();
        private static final Map<String, Storagearea> _nameClsMap = new HashMap<String, Storagearea>();
        static {
            for (Storagearea value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Storagearea(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Storagearea; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Storagearea> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Storagearea) { return OptionalThing.of((Storagearea)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Storagearea> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Storagearea codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Storagearea) { return (Storagearea)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Storagearea nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Storagearea> listAll() {
            return new ArrayList<Storagearea>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Storagearea> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Storagearea." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Storagearea> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Storagearea> clsList = new ArrayList<Storagearea>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Storagearea> groupOf(String groupName) {
            return new ArrayList<Storagearea>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫調査キーフラグ
     */
    public enum Maxinvflg implements CDef {
        /** $0: 最新在庫調査キー */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 条件指定 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Maxinvflg> _codeClsMap = new HashMap<String, Maxinvflg>();
        private static final Map<String, Maxinvflg> _nameClsMap = new HashMap<String, Maxinvflg>();
        static {
            for (Maxinvflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Maxinvflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Maxinvflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Maxinvflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Maxinvflg) { return OptionalThing.of((Maxinvflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Maxinvflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Maxinvflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Maxinvflg) { return (Maxinvflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Maxinvflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Maxinvflg> listAll() {
            return new ArrayList<Maxinvflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Maxinvflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Maxinvflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Maxinvflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Maxinvflg> clsList = new ArrayList<Maxinvflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Maxinvflg> groupOf(String groupName) {
            return new ArrayList<Maxinvflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保留区分
     */
    public enum Horyukbn implements CDef {
        /** $0: 保留 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 一時保留 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Horyukbn> _codeClsMap = new HashMap<String, Horyukbn>();
        private static final Map<String, Horyukbn> _nameClsMap = new HashMap<String, Horyukbn>();
        static {
            for (Horyukbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Horyukbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Horyukbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Horyukbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Horyukbn) { return OptionalThing.of((Horyukbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Horyukbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Horyukbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Horyukbn) { return (Horyukbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Horyukbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Horyukbn> listAll() {
            return new ArrayList<Horyukbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Horyukbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Horyukbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Horyukbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Horyukbn> clsList = new ArrayList<Horyukbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Horyukbn> groupOf(String groupName) {
            return new ArrayList<Horyukbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 使用中区分
     */
    public enum Useflg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用中 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Useflg> _codeClsMap = new HashMap<String, Useflg>();
        private static final Map<String, Useflg> _nameClsMap = new HashMap<String, Useflg>();
        static {
            for (Useflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Useflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Useflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Useflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Useflg) { return OptionalThing.of((Useflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Useflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Useflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Useflg) { return (Useflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Useflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Useflg> listAll() {
            return new ArrayList<Useflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Useflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Useflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Useflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Useflg> clsList = new ArrayList<Useflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Useflg> groupOf(String groupName) {
            return new ArrayList<Useflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 内外・国税還付品区分
     */
    public enum Fckokuflg implements CDef {
        /** $A000: 国産 */
        $A000("A000", "$A000", emptyStrings())
        ,
        /** $0001: 輸入 */
        $0001("0001", "$0001", emptyStrings())
        ,
        /** $K001: 輸入・国税還付品 */
        $K001("K001", "$K001", emptyStrings())
        ;
        private static final Map<String, Fckokuflg> _codeClsMap = new HashMap<String, Fckokuflg>();
        private static final Map<String, Fckokuflg> _nameClsMap = new HashMap<String, Fckokuflg>();
        static {
            for (Fckokuflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Fckokuflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Fckokuflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fckokuflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Fckokuflg) { return OptionalThing.of((Fckokuflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fckokuflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Fckokuflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Fckokuflg) { return (Fckokuflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Fckokuflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Fckokuflg> listAll() {
            return new ArrayList<Fckokuflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Fckokuflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Fckokuflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Fckokuflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Fckokuflg> clsList = new ArrayList<Fckokuflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Fckokuflg> groupOf(String groupName) {
            return new ArrayList<Fckokuflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * カートン形状区分
     */
    public enum Bowltypeflg implements CDef {
        /** $1: 通常品 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 通常品 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 通常品 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 通常品 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 異型品 */
        $5("5", "$5", emptyStrings())
        ,
        /** $9: 異型品 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, Bowltypeflg> _codeClsMap = new HashMap<String, Bowltypeflg>();
        private static final Map<String, Bowltypeflg> _nameClsMap = new HashMap<String, Bowltypeflg>();
        static {
            for (Bowltypeflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Bowltypeflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Bowltypeflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Bowltypeflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Bowltypeflg) { return OptionalThing.of((Bowltypeflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Bowltypeflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Bowltypeflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Bowltypeflg) { return (Bowltypeflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Bowltypeflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Bowltypeflg> listAll() {
            return new ArrayList<Bowltypeflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Bowltypeflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Bowltypeflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Bowltypeflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Bowltypeflg> clsList = new ArrayList<Bowltypeflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Bowltypeflg> groupOf(String groupName) {
            return new ArrayList<Bowltypeflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保管場在庫区分
     */
    public enum Inventoryrefdisp implements CDef {
        /** $01: 保管場 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 仕分場 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 引取場 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: かし品 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 国税還付品 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 未入庫 */
        $06("06", "$06", emptyStrings())
        ;
        private static final Map<String, Inventoryrefdisp> _codeClsMap = new HashMap<String, Inventoryrefdisp>();
        private static final Map<String, Inventoryrefdisp> _nameClsMap = new HashMap<String, Inventoryrefdisp>();
        static {
            for (Inventoryrefdisp value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Inventoryrefdisp(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Inventoryrefdisp; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inventoryrefdisp> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Inventoryrefdisp) { return OptionalThing.of((Inventoryrefdisp)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Inventoryrefdisp> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Inventoryrefdisp codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Inventoryrefdisp) { return (Inventoryrefdisp)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Inventoryrefdisp nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Inventoryrefdisp> listAll() {
            return new ArrayList<Inventoryrefdisp>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Inventoryrefdisp> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Inventoryrefdisp." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Inventoryrefdisp> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Inventoryrefdisp> clsList = new ArrayList<Inventoryrefdisp>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Inventoryrefdisp> groupOf(String groupName) {
            return new ArrayList<Inventoryrefdisp>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 融通指示ステータス
     */
    public enum Flinstrstatus implements CDef {
        /** $150: ファイル取込済 */
        $150("150", "$150", emptyStrings())
        ,
        /** $170: 内訳受信済 */
        $170("170", "$170", emptyStrings())
        ,
        /** $200: 伝票受信済 */
        $200("200", "$200", emptyStrings())
        ,
        /** $500: 発送元未指示 */
        $500("500", "$500", emptyStrings())
        ,
        /** $550: 発送元送信中 */
        $550("550", "$550", emptyStrings())
        ,
        /** $900: 発送元指示済 */
        $900("900", "$900", emptyStrings())
        ,
        /** $950: 伝票削除済 */
        $950("950", "$950", emptyStrings())
        ;
        private static final Map<String, Flinstrstatus> _codeClsMap = new HashMap<String, Flinstrstatus>();
        private static final Map<String, Flinstrstatus> _nameClsMap = new HashMap<String, Flinstrstatus>();
        static {
            for (Flinstrstatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Flinstrstatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Flinstrstatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flinstrstatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Flinstrstatus) { return OptionalThing.of((Flinstrstatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flinstrstatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Flinstrstatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Flinstrstatus) { return (Flinstrstatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Flinstrstatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Flinstrstatus> listAll() {
            return new ArrayList<Flinstrstatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Flinstrstatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Flinstrstatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Flinstrstatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Flinstrstatus> clsList = new ArrayList<Flinstrstatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Flinstrstatus> groupOf(String groupName) {
            return new ArrayList<Flinstrstatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 融通ステータス
     */
    public enum Flexstatus implements CDef {
        /** $100: 融通指示作成中 */
        $100("100", "$100", emptyStrings())
        ,
        /** $200: 融通指示情報受信済 */
        $200("200", "$200", emptyStrings())
        ,
        /** $550: 山出し中 */
        $550("550", "$550", emptyStrings())
        ,
        /** $600: 山出し完了 */
        $600("600", "$600", emptyStrings())
        ,
        /** $860: 引継検品中 */
        $860("860", "$860", emptyStrings())
        ,
        /** $870: 引継検品済 */
        $870("870", "$870", emptyStrings())
        ,
        /** $880: 発送先送信中 */
        $880("880", "$880", emptyStrings())
        ,
        /** $900: 発送先送信済 */
        $900("900", "$900", emptyStrings())
        ;
        private static final Map<String, Flexstatus> _codeClsMap = new HashMap<String, Flexstatus>();
        private static final Map<String, Flexstatus> _nameClsMap = new HashMap<String, Flexstatus>();
        static {
            for (Flexstatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Flexstatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Flexstatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flexstatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Flexstatus) { return OptionalThing.of((Flexstatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Flexstatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Flexstatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Flexstatus) { return (Flexstatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Flexstatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Flexstatus> listAll() {
            return new ArrayList<Flexstatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Flexstatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Flexstatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Flexstatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Flexstatus> clsList = new ArrayList<Flexstatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Flexstatus> groupOf(String groupName) {
            return new ArrayList<Flexstatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 流通識別
     */
    public enum Distributioncd implements CDef {
        /** $_: （指定なし） */
        $_("_", "$_", emptyStrings())
        ,
        /** $N: N */
        $N("N", "$N", emptyStrings())
        ,
        /** $R: R */
        $R("R", "$R", emptyStrings())
        ,
        /** $T: T */
        $T("T", "$T", emptyStrings())
        ;
        private static final Map<String, Distributioncd> _codeClsMap = new HashMap<String, Distributioncd>();
        private static final Map<String, Distributioncd> _nameClsMap = new HashMap<String, Distributioncd>();
        static {
            for (Distributioncd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Distributioncd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Distributioncd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Distributioncd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Distributioncd) { return OptionalThing.of((Distributioncd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Distributioncd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Distributioncd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Distributioncd) { return (Distributioncd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Distributioncd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Distributioncd> listAll() {
            return new ArrayList<Distributioncd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Distributioncd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Distributioncd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Distributioncd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Distributioncd> clsList = new ArrayList<Distributioncd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Distributioncd> groupOf(String groupName) {
            return new ArrayList<Distributioncd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 格納場所区分
     */
    public enum Stocklocation implements CDef {
        /** $01: 保管場 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 仕分場 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 引取場 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: かし品 */
        $04("04", "$04", emptyStrings())
        ,
        /** $06: 未入庫 */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 離島在庫 */
        $07("07", "$07", emptyStrings())
        ;
        private static final Map<String, Stocklocation> _codeClsMap = new HashMap<String, Stocklocation>();
        private static final Map<String, Stocklocation> _nameClsMap = new HashMap<String, Stocklocation>();
        static {
            for (Stocklocation value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Stocklocation(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Stocklocation; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Stocklocation> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Stocklocation) { return OptionalThing.of((Stocklocation)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Stocklocation> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Stocklocation codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Stocklocation) { return (Stocklocation)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Stocklocation nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Stocklocation> listAll() {
            return new ArrayList<Stocklocation>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Stocklocation> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Stocklocation." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Stocklocation> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Stocklocation> clsList = new ArrayList<Stocklocation>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Stocklocation> groupOf(String groupName) {
            return new ArrayList<Stocklocation>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫ステータス
     */
    public enum ResultStatus implements CDef {
        /** $00: 未入庫 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 作業指示送信済 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 入庫登録中 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 入庫登録済 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: はり紙検品中 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: はり紙検品済 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 格納中 */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 格納済 */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: 実績送信済 */
        $08("08", "$08", emptyStrings())
        ,
        /** $99: エラー */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, ResultStatus> _codeClsMap = new HashMap<String, ResultStatus>();
        private static final Map<String, ResultStatus> _nameClsMap = new HashMap<String, ResultStatus>();
        static {
            for (ResultStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ResultStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ResultStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ResultStatus) { return OptionalThing.of((ResultStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ResultStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ResultStatus) { return (ResultStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ResultStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ResultStatus> listAll() {
            return new ArrayList<ResultStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ResultStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ResultStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ResultStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ResultStatus> clsList = new ArrayList<ResultStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ResultStatus> groupOf(String groupName) {
            return new ArrayList<ResultStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 箱種別
     */
    public enum BoxCategory implements CDef {
        /** $00: 通常品 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 異型品 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: オリコン */
        $02("02", "$02", emptyStrings())
        ;
        private static final Map<String, BoxCategory> _codeClsMap = new HashMap<String, BoxCategory>();
        private static final Map<String, BoxCategory> _nameClsMap = new HashMap<String, BoxCategory>();
        static {
            for (BoxCategory value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BoxCategory(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BoxCategory; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BoxCategory> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BoxCategory) { return OptionalThing.of((BoxCategory)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BoxCategory> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BoxCategory codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BoxCategory) { return (BoxCategory)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BoxCategory nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BoxCategory> listAll() {
            return new ArrayList<BoxCategory>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BoxCategory> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BoxCategory." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BoxCategory> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BoxCategory> clsList = new ArrayList<BoxCategory>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BoxCategory> groupOf(String groupName) {
            return new ArrayList<BoxCategory>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保管場所コード
     */
    public enum Storagewarehousecd implements CDef {
        /** $JP45: JT大井流通ｾﾝﾀｰ */
        $JP45("JP45", "$JP45", emptyStrings())
        ,
        /** $JP46: JT六甲流通ｾﾝﾀｰ */
        $JP46("JP46", "$JP46", emptyStrings())
        ;
        private static final Map<String, Storagewarehousecd> _codeClsMap = new HashMap<String, Storagewarehousecd>();
        private static final Map<String, Storagewarehousecd> _nameClsMap = new HashMap<String, Storagewarehousecd>();
        static {
            for (Storagewarehousecd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Storagewarehousecd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Storagewarehousecd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Storagewarehousecd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Storagewarehousecd) { return OptionalThing.of((Storagewarehousecd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Storagewarehousecd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Storagewarehousecd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Storagewarehousecd) { return (Storagewarehousecd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Storagewarehousecd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Storagewarehousecd> listAll() {
            return new ArrayList<Storagewarehousecd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Storagewarehousecd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Storagewarehousecd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Storagewarehousecd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Storagewarehousecd> clsList = new ArrayList<Storagewarehousecd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Storagewarehousecd> groupOf(String groupName) {
            return new ArrayList<Storagewarehousecd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 売上種別
     */
    public enum Salestype implements CDef {
        /** $Z002: 出庫 */
        $Z002("Z002", "$Z002", emptyStrings())
        ,
        /** $Z005: 入庫 */
        $Z005("Z005", "$Z005", emptyStrings())
        ;
        private static final Map<String, Salestype> _codeClsMap = new HashMap<String, Salestype>();
        private static final Map<String, Salestype> _nameClsMap = new HashMap<String, Salestype>();
        static {
            for (Salestype value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Salestype(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Salestype; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Salestype> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Salestype) { return OptionalThing.of((Salestype)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Salestype> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Salestype codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Salestype) { return (Salestype)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Salestype nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Salestype> listAll() {
            return new ArrayList<Salestype>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Salestype> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Salestype." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Salestype> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Salestype> clsList = new ArrayList<Salestype>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Salestype> groupOf(String groupName) {
            return new ArrayList<Salestype>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保税出庫関連リスト帳票区分(パレット内個体情報コード一覧以外)
     */
    public enum Solistkbn2 implements CDef {
        /** $1: 棚出リスト（端数） */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 棚出リスト（単品） */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: パレット明細（単品） */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: パレット明細（端数） */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 仕分場受入検品リスト */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 積込リスト */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, Solistkbn2> _codeClsMap = new HashMap<String, Solistkbn2>();
        private static final Map<String, Solistkbn2> _nameClsMap = new HashMap<String, Solistkbn2>();
        static {
            for (Solistkbn2 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Solistkbn2(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Solistkbn2; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Solistkbn2> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Solistkbn2) { return OptionalThing.of((Solistkbn2)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Solistkbn2> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Solistkbn2 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Solistkbn2) { return (Solistkbn2)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Solistkbn2 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Solistkbn2> listAll() {
            return new ArrayList<Solistkbn2>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Solistkbn2> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Solistkbn2." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Solistkbn2> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Solistkbn2> clsList = new ArrayList<Solistkbn2>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Solistkbn2> groupOf(String groupName) {
            return new ArrayList<Solistkbn2>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * リスト発行区分
     */
    public enum PickingListType implements CDef {
        /** $0: 明細書・ラベル */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ラベル */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 明細書 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 方面別残数リスト */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, PickingListType> _codeClsMap = new HashMap<String, PickingListType>();
        private static final Map<String, PickingListType> _nameClsMap = new HashMap<String, PickingListType>();
        static {
            for (PickingListType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingListType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingListType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingListType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingListType) { return OptionalThing.of((PickingListType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingListType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingListType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingListType) { return (PickingListType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingListType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingListType> listAll() {
            return new ArrayList<PickingListType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingListType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingListType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingListType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingListType> clsList = new ArrayList<PickingListType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingListType> groupOf(String groupName) {
            return new ArrayList<PickingListType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 対象管理区分
     */
    public enum CoveredClass implements CDef {
        /** $0: × */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ○ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CoveredClass> _codeClsMap = new HashMap<String, CoveredClass>();
        private static final Map<String, CoveredClass> _nameClsMap = new HashMap<String, CoveredClass>();
        static {
            for (CoveredClass value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CoveredClass(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CoveredClass; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoveredClass> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CoveredClass) { return OptionalThing.of((CoveredClass)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoveredClass> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CoveredClass codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CoveredClass) { return (CoveredClass)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CoveredClass nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CoveredClass> listAll() {
            return new ArrayList<CoveredClass>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CoveredClass> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CoveredClass." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CoveredClass> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CoveredClass> clsList = new ArrayList<CoveredClass>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CoveredClass> groupOf(String groupName) {
            return new ArrayList<CoveredClass>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 非対象管理区分
     */
    public enum NotCoveredClass implements CDef {
        /** $0: × */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, NotCoveredClass> _codeClsMap = new HashMap<String, NotCoveredClass>();
        private static final Map<String, NotCoveredClass> _nameClsMap = new HashMap<String, NotCoveredClass>();
        static {
            for (NotCoveredClass value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NotCoveredClass(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NotCoveredClass; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NotCoveredClass> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NotCoveredClass) { return OptionalThing.of((NotCoveredClass)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NotCoveredClass> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NotCoveredClass codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NotCoveredClass) { return (NotCoveredClass)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NotCoveredClass nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NotCoveredClass> listAll() {
            return new ArrayList<NotCoveredClass>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NotCoveredClass> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NotCoveredClass." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NotCoveredClass> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NotCoveredClass> clsList = new ArrayList<NotCoveredClass>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NotCoveredClass> groupOf(String groupName) {
            return new ArrayList<NotCoveredClass>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出庫作業ステータス
     */
    public enum PickingWorkStatus implements CDef {
        /** $0: 未着手 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 作業中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 作業完了 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, PickingWorkStatus> _codeClsMap = new HashMap<String, PickingWorkStatus>();
        private static final Map<String, PickingWorkStatus> _nameClsMap = new HashMap<String, PickingWorkStatus>();
        static {
            for (PickingWorkStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingWorkStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingWorkStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingWorkStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingWorkStatus) { return OptionalThing.of((PickingWorkStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingWorkStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingWorkStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingWorkStatus) { return (PickingWorkStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingWorkStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingWorkStatus> listAll() {
            return new ArrayList<PickingWorkStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingWorkStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingWorkStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingWorkStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingWorkStatus> clsList = new ArrayList<PickingWorkStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingWorkStatus> groupOf(String groupName) {
            return new ArrayList<PickingWorkStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 再印刷区分
     */
    public enum ReprintedFlg implements CDef {
        /** $00: 未印刷 */
        $00("00", "$00", emptyStrings())
        ,
        /** $10: 印刷済 */
        $10("10", "$10", emptyStrings())
        ,
        /** $20: 未印刷（組替） */
        $20("20", "$20", emptyStrings())
        ,
        /** $30: 印刷済（組替） */
        $30("30", "$30", emptyStrings())
        ;
        private static final Map<String, ReprintedFlg> _codeClsMap = new HashMap<String, ReprintedFlg>();
        private static final Map<String, ReprintedFlg> _nameClsMap = new HashMap<String, ReprintedFlg>();
        static {
            for (ReprintedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReprintedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReprintedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReprintedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReprintedFlg) { return OptionalThing.of((ReprintedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReprintedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReprintedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReprintedFlg) { return (ReprintedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReprintedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReprintedFlg> listAll() {
            return new ArrayList<ReprintedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReprintedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReprintedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReprintedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReprintedFlg> clsList = new ArrayList<ReprintedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReprintedFlg> groupOf(String groupName) {
            return new ArrayList<ReprintedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * たばこ商品区分
     */
    public enum Cggdid implements CDef {
        /** $1: たばこ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: デバイス/アクセサリ */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 喫煙具 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Cggdid> _codeClsMap = new HashMap<String, Cggdid>();
        private static final Map<String, Cggdid> _nameClsMap = new HashMap<String, Cggdid>();
        static {
            for (Cggdid value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Cggdid(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Cggdid; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cggdid> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Cggdid) { return OptionalThing.of((Cggdid)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cggdid> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Cggdid codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Cggdid) { return (Cggdid)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Cggdid nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Cggdid> listAll() {
            return new ArrayList<Cggdid>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Cggdid> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Cggdid." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Cggdid> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Cggdid> clsList = new ArrayList<Cggdid>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Cggdid> groupOf(String groupName) {
            return new ArrayList<Cggdid>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 格納ステータス
     */
    public enum RcvPlanSts implements CDef {
        /** $0: 未指示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 格納指示済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, RcvPlanSts> _codeClsMap = new HashMap<String, RcvPlanSts>();
        private static final Map<String, RcvPlanSts> _nameClsMap = new HashMap<String, RcvPlanSts>();
        static {
            for (RcvPlanSts value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RcvPlanSts(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RcvPlanSts; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RcvPlanSts> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RcvPlanSts) { return OptionalThing.of((RcvPlanSts)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RcvPlanSts> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RcvPlanSts codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RcvPlanSts) { return (RcvPlanSts)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RcvPlanSts nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RcvPlanSts> listAll() {
            return new ArrayList<RcvPlanSts>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RcvPlanSts> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RcvPlanSts." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RcvPlanSts> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RcvPlanSts> clsList = new ArrayList<RcvPlanSts>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RcvPlanSts> groupOf(String groupName) {
            return new ArrayList<RcvPlanSts>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 論理ロケーションフラグ
     */
    public enum Virtuallocflg implements CDef {
        /** $0: 実ロケーション */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 論理ロケーション */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Virtuallocflg> _codeClsMap = new HashMap<String, Virtuallocflg>();
        private static final Map<String, Virtuallocflg> _nameClsMap = new HashMap<String, Virtuallocflg>();
        static {
            for (Virtuallocflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Virtuallocflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Virtuallocflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Virtuallocflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Virtuallocflg) { return OptionalThing.of((Virtuallocflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Virtuallocflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Virtuallocflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Virtuallocflg) { return (Virtuallocflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Virtuallocflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Virtuallocflg> listAll() {
            return new ArrayList<Virtuallocflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Virtuallocflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Virtuallocflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Virtuallocflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Virtuallocflg> clsList = new ArrayList<Virtuallocflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Virtuallocflg> groupOf(String groupName) {
            return new ArrayList<Virtuallocflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * り災品取扱区分
     */
    public enum SufferUsageFlg implements CDef {
        /** $0: 未登録 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 登録済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 解除 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, SufferUsageFlg> _codeClsMap = new HashMap<String, SufferUsageFlg>();
        private static final Map<String, SufferUsageFlg> _nameClsMap = new HashMap<String, SufferUsageFlg>();
        static {
            for (SufferUsageFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SufferUsageFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SufferUsageFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SufferUsageFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SufferUsageFlg) { return OptionalThing.of((SufferUsageFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SufferUsageFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SufferUsageFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SufferUsageFlg) { return (SufferUsageFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SufferUsageFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SufferUsageFlg> listAll() {
            return new ArrayList<SufferUsageFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SufferUsageFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SufferUsageFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SufferUsageFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SufferUsageFlg> clsList = new ArrayList<SufferUsageFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SufferUsageFlg> groupOf(String groupName) {
            return new ArrayList<SufferUsageFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 当日仕分完了フラグ
     */
    public enum Thedaysortingcompleteflg implements CDef {
        /** $0: 未完了 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 完了 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Thedaysortingcompleteflg> _codeClsMap = new HashMap<String, Thedaysortingcompleteflg>();
        private static final Map<String, Thedaysortingcompleteflg> _nameClsMap = new HashMap<String, Thedaysortingcompleteflg>();
        static {
            for (Thedaysortingcompleteflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Thedaysortingcompleteflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Thedaysortingcompleteflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Thedaysortingcompleteflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Thedaysortingcompleteflg) { return OptionalThing.of((Thedaysortingcompleteflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Thedaysortingcompleteflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Thedaysortingcompleteflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Thedaysortingcompleteflg) { return (Thedaysortingcompleteflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Thedaysortingcompleteflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Thedaysortingcompleteflg> listAll() {
            return new ArrayList<Thedaysortingcompleteflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Thedaysortingcompleteflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Thedaysortingcompleteflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Thedaysortingcompleteflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Thedaysortingcompleteflg> clsList = new ArrayList<Thedaysortingcompleteflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Thedaysortingcompleteflg> groupOf(String groupName) {
            return new ArrayList<Thedaysortingcompleteflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 適品・不適品区分
     */
    public enum Gooditemkbn implements CDef {
        /** $0: 適品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $9: 不適品 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, Gooditemkbn> _codeClsMap = new HashMap<String, Gooditemkbn>();
        private static final Map<String, Gooditemkbn> _nameClsMap = new HashMap<String, Gooditemkbn>();
        static {
            for (Gooditemkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Gooditemkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Gooditemkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Gooditemkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Gooditemkbn) { return OptionalThing.of((Gooditemkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Gooditemkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Gooditemkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Gooditemkbn) { return (Gooditemkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Gooditemkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Gooditemkbn> listAll() {
            return new ArrayList<Gooditemkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Gooditemkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Gooditemkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Gooditemkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Gooditemkbn> clsList = new ArrayList<Gooditemkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Gooditemkbn> groupOf(String groupName) {
            return new ArrayList<Gooditemkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 伝票タイプ
     */
    public enum Slptyp implements CDef {
        /** $ZO01: 定期配達 */
        $ZO01("ZO01", "$ZO01", emptyStrings())
        ,
        /** $ZO02: 定期宅配 */
        $ZO02("ZO02", "$ZO02", emptyStrings())
        ,
        /** $ZO03: 定期引取 */
        $ZO03("ZO03", "$ZO03", emptyStrings())
        ,
        /** $ZO04: さしず前予約引取 */
        $ZO04("ZO04", "$ZO04", emptyStrings())
        ,
        /** $ZO05: さしず後予約引取 */
        $ZO05("ZO05", "$ZO05", emptyStrings())
        ,
        /** $ZO06: CAP定期配達 */
        $ZO06("ZO06", "$ZO06", emptyStrings())
        ,
        /** $ZO07: CAP定期宅配 */
        $ZO07("ZO07", "$ZO07", emptyStrings())
        ,
        /** $ZO08: CAP定期引取 */
        $ZO08("ZO08", "$ZO08", emptyStrings())
        ,
        /** $ZO09: CAP引取 */
        $ZO09("ZO09", "$ZO09", emptyStrings())
        ,
        /** $ZO10: 宅配サービス */
        $ZO10("ZO10", "$ZO10", emptyStrings())
        ,
        /** $ZO11: さしず前臨時配達 */
        $ZO11("ZO11", "$ZO11", emptyStrings())
        ,
        /** $ZO15: CAP直送 */
        $ZO15("ZO15", "$ZO15", emptyStrings())
        ,
        /** $ZO18: 当日引取 */
        $ZO18("ZO18", "$ZO18", emptyStrings())
        ,
        /** $ZO22: 誤注当日引取 */
        $ZO22("ZO22", "$ZO22", emptyStrings())
        ,
        /** $ZO23: 誤注さしず後引取 */
        $ZO23("ZO23", "$ZO23", emptyStrings())
        ,
        /** $ZO24: 誤注さしず後臨配 */
        $ZO24("ZO24", "$ZO24", emptyStrings())
        ,
        /** $ZO25: 拡張臨時配達 */
        $ZO25("ZO25", "$ZO25", emptyStrings())
        ,
        /** $ZO31: EOS受注伝票1 */
        $ZO31("ZO31", "$ZO31", emptyStrings())
        ,
        /** $ZO32: EOS受注伝票2 */
        $ZO32("ZO32", "$ZO32", emptyStrings())
        ,
        /** $ZO33: EOS受注伝票3 */
        $ZO33("ZO33", "$ZO33", emptyStrings())
        ,
        /** $ZO34: EOS受注伝票4 */
        $ZO34("ZO34", "$ZO34", emptyStrings())
        ,
        /** $ZO35: EOS受注伝票5 */
        $ZO35("ZO35", "$ZO35", emptyStrings())
        ,
        /** $ZO36: EOS受注伝票6 */
        $ZO36("ZO36", "$ZO36", emptyStrings())
        ,
        /** $ZO37: EOS受注伝票7 */
        $ZO37("ZO37", "$ZO37", emptyStrings())
        ,
        /** $ZO38: EOS受注伝票8 */
        $ZO38("ZO38", "$ZO38", emptyStrings())
        ,
        /** $ZO71: 定期配達取替交付 */
        $ZO71("ZO71", "$ZO71", emptyStrings())
        ,
        /** $ZO72: 定期宅配取替交付 */
        $ZO72("ZO72", "$ZO72", emptyStrings())
        ,
        /** $ZO73: 定期引取取替交付 */
        $ZO73("ZO73", "$ZO73", emptyStrings())
        ,
        /** $ZO74: 当日引取取替交付 */
        $ZO74("ZO74", "$ZO74", emptyStrings())
        ,
        /** $ZO75: さしず前予約引取取替交付 */
        $ZO75("ZO75", "$ZO75", emptyStrings())
        ,
        /** $ZO76: さしず後予約引取取替交付 */
        $ZO76("ZO76", "$ZO76", emptyStrings())
        ,
        /** $ZO81: 担当区受入宅配 */
        $ZO81("ZO81", "$ZO81", emptyStrings())
        ,
        /** $ZO82: 当日担当区受入 */
        $ZO82("ZO82", "$ZO82", emptyStrings())
        ,
        /** $ZO83: さしず前担当区受入 */
        $ZO83("ZO83", "$ZO83", emptyStrings())
        ,
        /** $ZO84: さしず後担当区受入 */
        $ZO84("ZO84", "$ZO84", emptyStrings())
        ,
        /** $ZO86: 当日担当区払出 */
        $ZO86("ZO86", "$ZO86", emptyStrings())
        ,
        /** $ZO87: さしず前担当区払出 */
        $ZO87("ZO87", "$ZO87", emptyStrings())
        ,
        /** $ZO88: さしず後担当区払出 */
        $ZO88("ZO88", "$ZO88", emptyStrings())
        ,
        /** $ZO91: 卸代行宅配 */
        $ZO91("ZO91", "$ZO91", emptyStrings())
        ,
        /** $ZO92: 当日卸代行引渡 */
        $ZO92("ZO92", "$ZO92", emptyStrings())
        ,
        /** $ZO93: さしず前卸代行引渡 */
        $ZO93("ZO93", "$ZO93", emptyStrings())
        ,
        /** $ZO94: さしず後卸代行引渡 */
        $ZO94("ZO94", "$ZO94", emptyStrings())
        ,
        /** $ZO99: 卸代行CAP宅配 */
        $ZO99("ZO99", "$ZO99", emptyStrings())
        ,
        /** $ZZUB: 引取補填 */
        $ZZUB("ZZUB", "$ZZUB", emptyStrings())
        ,
        /** $ZZZZ: 商品 */
        $ZZZZ("ZZZZ", "$ZZZZ", emptyStrings())
        ;
        private static final Map<String, Slptyp> _codeClsMap = new HashMap<String, Slptyp>();
        private static final Map<String, Slptyp> _nameClsMap = new HashMap<String, Slptyp>();
        static {
            for (Slptyp value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Slptyp(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Slptyp; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Slptyp> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Slptyp) { return OptionalThing.of((Slptyp)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Slptyp> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Slptyp codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Slptyp) { return (Slptyp)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Slptyp nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Slptyp> listAll() {
            return new ArrayList<Slptyp>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Slptyp> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Slptyp." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Slptyp> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Slptyp> clsList = new ArrayList<Slptyp>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Slptyp> groupOf(String groupName) {
            return new ArrayList<Slptyp>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出庫ステータス(検索用)（在庫引当）
     */
    public enum SostatusForserch2 implements CDef {
        /** $0: 予定情報受信済 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 引当中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 引当済 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 棚出中以降 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 全件表示 */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, SostatusForserch2> _codeClsMap = new HashMap<String, SostatusForserch2>();
        private static final Map<String, SostatusForserch2> _nameClsMap = new HashMap<String, SostatusForserch2>();
        static {
            for (SostatusForserch2 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SostatusForserch2(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SostatusForserch2; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SostatusForserch2> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SostatusForserch2) { return OptionalThing.of((SostatusForserch2)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SostatusForserch2> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SostatusForserch2 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SostatusForserch2) { return (SostatusForserch2)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SostatusForserch2 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SostatusForserch2> listAll() {
            return new ArrayList<SostatusForserch2>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SostatusForserch2> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SostatusForserch2." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SostatusForserch2> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SostatusForserch2> clsList = new ArrayList<SostatusForserch2>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SostatusForserch2> groupOf(String groupName) {
            return new ArrayList<SostatusForserch2>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 順番区分
     */
    public enum LineOrderKbn implements CDef {
        /** $0: △ */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ▼ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LineOrderKbn> _codeClsMap = new HashMap<String, LineOrderKbn>();
        private static final Map<String, LineOrderKbn> _nameClsMap = new HashMap<String, LineOrderKbn>();
        static {
            for (LineOrderKbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LineOrderKbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LineOrderKbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LineOrderKbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LineOrderKbn) { return OptionalThing.of((LineOrderKbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LineOrderKbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LineOrderKbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LineOrderKbn) { return (LineOrderKbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LineOrderKbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LineOrderKbn> listAll() {
            return new ArrayList<LineOrderKbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LineOrderKbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LineOrderKbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LineOrderKbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LineOrderKbn> clsList = new ArrayList<LineOrderKbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LineOrderKbn> groupOf(String groupName) {
            return new ArrayList<LineOrderKbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 個口圧縮（ライン）
     */
    public enum Consolidationflg implements CDef {
        /** $0: 全同梱のみ */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対応ブロック1と同梱 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 対応ブロック2と同梱 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 個口圧縮なし */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Consolidationflg> _codeClsMap = new HashMap<String, Consolidationflg>();
        private static final Map<String, Consolidationflg> _nameClsMap = new HashMap<String, Consolidationflg>();
        static {
            for (Consolidationflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Consolidationflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Consolidationflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Consolidationflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Consolidationflg) { return OptionalThing.of((Consolidationflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Consolidationflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Consolidationflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Consolidationflg) { return (Consolidationflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Consolidationflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Consolidationflg> listAll() {
            return new ArrayList<Consolidationflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Consolidationflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Consolidationflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Consolidationflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Consolidationflg> clsList = new ArrayList<Consolidationflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Consolidationflg> groupOf(String groupName) {
            return new ArrayList<Consolidationflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕分曜日
     */
    public enum DaysOfWeek implements CDef {
        /** $1: (月) */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: (火) */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: (水) */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: (木) */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: (金) */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: (土) */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: (日) */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, DaysOfWeek> _codeClsMap = new HashMap<String, DaysOfWeek>();
        private static final Map<String, DaysOfWeek> _nameClsMap = new HashMap<String, DaysOfWeek>();
        static {
            for (DaysOfWeek value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DaysOfWeek(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DaysOfWeek; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DaysOfWeek> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DaysOfWeek) { return OptionalThing.of((DaysOfWeek)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DaysOfWeek> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DaysOfWeek codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DaysOfWeek) { return (DaysOfWeek)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DaysOfWeek nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DaysOfWeek> listAll() {
            return new ArrayList<DaysOfWeek>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DaysOfWeek> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DaysOfWeek." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DaysOfWeek> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DaysOfWeek> clsList = new ArrayList<DaysOfWeek>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DaysOfWeek> groupOf(String groupName) {
            return new ArrayList<DaysOfWeek>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロケーション区分
     */
    public enum Lockbn implements CDef {
        /** $0: 固定ロケ */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 不定ロケ（使用中） */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 不定ロケ（未使用） */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Lockbn> _codeClsMap = new HashMap<String, Lockbn>();
        private static final Map<String, Lockbn> _nameClsMap = new HashMap<String, Lockbn>();
        static {
            for (Lockbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Lockbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Lockbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Lockbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Lockbn) { return OptionalThing.of((Lockbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Lockbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Lockbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Lockbn) { return (Lockbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Lockbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Lockbn> listAll() {
            return new ArrayList<Lockbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Lockbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Lockbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Lockbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Lockbn> clsList = new ArrayList<Lockbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Lockbn> groupOf(String groupName) {
            return new ArrayList<Lockbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充切上単位
     */
    public enum ReplenishmentRoundedupUnit implements CDef {
        /** $a: 切り上げ無し */
        $a("a", "$a", emptyStrings())
        ,
        /** $b: ダンボール */
        $b("b", "$b", emptyStrings())
        ,
        /** $c: パレット */
        $c("c", "$c", emptyStrings())
        ,
        /** $d: カートン数指定 */
        $d("d", "$d", emptyStrings())
        ;
        private static final Map<String, ReplenishmentRoundedupUnit> _codeClsMap = new HashMap<String, ReplenishmentRoundedupUnit>();
        private static final Map<String, ReplenishmentRoundedupUnit> _nameClsMap = new HashMap<String, ReplenishmentRoundedupUnit>();
        static {
            for (ReplenishmentRoundedupUnit value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishmentRoundedupUnit(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishmentRoundedupUnit; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishmentRoundedupUnit> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishmentRoundedupUnit) { return OptionalThing.of((ReplenishmentRoundedupUnit)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishmentRoundedupUnit> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishmentRoundedupUnit codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishmentRoundedupUnit) { return (ReplenishmentRoundedupUnit)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishmentRoundedupUnit nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishmentRoundedupUnit> listAll() {
            return new ArrayList<ReplenishmentRoundedupUnit>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishmentRoundedupUnit> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishmentRoundedupUnit." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishmentRoundedupUnit> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishmentRoundedupUnit> clsList = new ArrayList<ReplenishmentRoundedupUnit>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishmentRoundedupUnit> groupOf(String groupName) {
            return new ArrayList<ReplenishmentRoundedupUnit>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充区分
     */
    public enum Restockkbn implements CDef {
        /** $a: A */
        $a("a", "$a", emptyStrings())
        ,
        /** $b: B */
        $b("b", "$b", emptyStrings())
        ,
        /** $c: C */
        $c("c", "$c", emptyStrings())
        ;
        private static final Map<String, Restockkbn> _codeClsMap = new HashMap<String, Restockkbn>();
        private static final Map<String, Restockkbn> _nameClsMap = new HashMap<String, Restockkbn>();
        static {
            for (Restockkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Restockkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Restockkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Restockkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Restockkbn) { return OptionalThing.of((Restockkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Restockkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Restockkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Restockkbn) { return (Restockkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Restockkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Restockkbn> listAll() {
            return new ArrayList<Restockkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Restockkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Restockkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Restockkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Restockkbn> clsList = new ArrayList<Restockkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Restockkbn> groupOf(String groupName) {
            return new ArrayList<Restockkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫区分
     */
    public enum Zaikodiv implements CDef {
        /** $20: 正常品 */
        $20("20", "$20", emptyStrings())
        ,
        /** $21: つぶれ */
        $21("21", "$21", emptyStrings())
        ,
        /** $24: 濡れ */
        $24("24", "$24", emptyStrings())
        ,
        /** $27: オイル */
        $27("27", "$27", emptyStrings())
        ,
        /** $28: 特荷 */
        $28("28", "$28", emptyStrings())
        ,
        /** $29: その他２ */
        $29("29", "$29", emptyStrings())
        ,
        /** $30: その他 */
        $30("30", "$30", emptyStrings())
        ,
        /** $31: ＯＴＨＥＲ */
        $31("31", "$31", emptyStrings())
        ,
        /** $32: 工場リワーク */
        $32("32", "$32", emptyStrings())
        ,
        /** $33: プリントER */
        $33("33", "$33", emptyStrings())
        ,
        /** $34: 予備1 */
        $34("34", "$34", emptyStrings())
        ,
        /** $35: 予備2 */
        $35("35", "$35", emptyStrings())
        ,
        /** $36: 予備3 */
        $36("36", "$36", emptyStrings())
        ,
        /** $37: 予備4 */
        $37("37", "$37", emptyStrings())
        ,
        /** $40: 検査済正常 */
        $40("40", "$40", emptyStrings())
        ,
        /** $41: 検査済つぶれ */
        $41("41", "$41", emptyStrings())
        ,
        /** $44: 検査済濡れ */
        $44("44", "$44", emptyStrings())
        ,
        /** $47: 検査済ｵｲﾙ */
        $47("47", "$47", emptyStrings())
        ,
        /** $48: 特荷不良品 */
        $48("48", "$48", emptyStrings())
        ,
        /** $49: 検査済その他２ */
        $49("49", "$49", emptyStrings())
        ,
        /** $50: 還付対象 */
        $50("50", "$50", emptyStrings())
        ,
        /** $60: 検査済その他 */
        $60("60", "$60", emptyStrings())
        ,
        /** $61: 検査済ＯＴＨＥＲ */
        $61("61", "$61", emptyStrings())
        ,
        /** $62: 検査済工場リワーク */
        $62("62", "$62", emptyStrings())
        ,
        /** $63: 検査済プリントER */
        $63("63", "$63", emptyStrings())
        ,
        /** $64: 検査済予備1 */
        $64("64", "$64", emptyStrings())
        ,
        /** $65: 検査済予備2 */
        $65("65", "$65", emptyStrings())
        ,
        /** $66: 検査済予備3 */
        $66("66", "$66", emptyStrings())
        ,
        /** $67: 検査済予備4 */
        $67("67", "$67", emptyStrings())
        ;
        private static final Map<String, Zaikodiv> _codeClsMap = new HashMap<String, Zaikodiv>();
        private static final Map<String, Zaikodiv> _nameClsMap = new HashMap<String, Zaikodiv>();
        static {
            for (Zaikodiv value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Zaikodiv(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Zaikodiv; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Zaikodiv> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Zaikodiv) { return OptionalThing.of((Zaikodiv)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Zaikodiv> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Zaikodiv codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Zaikodiv) { return (Zaikodiv)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Zaikodiv nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Zaikodiv> listAll() {
            return new ArrayList<Zaikodiv>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Zaikodiv> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Zaikodiv." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Zaikodiv> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Zaikodiv> clsList = new ArrayList<Zaikodiv>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Zaikodiv> groupOf(String groupName) {
            return new ArrayList<Zaikodiv>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 開封フラグ
     */
    public enum Openflg implements CDef {
        /** $0: 未開封 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 開封済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Openflg> _codeClsMap = new HashMap<String, Openflg>();
        private static final Map<String, Openflg> _nameClsMap = new HashMap<String, Openflg>();
        static {
            for (Openflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Openflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Openflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Openflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Openflg) { return OptionalThing.of((Openflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Openflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Openflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Openflg) { return (Openflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Openflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Openflg> listAll() {
            return new ArrayList<Openflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Openflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Openflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Openflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Openflg> clsList = new ArrayList<Openflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Openflg> groupOf(String groupName) {
            return new ArrayList<Openflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 当日作成ラベル枚数
     */
    public enum TodayPrintOnlyFlg implements CDef {
        /** $1: 当日作成分のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, TodayPrintOnlyFlg> _codeClsMap = new HashMap<String, TodayPrintOnlyFlg>();
        private static final Map<String, TodayPrintOnlyFlg> _nameClsMap = new HashMap<String, TodayPrintOnlyFlg>();
        static {
            for (TodayPrintOnlyFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TodayPrintOnlyFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TodayPrintOnlyFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TodayPrintOnlyFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TodayPrintOnlyFlg) { return OptionalThing.of((TodayPrintOnlyFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TodayPrintOnlyFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TodayPrintOnlyFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TodayPrintOnlyFlg) { return (TodayPrintOnlyFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TodayPrintOnlyFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TodayPrintOnlyFlg> listAll() {
            return new ArrayList<TodayPrintOnlyFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TodayPrintOnlyFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TodayPrintOnlyFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TodayPrintOnlyFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TodayPrintOnlyFlg> clsList = new ArrayList<TodayPrintOnlyFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TodayPrintOnlyFlg> groupOf(String groupName) {
            return new ArrayList<TodayPrintOnlyFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 開始終了
     */
    public enum StartEnd implements CDef {
        /** $1: 開始 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 終了 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, StartEnd> _codeClsMap = new HashMap<String, StartEnd>();
        private static final Map<String, StartEnd> _nameClsMap = new HashMap<String, StartEnd>();
        static {
            for (StartEnd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StartEnd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StartEnd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StartEnd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StartEnd) { return OptionalThing.of((StartEnd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StartEnd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StartEnd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StartEnd) { return (StartEnd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StartEnd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StartEnd> listAll() {
            return new ArrayList<StartEnd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StartEnd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StartEnd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StartEnd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StartEnd> clsList = new ArrayList<StartEnd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StartEnd> groupOf(String groupName) {
            return new ArrayList<StartEnd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 銘柄区分_JT輸入込みリスト
     */
    public enum SyhnKbnJt implements CDef {
        /** $A000: 国産 */
        $A000("A000", "$A000", emptyStrings())
        ,
        /** $0002: JT輸入 */
        $0002("0002", "$0002", emptyStrings())
        ,
        /** $0001: 輸入 */
        $0001("0001", "$0001", emptyStrings())
        ,
        /** $0000: 商品 */
        $0000("0000", "$0000", emptyStrings())
        ;
        private static final Map<String, SyhnKbnJt> _codeClsMap = new HashMap<String, SyhnKbnJt>();
        private static final Map<String, SyhnKbnJt> _nameClsMap = new HashMap<String, SyhnKbnJt>();
        static {
            for (SyhnKbnJt value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SyhnKbnJt(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SyhnKbnJt; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SyhnKbnJt> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SyhnKbnJt) { return OptionalThing.of((SyhnKbnJt)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SyhnKbnJt> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SyhnKbnJt codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SyhnKbnJt) { return (SyhnKbnJt)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SyhnKbnJt nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SyhnKbnJt> listAll() {
            return new ArrayList<SyhnKbnJt>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SyhnKbnJt> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SyhnKbnJt." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SyhnKbnJt> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SyhnKbnJt> clsList = new ArrayList<SyhnKbnJt>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SyhnKbnJt> groupOf(String groupName) {
            return new ArrayList<SyhnKbnJt>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 輸送区分
     */
    public enum Transkbn implements CDef {
        /** $0: TD */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 中継 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: CAP */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Transkbn> _codeClsMap = new HashMap<String, Transkbn>();
        private static final Map<String, Transkbn> _nameClsMap = new HashMap<String, Transkbn>();
        static {
            for (Transkbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Transkbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Transkbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Transkbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Transkbn) { return OptionalThing.of((Transkbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Transkbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Transkbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Transkbn) { return (Transkbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Transkbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Transkbn> listAll() {
            return new ArrayList<Transkbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Transkbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Transkbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Transkbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Transkbn> clsList = new ArrayList<Transkbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Transkbn> groupOf(String groupName) {
            return new ArrayList<Transkbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 車種
     */
    public enum Carknd implements CDef {
        /** $0: 0t */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 2t */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 4t */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 10t */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, Carknd> _codeClsMap = new HashMap<String, Carknd>();
        private static final Map<String, Carknd> _nameClsMap = new HashMap<String, Carknd>();
        static {
            for (Carknd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Carknd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Carknd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Carknd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Carknd) { return OptionalThing.of((Carknd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Carknd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Carknd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Carknd) { return (Carknd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Carknd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Carknd> listAll() {
            return new ArrayList<Carknd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Carknd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Carknd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Carknd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Carknd> clsList = new ArrayList<Carknd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Carknd> groupOf(String groupName) {
            return new ArrayList<Carknd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 0T表示拠点
     */
    public enum Cartypecmb0tdisp implements CDef {
        /** $3030: ＣＡＰセンター */
        $3030("3030", "$3030", emptyStrings())
        ;
        private static final Map<String, Cartypecmb0tdisp> _codeClsMap = new HashMap<String, Cartypecmb0tdisp>();
        private static final Map<String, Cartypecmb0tdisp> _nameClsMap = new HashMap<String, Cartypecmb0tdisp>();
        static {
            for (Cartypecmb0tdisp value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Cartypecmb0tdisp(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Cartypecmb0tdisp; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cartypecmb0tdisp> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Cartypecmb0tdisp) { return OptionalThing.of((Cartypecmb0tdisp)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Cartypecmb0tdisp> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Cartypecmb0tdisp codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Cartypecmb0tdisp) { return (Cartypecmb0tdisp)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Cartypecmb0tdisp nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Cartypecmb0tdisp> listAll() {
            return new ArrayList<Cartypecmb0tdisp>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Cartypecmb0tdisp> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Cartypecmb0tdisp." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Cartypecmb0tdisp> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Cartypecmb0tdisp> clsList = new ArrayList<Cartypecmb0tdisp>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Cartypecmb0tdisp> groupOf(String groupName) {
            return new ArrayList<Cartypecmb0tdisp>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 一次ピッキングリスト
     */
    public enum CenterPicListCls1 implements CDef {
        /** $0: オーダーピッキングリスト */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: トータルピッキングリスト */
        $1("1", "$1", emptyStrings())
        ,
        /** $4: ケースピッキングリスト */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: マルチピッキングリスト */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 単行ピッキングリスト */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, CenterPicListCls1> _codeClsMap = new HashMap<String, CenterPicListCls1>();
        private static final Map<String, CenterPicListCls1> _nameClsMap = new HashMap<String, CenterPicListCls1>();
        static {
            for (CenterPicListCls1 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterPicListCls1(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterPicListCls1; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls1> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterPicListCls1) { return OptionalThing.of((CenterPicListCls1)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls1> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls1 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterPicListCls1) { return (CenterPicListCls1)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls1 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterPicListCls1> listAll() {
            return new ArrayList<CenterPicListCls1>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterPicListCls1> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterPicListCls1." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterPicListCls1> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterPicListCls1> clsList = new ArrayList<CenterPicListCls1>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterPicListCls1> groupOf(String groupName) {
            return new ArrayList<CenterPicListCls1>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 二次ピッキングリスト
     */
    public enum CenterPicListCls2 implements CDef {
        /** $2: 摘み取りリスト */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 種蒔きリスト */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, CenterPicListCls2> _codeClsMap = new HashMap<String, CenterPicListCls2>();
        private static final Map<String, CenterPicListCls2> _nameClsMap = new HashMap<String, CenterPicListCls2>();
        static {
            for (CenterPicListCls2 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterPicListCls2(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterPicListCls2; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls2> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterPicListCls2) { return OptionalThing.of((CenterPicListCls2)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls2> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls2 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterPicListCls2) { return (CenterPicListCls2)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls2 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterPicListCls2> listAll() {
            return new ArrayList<CenterPicListCls2>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterPicListCls2> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterPicListCls2." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterPicListCls2> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterPicListCls2> clsList = new ArrayList<CenterPicListCls2>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterPicListCls2> groupOf(String groupName) {
            return new ArrayList<CenterPicListCls2>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状・荷札
     */
    public enum CenterPicListCls3 implements CDef {
        /** $1: 送り状＋バラ・ケース荷札 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 送り状＋バラ荷札 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 送り状＋ケース荷札 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 送り状 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: バラ・ケース荷札 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: バラ荷札 */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: ケース荷札 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, CenterPicListCls3> _codeClsMap = new HashMap<String, CenterPicListCls3>();
        private static final Map<String, CenterPicListCls3> _nameClsMap = new HashMap<String, CenterPicListCls3>();
        static {
            for (CenterPicListCls3 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterPicListCls3(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterPicListCls3; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls3> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterPicListCls3) { return OptionalThing.of((CenterPicListCls3)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls3> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls3 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterPicListCls3) { return (CenterPicListCls3)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls3 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterPicListCls3> listAll() {
            return new ArrayList<CenterPicListCls3>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterPicListCls3> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterPicListCls3." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterPicListCls3> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterPicListCls3> clsList = new ArrayList<CenterPicListCls3>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterPicListCls3> groupOf(String groupName) {
            return new ArrayList<CenterPicListCls3>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 佐川配達時間帯
     */
    public enum CenterSagawaDelivTz implements CDef {
        /** $01: 午前中 */
        $01("01", "$01", emptyStrings())
        ,
        /** $04: 18時～21時 */
        $04("04", "$04", emptyStrings())
        ,
        /** $12: 12時～14時 */
        $12("12", "$12", emptyStrings())
        ,
        /** $14: 14時～16時 */
        $14("14", "$14", emptyStrings())
        ,
        /** $16: 16時～18時 */
        $16("16", "$16", emptyStrings())
        ,
        /** $18: 18時～20時 */
        $18("18", "$18", emptyStrings())
        ,
        /** $19: 19時～21時 */
        $19("19", "$19", emptyStrings())
        ;
        private static final Map<String, CenterSagawaDelivTz> _codeClsMap = new HashMap<String, CenterSagawaDelivTz>();
        private static final Map<String, CenterSagawaDelivTz> _nameClsMap = new HashMap<String, CenterSagawaDelivTz>();
        static {
            for (CenterSagawaDelivTz value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterSagawaDelivTz(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterSagawaDelivTz; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSagawaDelivTz> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterSagawaDelivTz) { return OptionalThing.of((CenterSagawaDelivTz)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSagawaDelivTz> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterSagawaDelivTz codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterSagawaDelivTz) { return (CenterSagawaDelivTz)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterSagawaDelivTz nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterSagawaDelivTz> listAll() {
            return new ArrayList<CenterSagawaDelivTz>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterSagawaDelivTz> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterSagawaDelivTz." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterSagawaDelivTz> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterSagawaDelivTz> clsList = new ArrayList<CenterSagawaDelivTz>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterSagawaDelivTz> groupOf(String groupName) {
            return new ArrayList<CenterSagawaDelivTz>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 便種(商品)
     */
    public enum CenterTransportTypeItem implements CDef {
        /** $001: 指定なし */
        $001("001", "$001", emptyStrings())
        ,
        /** $002: 飛脚クール便(冷蔵) */
        $002("002", "$002", emptyStrings())
        ,
        /** $003: 飛脚クール便(冷凍) */
        $003("003", "$003", emptyStrings())
        ;
        private static final Map<String, CenterTransportTypeItem> _codeClsMap = new HashMap<String, CenterTransportTypeItem>();
        private static final Map<String, CenterTransportTypeItem> _nameClsMap = new HashMap<String, CenterTransportTypeItem>();
        static {
            for (CenterTransportTypeItem value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTransportTypeItem(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTransportTypeItem; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransportTypeItem> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTransportTypeItem) { return OptionalThing.of((CenterTransportTypeItem)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransportTypeItem> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTransportTypeItem codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTransportTypeItem) { return (CenterTransportTypeItem)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTransportTypeItem nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTransportTypeItem> listAll() {
            return new ArrayList<CenterTransportTypeItem>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTransportTypeItem> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTransportTypeItem." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTransportTypeItem> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTransportTypeItem> clsList = new ArrayList<CenterTransportTypeItem>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTransportTypeItem> groupOf(String groupName) {
            return new ArrayList<CenterTransportTypeItem>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷姿コード
     */
    public enum CenterSlipShapeCd implements CDef {
        /** $001: 箱類 */
        $001("001", "$001", emptyStrings())
        ,
        /** $002: バッグ類 */
        $002("002", "$002", emptyStrings())
        ,
        /** $003: スーツケース */
        $003("003", "$003", emptyStrings())
        ,
        /** $004: 封筒類 */
        $004("004", "$004", emptyStrings())
        ,
        /** $005: ゴルフバッグ */
        $005("005", "$005", emptyStrings())
        ,
        /** $006: スキー */
        $006("006", "$006", emptyStrings())
        ,
        /** $007: スノーボード */
        $007("007", "$007", emptyStrings())
        ,
        /** $008: その他 */
        $008("008", "$008", emptyStrings())
        ;
        private static final Map<String, CenterSlipShapeCd> _codeClsMap = new HashMap<String, CenterSlipShapeCd>();
        private static final Map<String, CenterSlipShapeCd> _nameClsMap = new HashMap<String, CenterSlipShapeCd>();
        static {
            for (CenterSlipShapeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterSlipShapeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterSlipShapeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSlipShapeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterSlipShapeCd) { return OptionalThing.of((CenterSlipShapeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSlipShapeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterSlipShapeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterSlipShapeCd) { return (CenterSlipShapeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterSlipShapeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterSlipShapeCd> listAll() {
            return new ArrayList<CenterSlipShapeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterSlipShapeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterSlipShapeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterSlipShapeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterSlipShapeCd> clsList = new ArrayList<CenterSlipShapeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterSlipShapeCd> groupOf(String groupName) {
            return new ArrayList<CenterSlipShapeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 便種(スピードで選択)
     */
    public enum CenterTransportTypeSpeed implements CDef {
        /** $000: 飛脚宅配便 */
        $000("000", "$000", emptyStrings())
        ,
        /** $001: 飛脚スーパー便 */
        $001("001", "$001", emptyStrings())
        ,
        /** $002: 飛脚即配便 */
        $002("002", "$002", emptyStrings())
        ,
        /** $003: 飛脚航空便(翌日中配達) */
        $003("003", "$003", emptyStrings())
        ,
        /** $004: 飛脚航空便(翌日午前中配達) */
        $004("004", "$004", emptyStrings())
        ,
        /** $005: 飛脚ジャストタイム便 */
        $005("005", "$005", emptyStrings())
        ;
        private static final Map<String, CenterTransportTypeSpeed> _codeClsMap = new HashMap<String, CenterTransportTypeSpeed>();
        private static final Map<String, CenterTransportTypeSpeed> _nameClsMap = new HashMap<String, CenterTransportTypeSpeed>();
        static {
            for (CenterTransportTypeSpeed value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTransportTypeSpeed(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTransportTypeSpeed; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransportTypeSpeed> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTransportTypeSpeed) { return OptionalThing.of((CenterTransportTypeSpeed)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransportTypeSpeed> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTransportTypeSpeed codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTransportTypeSpeed) { return (CenterTransportTypeSpeed)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTransportTypeSpeed nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTransportTypeSpeed> listAll() {
            return new ArrayList<CenterTransportTypeSpeed>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTransportTypeSpeed> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTransportTypeSpeed." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTransportTypeSpeed> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTransportTypeSpeed> clsList = new ArrayList<CenterTransportTypeSpeed>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTransportTypeSpeed> groupOf(String groupName) {
            return new ArrayList<CenterTransportTypeSpeed>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 指定シール
     */
    public enum CenterSealType implements CDef {
        /** $001: 飛脚クール便(冷蔵) */
        $001("001", "$001", emptyStrings())
        ,
        /** $002: 飛脚クール便(冷凍) */
        $002("002", "$002", emptyStrings())
        ,
        /** $003: 飛脚スーパー便 */
        $003("003", "$003", emptyStrings())
        ,
        /** $004: 営止めサービス */
        $004("004", "$004", emptyStrings())
        ,
        /** $005: 配達指定日 */
        $005("005", "$005", emptyStrings())
        ,
        /** $007: 時間帯指定(５時間帯) */
        $007("007", "$007", emptyStrings())
        ,
        /** $008: eコレクト(現金決済) */
        $008("008", "$008", emptyStrings())
        ,
        /** $009: eコレクト(デビット／クレジット決済) */
        $009("009", "$009", emptyStrings())
        ,
        /** $010: eコレクト(なんでも決済) */
        $010("010", "$010", emptyStrings())
        ,
        /** $011: 取扱注意 */
        $011("011", "$011", emptyStrings())
        ,
        /** $012: 貴重品 */
        $012("012", "$012", emptyStrings())
        ,
        /** $013: 天地無用 */
        $013("013", "$013", emptyStrings())
        ,
        /** $014: 飛脚即配便 */
        $014("014", "$014", emptyStrings())
        ,
        /** $016: 時間帯指定(午前中) */
        $016("016", "$016", emptyStrings())
        ,
        /** $017: 飛脚航空便 */
        $017("017", "$017", emptyStrings())
        ,
        /** $018: 飛脚ジャストタイム便 */
        $018("018", "$018", emptyStrings())
        ,
        /** $019: 時間帯指定(６時間帯(オプション) */
        $019("019", "$019", emptyStrings())
        ;
        private static final Map<String, CenterSealType> _codeClsMap = new HashMap<String, CenterSealType>();
        private static final Map<String, CenterSealType> _nameClsMap = new HashMap<String, CenterSealType>();
        static {
            for (CenterSealType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterSealType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterSealType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSealType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterSealType) { return OptionalThing.of((CenterSealType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSealType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterSealType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterSealType) { return (CenterSealType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterSealType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterSealType> listAll() {
            return new ArrayList<CenterSealType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterSealType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterSealType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterSealType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterSealType> clsList = new ArrayList<CenterSealType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterSealType> groupOf(String groupName) {
            return new ArrayList<CenterSealType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * データ種別
     */
    public enum CenterTagClass implements CDef {
        /** $01: ヤマト(通常) */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: ヤマト(保冷・・・冷蔵) */
        $02("02", "$02", emptyStrings())
        ,
        /** $11: 佐川(通常) */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 佐川(保冷・・・冷蔵) */
        $12("12", "$12", emptyStrings())
        ,
        /** $21: ゆうパック(通常) */
        $21("21", "$21", emptyStrings())
        ,
        /** $22: ゆうパック(保冷・・・冷蔵) */
        $22("22", "$22", emptyStrings())
        ;
        private static final Map<String, CenterTagClass> _codeClsMap = new HashMap<String, CenterTagClass>();
        private static final Map<String, CenterTagClass> _nameClsMap = new HashMap<String, CenterTagClass>();
        static {
            for (CenterTagClass value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTagClass(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTagClass; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagClass> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTagClass) { return OptionalThing.of((CenterTagClass)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagClass> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTagClass codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTagClass) { return (CenterTagClass)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTagClass nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTagClass> listAll() {
            return new ArrayList<CenterTagClass>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTagClass> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTagClass." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTagClass> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTagClass> clsList = new ArrayList<CenterTagClass>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTagClass> groupOf(String groupName) {
            return new ArrayList<CenterTagClass>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状データ種別
     */
    public enum CenterTagDataType implements CDef {
        /** $1: B2 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: E飛伝2 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: E飛伝Pro */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: ゆうパックプリントR(発送予定) */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: ゆうパックプリントR(発送履歴) */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 発送確定データフォーマット */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: 大口FDデータフォーマット */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, CenterTagDataType> _codeClsMap = new HashMap<String, CenterTagDataType>();
        private static final Map<String, CenterTagDataType> _nameClsMap = new HashMap<String, CenterTagDataType>();
        static {
            for (CenterTagDataType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTagDataType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTagDataType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagDataType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTagDataType) { return OptionalThing.of((CenterTagDataType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagDataType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTagDataType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTagDataType) { return (CenterTagDataType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTagDataType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTagDataType> listAll() {
            return new ArrayList<CenterTagDataType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTagDataType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTagDataType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTagDataType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTagDataType> clsList = new ArrayList<CenterTagDataType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTagDataType> groupOf(String groupName) {
            return new ArrayList<CenterTagDataType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状種別
     */
    public enum CenterTagType implements CDef {
        /** $1: 汎用荷札 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ヤマト宅急便(発払)荷札 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ヤマト宅急便(コレクト)荷札 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 佐川荷札(WebAPI) */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: ゆうパック荷札 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: ゆうパケット荷札 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, CenterTagType> _codeClsMap = new HashMap<String, CenterTagType>();
        private static final Map<String, CenterTagType> _nameClsMap = new HashMap<String, CenterTagType>();
        static {
            for (CenterTagType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTagType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTagType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTagType) { return OptionalThing.of((CenterTagType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTagType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTagType) { return (CenterTagType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTagType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTagType> listAll() {
            return new ArrayList<CenterTagType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTagType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTagType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTagType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTagType> clsList = new ArrayList<CenterTagType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTagType> groupOf(String groupName) {
            return new ArrayList<CenterTagType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状種別(代引時、2枚目以降)
     */
    public enum CenterTagTypeAfter implements CDef {
        /** $1: 汎用荷札 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ヤマト宅急便(発払)荷札 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ヤマト宅急便(コレクト)荷札 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 佐川荷札(WebAPI) */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: ゆうパック荷札 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: ゆうパケット荷札 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, CenterTagTypeAfter> _codeClsMap = new HashMap<String, CenterTagTypeAfter>();
        private static final Map<String, CenterTagTypeAfter> _nameClsMap = new HashMap<String, CenterTagTypeAfter>();
        static {
            for (CenterTagTypeAfter value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTagTypeAfter(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTagTypeAfter; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagTypeAfter> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTagTypeAfter) { return OptionalThing.of((CenterTagTypeAfter)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagTypeAfter> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTagTypeAfter codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTagTypeAfter) { return (CenterTagTypeAfter)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTagTypeAfter nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTagTypeAfter> listAll() {
            return new ArrayList<CenterTagTypeAfter>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTagTypeAfter> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTagTypeAfter." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTagTypeAfter> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTagTypeAfter> clsList = new ArrayList<CenterTagTypeAfter>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTagTypeAfter> groupOf(String groupName) {
            return new ArrayList<CenterTagTypeAfter>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI便種コード
     */
    public enum CenterApiBinsyuCode implements CDef {
        /** $000: 陸便 */
        $000("000", "$000", emptyStrings())
        ,
        /** $030: 航空便 */
        $030("030", "$030", emptyStrings())
        ,
        /** $140: クール冷蔵 */
        $140("140", "$140", emptyStrings())
        ,
        /** $141: クール冷蔵(航空便) */
        $141("141", "$141", emptyStrings())
        ,
        /** $150: クール冷凍 */
        $150("150", "$150", emptyStrings())
        ,
        /** $151: クール冷凍(航空便) */
        $151("151", "$151", emptyStrings())
        ;
        private static final Map<String, CenterApiBinsyuCode> _codeClsMap = new HashMap<String, CenterApiBinsyuCode>();
        private static final Map<String, CenterApiBinsyuCode> _nameClsMap = new HashMap<String, CenterApiBinsyuCode>();
        static {
            for (CenterApiBinsyuCode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiBinsyuCode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiBinsyuCode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiBinsyuCode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiBinsyuCode) { return OptionalThing.of((CenterApiBinsyuCode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiBinsyuCode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiBinsyuCode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiBinsyuCode) { return (CenterApiBinsyuCode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiBinsyuCode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiBinsyuCode> listAll() {
            return new ArrayList<CenterApiBinsyuCode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiBinsyuCode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiBinsyuCode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiBinsyuCode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiBinsyuCode> clsList = new ArrayList<CenterApiBinsyuCode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiBinsyuCode> groupOf(String groupName) {
            return new ArrayList<CenterApiBinsyuCode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI代引フラグ
     */
    public enum CenterApiDaibikiFlg implements CDef {
        /** $0: 通常の送り状を発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 代金引換の送り状を発行 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterApiDaibikiFlg> _codeClsMap = new HashMap<String, CenterApiDaibikiFlg>();
        private static final Map<String, CenterApiDaibikiFlg> _nameClsMap = new HashMap<String, CenterApiDaibikiFlg>();
        static {
            for (CenterApiDaibikiFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiDaibikiFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiDaibikiFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiDaibikiFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiDaibikiFlg) { return OptionalThing.of((CenterApiDaibikiFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiDaibikiFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiDaibikiFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiDaibikiFlg) { return (CenterApiDaibikiFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiDaibikiFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiDaibikiFlg> listAll() {
            return new ArrayList<CenterApiDaibikiFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiDaibikiFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiDaibikiFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiDaibikiFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiDaibikiFlg> clsList = new ArrayList<CenterApiDaibikiFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiDaibikiFlg> groupOf(String groupName) {
            return new ArrayList<CenterApiDaibikiFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI代引支払方法区分
     */
    public enum CenterApiDaibikiType implements CDef {
        /** $0: なんでも決済 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 現金 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: クレジットカード・デビットカード */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CenterApiDaibikiType> _codeClsMap = new HashMap<String, CenterApiDaibikiType>();
        private static final Map<String, CenterApiDaibikiType> _nameClsMap = new HashMap<String, CenterApiDaibikiType>();
        static {
            for (CenterApiDaibikiType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiDaibikiType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiDaibikiType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiDaibikiType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiDaibikiType) { return OptionalThing.of((CenterApiDaibikiType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiDaibikiType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiDaibikiType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiDaibikiType) { return (CenterApiDaibikiType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiDaibikiType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiDaibikiType> listAll() {
            return new ArrayList<CenterApiDaibikiType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiDaibikiType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiDaibikiType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiDaibikiType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiDaibikiType> clsList = new ArrayList<CenterApiDaibikiType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiDaibikiType> groupOf(String groupName) {
            return new ArrayList<CenterApiDaibikiType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI営止フラグ
     */
    public enum CenterApiEidomeFlg implements CDef {
        /** $0: 営業所止めを行いません */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 営業所止めにします */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterApiEidomeFlg> _codeClsMap = new HashMap<String, CenterApiEidomeFlg>();
        private static final Map<String, CenterApiEidomeFlg> _nameClsMap = new HashMap<String, CenterApiEidomeFlg>();
        static {
            for (CenterApiEidomeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiEidomeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiEidomeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiEidomeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiEidomeFlg) { return OptionalThing.of((CenterApiEidomeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiEidomeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiEidomeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiEidomeFlg) { return (CenterApiEidomeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiEidomeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiEidomeFlg> listAll() {
            return new ArrayList<CenterApiEidomeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiEidomeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiEidomeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiEidomeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiEidomeFlg> clsList = new ArrayList<CenterApiEidomeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiEidomeFlg> groupOf(String groupName) {
            return new ArrayList<CenterApiEidomeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI重量コード
     */
    public enum CenterApiWeightCd implements CDef {
        /** $60: 2Kg(サイズ60) */
        $60("60", "$60", emptyStrings())
        ,
        /** $80: 5Kg(サイズ80) */
        $80("80", "$80", emptyStrings())
        ,
        /** $100: 10Kg(サイズ100) */
        $100("100", "$100", emptyStrings())
        ,
        /** $140: 20Kg(サイズ140) */
        $140("140", "$140", emptyStrings())
        ,
        /** $160: 30Kg(サイズ160) */
        $160("160", "$160", emptyStrings())
        ;
        private static final Map<String, CenterApiWeightCd> _codeClsMap = new HashMap<String, CenterApiWeightCd>();
        private static final Map<String, CenterApiWeightCd> _nameClsMap = new HashMap<String, CenterApiWeightCd>();
        static {
            for (CenterApiWeightCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiWeightCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiWeightCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiWeightCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiWeightCd) { return OptionalThing.of((CenterApiWeightCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiWeightCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiWeightCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiWeightCd) { return (CenterApiWeightCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiWeightCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiWeightCd> listAll() {
            return new ArrayList<CenterApiWeightCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiWeightCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiWeightCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiWeightCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiWeightCd> clsList = new ArrayList<CenterApiWeightCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiWeightCd> groupOf(String groupName) {
            return new ArrayList<CenterApiWeightCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 発行対象のみ表示
     */
    public enum CenterOutputTargetFlg implements CDef {
        /** $1: 発行対象のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterOutputTargetFlg> _codeClsMap = new HashMap<String, CenterOutputTargetFlg>();
        private static final Map<String, CenterOutputTargetFlg> _nameClsMap = new HashMap<String, CenterOutputTargetFlg>();
        static {
            for (CenterOutputTargetFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterOutputTargetFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterOutputTargetFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterOutputTargetFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterOutputTargetFlg) { return OptionalThing.of((CenterOutputTargetFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterOutputTargetFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterOutputTargetFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterOutputTargetFlg) { return (CenterOutputTargetFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterOutputTargetFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterOutputTargetFlg> listAll() {
            return new ArrayList<CenterOutputTargetFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterOutputTargetFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterOutputTargetFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterOutputTargetFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterOutputTargetFlg> clsList = new ArrayList<CenterOutputTargetFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterOutputTargetFlg> groupOf(String groupName) {
            return new ArrayList<CenterOutputTargetFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未発行のみ表示
     */
    public enum CenterPrintCondition implements CDef {
        /** $1: 未発行のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterPrintCondition> _codeClsMap = new HashMap<String, CenterPrintCondition>();
        private static final Map<String, CenterPrintCondition> _nameClsMap = new HashMap<String, CenterPrintCondition>();
        static {
            for (CenterPrintCondition value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterPrintCondition(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterPrintCondition; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPrintCondition> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterPrintCondition) { return OptionalThing.of((CenterPrintCondition)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPrintCondition> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterPrintCondition codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterPrintCondition) { return (CenterPrintCondition)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterPrintCondition nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterPrintCondition> listAll() {
            return new ArrayList<CenterPrintCondition>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterPrintCondition> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterPrintCondition." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterPrintCondition> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterPrintCondition> clsList = new ArrayList<CenterPrintCondition>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterPrintCondition> groupOf(String groupName) {
            return new ArrayList<CenterPrintCondition>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * デザイン区分
     */
    public enum CenterDesignflg implements CDef {
        /** $00: 00 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 01 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 02 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 03 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 04 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 05 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 06 */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 07 */
        $07("07", "$07", emptyStrings())
        ,
        /** $10: 10 */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: 11 */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 12 */
        $12("12", "$12", emptyStrings())
        ,
        /** $20: 20 */
        $20("20", "$20", emptyStrings())
        ,
        /** $27: 27 */
        $27("27", "$27", emptyStrings())
        ,
        /** $28: 28 */
        $28("28", "$28", emptyStrings())
        ,
        /** $29: 29 */
        $29("29", "$29", emptyStrings())
        ,
        /** $30: 30 */
        $30("30", "$30", emptyStrings())
        ,
        /** $31: 31 */
        $31("31", "$31", emptyStrings())
        ,
        /** $32: 32 */
        $32("32", "$32", emptyStrings())
        ,
        /** $33: 33 */
        $33("33", "$33", emptyStrings())
        ,
        /** $34: 34 */
        $34("34", "$34", emptyStrings())
        ,
        /** $35: 35 */
        $35("35", "$35", emptyStrings())
        ,
        /** $37: 37 */
        $37("37", "$37", emptyStrings())
        ,
        /** $38: 38 */
        $38("38", "$38", emptyStrings())
        ,
        /** $39: 39 */
        $39("39", "$39", emptyStrings())
        ,
        /** $40: 40 */
        $40("40", "$40", emptyStrings())
        ,
        /** $47: 47 */
        $47("47", "$47", emptyStrings())
        ,
        /** $48: 48 */
        $48("48", "$48", emptyStrings())
        ,
        /** $49: 49 */
        $49("49", "$49", emptyStrings())
        ,
        /** $50: 50 */
        $50("50", "$50", emptyStrings())
        ,
        /** $60: 60 */
        $60("60", "$60", emptyStrings())
        ,
        /** $66: 66 */
        $66("66", "$66", emptyStrings())
        ,
        /** $67: 67 */
        $67("67", "$67", emptyStrings())
        ,
        /** $68: 68 */
        $68("68", "$68", emptyStrings())
        ,
        /** $69: 69 */
        $69("69", "$69", emptyStrings())
        ,
        /** $77: 77 */
        $77("77", "$77", emptyStrings())
        ,
        /** $88: 88 */
        $88("88", "$88", emptyStrings())
        ,
        /** $90: 90 */
        $90("90", "$90", emptyStrings())
        ,
        /** $96: 96 */
        $96("96", "$96", emptyStrings())
        ,
        /** $97: 97 */
        $97("97", "$97", emptyStrings())
        ,
        /** $98: 98 */
        $98("98", "$98", emptyStrings())
        ,
        /** $99: 99 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, CenterDesignflg> _codeClsMap = new HashMap<String, CenterDesignflg>();
        private static final Map<String, CenterDesignflg> _nameClsMap = new HashMap<String, CenterDesignflg>();
        static {
            for (CenterDesignflg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterDesignflg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterDesignflg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterDesignflg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterDesignflg) { return OptionalThing.of((CenterDesignflg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterDesignflg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterDesignflg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterDesignflg) { return (CenterDesignflg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterDesignflg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterDesignflg> listAll() {
            return new ArrayList<CenterDesignflg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterDesignflg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterDesignflg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterDesignflg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterDesignflg> clsList = new ArrayList<CenterDesignflg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterDesignflg> groupOf(String groupName) {
            return new ArrayList<CenterDesignflg>(4);
        }

        @Override public String toString() { return code(); }
    }

    public enum DefMeta implements ClassificationMeta {
        /** 処理区分マスタの処理区分CD */
        ProcessTypeCd
        ,
        /** 検品後納品明細出力対象 */
        AfterDelivSlipOutTgt
        ,
        /** 検品後荷札出力フラグ */
        AfterTagOutFlg
        ,
        /** 引当不可フラグ表示 */
        AllcNgDisplay
        ,
        /** 引当禁止フラグ */
        AllcNgFlg
        ,
        /** 引当ソートキー */
        AllocSortKey
        ,
        /** 全数出庫フラグ */
        AllShippingFlg
        ,
        /** 着店CDフォーマット */
        ArrivalStoreFormat
        ,
        /** 自動緊急フラグ設定フラグ */
        AutoEmgSetFlg
        ,
        /** 自動緊急フラグ判断対象 */
        AutoEmgSetTgt
        ,
        /** 自動印刷対象フラグ */
        AutoPrintTargetFlg
        ,
        /** 自動出庫指示フラグ */
        AutoShipInstFlg
        ,
        /** バーコード種別 */
        BarcodeType
        ,
        /** バッチ処理中フラグ */
        BatchProgressFlg
        ,
        /** 荷材選択スキップ */
        BoxSelectSkip
        ,
        /** キャンセルデータ表示 */
        CancelDataDisplay
        ,
        /** ケースピッキングフラグ */
        CasePicFlg
        ,
        /** センタ・荷主区分 */
        CenterClientCls
        ,
        /** センタ間移動フラグ */
        CenterTransitFlg
        ,
        /** 文字コード */
        CharacterCd
        ,
        /** 引当可能数0非表示 */
        ChargeQty0Display
        ,
        /** チェックディジット */
        CheckDigit
        ,
        /** 複数番号の有無 */
        CodeFlg
        ,
        /** 個別番号の種別 */
        CodeType
        ,
        /** 元着区分 */
        CodCls
        ,
        /** 元／着払／代引文字 */
        CodType
        ,
        /** 列型 */
        ColType
        ,
        /** コメント1有無 */
        CommentFlg
        ,
        /** 大口事業所フラグ */
        CompanyFlg
        ,
        /** クール区分 */
        CoolCls
        ,
        /** 保冷種別 */
        CoolType
        ,
        /** コピー対象テーブル */
        CopyTargetTable
        ,
        /** 赤黒区分 */
        CorrectType
        ,
        /** コミット区分 */
        DataInputCommitType
        ,
        /** 処理区分 */
        DataInputOperationType
        ,
        /** 処理区分 */
        DataInputProcessType
        ,
        /** 取込対象 */
        DataInputRange
        ,
        /** 取込種類 */
        DataInputType
        ,
        /** データ型 */
        DataType
        ,
        /** デフォルト */
        Default
        ,
        /** デフォルトフラグ */
        DefaultFlg
        ,
        /** 削除データ表示 */
        DeleteDataDisplay
        ,
        /** 納品先フラグ */
        DeliveryFlg
        ,
        /** 送付先一致フラグ */
        DelivMatchFlg
        ,
        /** 納品時間帯 */
        DelivTz
        ,
        /** 削除フラグ */
        DelFlg
        ,
        /** 預託先フラグ */
        DepositFlg
        ,
        /** 表示必須 */
        DisplayRequired
        ,
        /** 日付区分 */
        DtCls
        ,
        /** 編集可否 */
        Editable
        ,
        /** 緊急表示区分 */
        EmergencyDisplay
        ,
        /** 緊急フラグ */
        EmergencyFlg
        ,
        /** エラーフラグ */
        ErrorFlg
        ,
        /** エラー処理方法 */
        ErrorProcessMet
        ,
        /** 定点切れ */
        FixedPoint
        ,
        /** 強制確定フラグ */
        ForceFixedFlg
        ,
        /** 外貨フラグ */
        ForeignFlg
        ,
        /** ギフトフラグ */
        GiftFlg
        ,
        /** ギフト用納品書種別 */
        GiftStatementType
        ,
        /** HT文字認識使用フラグ */
        HtCharReadFlg
        ,
        /** 取込みフラグ */
        ImportFlg
        ,
        /** 終了したお知らせの表示 */
        InfoFlg
        ,
        /** 入出庫区分 */
        InoutType
        ,
        /** 入力区分 */
        InputType
        ,
        /** 検品フラグ */
        InspectionFlg
        ,
        /** 比較条件差異 */
        InventoryLocationProduct
        ,
        /** 送り状データ出力フラグ */
        InvoiceCreateFlg
        ,
        /** 項目型 */
        ItemType
        ,
        /** 最新フラグ */
        LastFlg
        ,
        /** 期限日管理フラグ */
        LimitDtManagFlg
        ,
        /** 期限日逆転防止フラグ */
        LimitDtReverseFlg
        ,
        /** 制限メッセージCD */
        LimitMessageCd
        ,
        /** 改行コード */
        LineFeedCd
        ,
        /** リスト発行フラグ */
        ListOutFlg
        ,
        /** リスト発行フラグ(一覧表示用) */
        ListOutFlgDisp
        ,
        /** 発行区分 */
        ListOutKbn
        ,
        /** 積込フラグ */
        LoadingFlg
        ,
        /** ロケーション種別 */
        LocationType
        ,
        /** ロックアウト */
        Lockout
        ,
        /** ログ明細ステータス */
        LogDtlStatus
        ,
        /** ログ明細種別 */
        LogDtlType
        ,
        /** ログステータス */
        LogStatus
        ,
        /** ロット管理フラグ */
        LotManagFlg
        ,
        /** ロット逆転防止フラグ */
        LotReverseFlg
        ,
        /** 入庫No.マージ区分 */
        MergeCls
        ,
        /** 名寄せ有無 */
        MergeFlg
        ,
        /** 属性 */
        MessageType
        ,
        /** 混載フラグ */
        MixedFlg
        ,
        /** 在庫移動指示ステータス */
        MoveInstStatus
        ,
        /** マルチピック計算区分 */
        MultiPicCls
        ,
        /** マルチピック計算フラグ */
        MultiPicFlg
        ,
        /** 必須 */
        Necessary
        ,
        /** 未完了のみ表示 */
        NotCompletedFlg
        ,
        /** 未出庫全件表示区分 */
        NoAllcDisplayFlg
        ,
        /** 未確定のみ表示 */
        NoConfirmedFlg
        ,
        /** 下積み厳禁区分 */
        NoStockCls
        ,
        /** 欠品無のみ表示 */
        NoStockOutFlg
        ,
        /** 逆さま厳禁区分 */
        NoUpsideDownCls
        ,
        /** ワンタイムフラグ */
        OnetimeFlg
        ,
        /** HT/SD過入荷可フラグ */
        OverStoreNumFlg
        ,
        /** 梱包計算処理区分 */
        PackingCalCls
        ,
        /** 梱包方法 */
        PackingProcessCls
        ,
        /** 個数口表示フラグ */
        PackingShowFlg
        ,
        /** 梱包ステータス */
        PackingStatus
        ,
        /** パスワードリセット */
        PasswordReset
        ,
        /** HT/SD過去日入力可フラグ */
        PastStoreDtFlg
        ,
        /** 削除 */
        PhysicalDelete
        ,
        /** 出庫フラグ */
        PickingFlg
        ,
        /** ピックロケフラグ */
        PickingLocationFlg
        ,
        /** 出庫ステータス */
        PickingStatus
        ,
        /** ピッキング方法 */
        PicCls
        ,
        /** 最適ピック提案ブレイクキー */
        PicMthdRcmdBreakKey
        ,
        /** 最適ピック提案フラグ */
        PicMthdRcmdFlg
        ,
        /** 最適ピックリスト出力フラグ */
        PicMthdRcmdListOut
        ,
        /** 郵便種別 */
        PostType
        ,
        /** 再印刷有無 */
        PrintedFlg
        ,
        /** 印刷データタイプ */
        PrintDataType
        ,
        /** エラーのみ */
        PrintErrorFlg
        ,
        /** 印刷キューステータス */
        PrintQueueStatus
        ,
        /** 印刷結果区分 */
        PrintResultClass
        ,
        /** 印刷サービスステータス */
        PrintServiceStatus
        ,
        /** 印刷ステータス */
        PrintStatus
        ,
        /** 優先フラグ */
        PriorityFlg
        ,
        /** 商品ラベルソースCDバーコード種別 */
        ProductLabelJanBarcode
        ,
        /** 商品ラベル出力単位 */
        ProductLabelOutUnit
        ,
        /** 商品ラベル商品CDバーコード種別 */
        ProductLabelProdBarcode
        ,
        /** 商品毎別梱包 */
        ProductPartPacking
        ,
        /** 商品種別コード */
        ProductTypeCode
        ,
        /** 0非表示 */
        Qty0Display
        ,
        /** 変更理由 */
        ReasonType
        ,
        /** 入荷納品ステータス */
        ReceiveDeliveryStatus
        ,
        /** 入荷フラグ */
        ReceiveFlg
        ,
        /** 入荷ステータス */
        ReceiveStatus
        ,
        /** 補充ロケ割付区分 */
        ReplenishAllocCls
        ,
        /** 補充商品CD未設定 */
        ReplenishProductCdUnset
        ,
        /** 補充点検索区分 */
        ReplenishSearchCls
        ,
        /** 補充単位区分 */
        ReplenishUnitCls
        ,
        /** 項目型 */
        ReportLayoutItemType
        ,
        /** 補充種別 */
        RestockType
        ,
        /** 実績入力後入庫/商品ラベル出力 */
        ResultAfterProductLabel
        ,
        /** 実績入力後入庫/商品ラベル出力対象 */
        ResultAfterProductTarget
        ,
        /** 期限日出荷制限フラグ */
        ReverseValidFlg
        ,
        /** 権限制御区分 */
        RoleControlClass
        ,
        /** 選択 */
        Select
        ,
        /** 印刷サービスステータス */
        SelectPrintServiceStatus
        ,
        /** 処理区分 */
        SerialOperationType
        ,
        /** 決済種別 */
        SettlementType
        ,
        /** 単行出荷検品荷札/納品明細出力区分 */
        SglRowInspAfterOutCls
        ,
        /** 単行ピックフラグ */
        SglRowPicFlg
        ,
        /** 部単位印刷要否 */
        SheetCollate
        ,
        /** 出荷フラグ */
        ShippingFlg
        ,
        /** 出荷ステータス */
        ShippingStatus
        ,
        /** 出荷停止フラグ */
        ShippingStopFlg
        ,
        /** 欠品表示区分 */
        ShortStockDisplay
        ,
        /** 出荷検品区分 */
        ShpCheckCls
        ,
        /** 未検品表示区分 */
        ShpCheckDisplay
        ,
        /** 送り状種別 */
        SlipType
        ,
        /** 操作音再生フラグ */
        SoundPlayFlg
        ,
        /** 在庫調整フラグ */
        StockAdjustFlg
        ,
        /** 在庫表示内容 */
        StockDisplayFld
        ,
        /** 在庫有のみフラグ */
        StockExistOnlyFlg
        ,
        /** 在庫調整フラグ */
        StockMoveFlg
        ,
        /** 在庫数 0非表示 */
        StockNum0Display
        ,
        /** 欠品時引当区分 */
        StockOutAllocCls
        ,
        /** 欠品時自動出庫指示フラグ */
        StockOutAutoInstFlg
        ,
        /** 欠品フラグ */
        StockOutFlg
        ,
        /** 欠品時出庫指示取消フラグ */
        StockOutInstCxlFlg
        ,
        /** 欠品時出荷指示分離フラグ */
        StockOutInstSplitFlg
        ,
        /** 在庫数表示 */
        StockQtyDisplay
        ,
        /** 棚卸データ有 */
        StockTakingInput
        ,
        /** 在庫対象 */
        StockTarget
        ,
        /** 入庫日管理フラグ */
        StoreDtFlg
        ,
        /** 格納フラグ */
        StoreFlg
        ,
        /** 入庫No.分割表示 */
        StoreNoDivideDisplay
        ,
        /** 入庫No.管理フラグ */
        StoreNoFlg
        ,
        /** 入庫No.マージフラグ */
        StoreNoMergeFlg
        ,
        /** システムログステータス */
        SystemLogStatus
        ,
        /** システムログ種別 */
        SystemLogType
        ,
        /** システム種別 */
        SystemType
        ,
        /** 荷札納品書在中出力フラグ */
        TagDeliveryOutFlg
        ,
        /** 作業日/出荷日/納品日区分 */
        TakingShippingDtFlg
        ,
        /** 作業日/出荷日区分 */
        TakingShippingFlg
        ,
        /** ターゲットウインドウ */
        TargetWindow
        ,
        /** 表示位置 */
        TextAlign
        ,
        /** トータルピックフラグ */
        TotalPicFlg
        ,
        /** 追跡番号採番単位 */
        TrackingNumberingUnit
        ,
        /** 積送中在庫のみ表示 */
        TransitDisplay
        ,
        /** アンマッチ有 */
        Unmatch
        ,
        /** 更新可否 */
        Updatable
        ,
        /** 修正コード */
        UpdCd
        ,
        /** 更新区分 */
        UpdType
        ,
        /** アップロードテーブル名 */
        UploadTableNm
        ,
        /** ユーザ編集可否 */
        UserEditable
        ,
        /** HT/SDケースピック使用フラグ */
        UseHtShipFlg
        ,
        /** 仕入先フラグ */
        VendorFlg
        ,
        /** 表示可否 */
        Visible
        ,
        /** 処理済フラグ */
        WorkFlg
        ,
        /** 作業メッセージ有無 */
        WorkMessageFlg
        ,
        /** ヤマト配達時間帯 */
        YamatoDelivTz
        ,
        /** ゆうパック配達時間帯 */
        YupackDelivTz
        ,
        /** 郵便番号フラグ */
        ZipFlg
        ,
        /** 出退勤・休憩 */
        AttendanceLeavingRest
        ,
        /** Bill of Lading出力対象フラグ */
        BolOutputTargetFlg
        ,
        /** Bill of Lading出力フラグ */
        BolOutFlg
        ,
        /** Call Before Delivery フラグCD */
        CallBeforeDeliveryFlg
        ,
        /** ケースピッキング対象 */
        CasePickFlg
        ,
        /** ケースピッキング対象 */
        CasePicTarget
        ,
        /** CES連携フラグ */
        CesIntegrationFlg
        ,
        /** Collect On Delivery フラグCD */
        CodFlg
        ,
        /** 小数有無フラグ */
        DecimalExistFlg
        ,
        /** 小数管理商品梱包単位 */
        DecimalProductPacking
        ,
        /** Do Not Stack Pallets フラグCD */
        DoNotStackStackFlg
        ,
        /** 緊急補充ゾーン補充荷姿 */
        EmReplenishShapeFlg
        ,
        /** Food フラグCD */
        FoogFlg
        ,
        /** Freezable Protection フラグCD */
        FreezableProtectionFlg
        ,
        /** Freight Class */
        FreightCls
        ,
        /** Guaranteed Plus フラグCD */
        GuaranteedPlusFlg
        ,
        /** Inside Delivery フラグCD (Collect) */
        InsideDeliveryCollectFlg
        ,
        /** Inside Delivery フラグCD (Prepaid) */
        InsideDeliveryPrepaidFlg
        ,
        /** Inside Pickup フラグCD (Collect) */
        InsidePickupCollectFlg
        ,
        /** Inside Pickup フラグCD (Prepaid) */
        InsidePickupPrepaidFlg
        ,
        /** 検品ラベル出力 */
        InspectionLabelOutFlg
        ,
        /** Liftgate at delivery フラグCD (Collect) */
        LiftgateDeliveryCollectFlg
        ,
        /** Liftgate at delivery フラグCD (Prepaid) */
        LiftgateDeliveryPrepaidFlg
        ,
        /** Liftgate at pickup フラグCD (Collect) */
        LiftgatePickupCollectFlg
        ,
        /** Liftgate at pickup フラグCD (Prepaid) */
        LiftgatePickupPrepaidFlg
        ,
        /** Limited Access Delivery フラグCD */
        LimitedAccessDeliveryFlg
        ,
        /** Limited Access Pickup フラグCD */
        LimitedAccessPickupFlg
        ,
        /** Over-Sized/Extreme Length フラグCD */
        OverSizedFlg
        ,
        /** 納品明細書自動発行フラグ */
        PackingSlipAutoOutputFlg
        ,
        /** Payment Term */
        PaymentTerm
        ,
        /** ピッキング種別 */
        PickingType
        ,
        /** Poison フラグCD */
        PoisonFlg
        ,
        /** 提案ピッキング方法 */
        RcmdPickingCls
        ,
        /** Residential Delivery フラグCD */
        ResidentialDeliveryFlg
        ,
        /** Residential Pickup フラグCD */
        ResidentialPickupFlg
        ,
        /** Saturday Delivery フラグCD */
        SatDeliveryFlg
        ,
        /** 単行ピッキング対象 */
        SglRowPicTarget
        ,
        /** Signature ReleaseフラグCD */
        SignatureReleaseFlg
        ,
        /** Signature Required フラグCD */
        SignatureRequiredFlg
        ,
        /** 郵便番号種別 */
        UploadZipType
        ,
        /** 作業実績出力フラグ */
        WorkLogOutFlg
        ,
        /** 作業ステータス */
        WorkStatus
        ,
        /** 滅却ステータス */
        Adjuststatus
        ,
        /** 組織区分 */
        Companygroup
        ,
        /** ロケーショングループ */
        LocGroup
        ,
        /** 作業区分 */
        Worktype
        ,
        /** CAP銘柄区分 */
        Capitemflg
        ,
        /** パレットはり紙ステータス */
        Palletests
        ,
        /** 銘柄マスタ使用区分1 */
        Usid
        ,
        /** 銘柄マスタ使用区分2 */
        Itemusedflg
        ,
        /** 段ボールステータス */
        Symbolsts
        ,
        /** 保税出庫関連リスト帳票区分 */
        Solistkbn
        ,
        /** パレットはり紙作成区分 */
        Palletaddflg
        ,
        /** 製品区分 */
        Productdiv
        ,
        /** 出庫経路区分 */
        Soroutediv
        ,
        /** 依頼種別 */
        Requesttype
        ,
        /** 検査ステータス */
        Examsts
        ,
        /** 受注番号付加コード */
        Ordernoaddcd
        ,
        /** 追跡区分 */
        Tracetype
        ,
        /** 倉庫識別 */
        Warehouseid
        ,
        /** 市場区分 */
        Markettype
        ,
        /** 保留フラグ */
        Reservationflg
        ,
        /** 製品包装形態 */
        Packingtype
        ,
        /** 製造記号パターン（国産） */
        Productmarkptn
        ,
        /** 製造記号パターン（BATJ） */
        Productmarkptnbatj
        ,
        /** 製造記号月コード */
        Productmarkmonth
        ,
        /** 賞味期限月数 */
        Limitdatemonth
        ,
        /** 引当可能賞味期限残月数 */
        Alclimitdatemonth
        ,
        /** ラベルレイアウトマスタ */
        Labellayoutmaster
        ,
        /** 輸送形態 */
        Trafficpattern
        ,
        /** たばこ区分 */
        Cgrid
        ,
        /** 帳票名 */
        Reportname
        ,
        /** 条件フラグ */
        Jyokenflg
        ,
        /** 移行用お得意様コード */
        Imshiptocode
        ,
        /** ファイル関連情報 */
        Fileinfo
        ,
        /** 出庫先変換マスタ */
        Shiptocdchg
        ,
        /** 流通センターマスタ */
        Tdwmscd
        ,
        /** 受払データタイプ */
        Inoutdatatype
        ,
        /** 荷動き在庫調査対象期間 */
        Invmoveterm
        ,
        /** シンボル貼付システム送信用HULFTマスタ */
        Symbolsendhulftmaster
        ,
        /** ログ出力フラグ */
        Logflag
        ,
        /** 詰合せ状態 */
        Assortmentsts
        ,
        /** 詰合せフラグ */
        Assortmentflg
        ,
        /** 検索用詰合せ状態 */
        Aststsforsearch
        ,
        /** １次検査開始送信フラグ */
        Firstexamsendflg
        ,
        /** MOS送信フラグ */
        Mossendflg
        ,
        /** ケース作成区分 */
        Casecreatetype
        ,
        /** MOS国産送信フラグ */
        Mosjtsendflg
        ,
        /** ＢＡＴ搬入依頼保管場所コード */
        Batkeepwarehousecd
        ,
        /** ＢＡＴ搬入依頼拠点コード */
        Batwarehousecd
        ,
        /** データ作成フラグ */
        Datamakeflg
        ,
        /** 搬入実績データ数量単位 */
        Rcvresultqtytype
        ,
        /** 品質検査実施フラグ */
        Qualityexamflg
        ,
        /** メーカーケースコード固定項目 */
        Makercasecodefixedvalue
        ,
        /** 製造記号（国免） */
        Productmarkjttaxfree
        ,
        /** 引当不能リスト（記入用）帳票出力定義 */
        PrinterdefS011
        ,
        /** 引当不能リスト（実績用）帳票出力定義 */
        PrinterdefS012
        ,
        /** パレットはり紙帳票出力定義（ＨＴ） */
        PrinterdefN002
        ,
        /** 分割はい替パレットはり紙帳票出力定義（ＨＴ） */
        PrinterdefZ005
        ,
        /** 仕分補充区分 */
        Sortstockkbn
        ,
        /** 追跡区分詳細 */
        Tracetypedt
        ,
        /** ラック間製品移動確認リスト印刷区分 */
        Racklabelprflg
        ,
        /** 山出しリスト（製品移動：仕分場）帳票出力定義（ＨＴ） */
        PrinterdefS0031
        ,
        /** 山出しリスト（製品移動：引取場）帳票出力定義（ＨＴ） */
        PrinterdefS0032
        ,
        /** 山出しリスト（製品移動：融通）帳票出力定義（ＨＴ） */
        PrinterdefS0033
        ,
        /** 山出しリスト（製品移動：その他）帳票出力定義（ＨＴ） */
        PrinterdefS0034
        ,
        /** 不明ケース判定 */
        Unknowncaselimit
        ,
        /** 仕分場在庫区分 */
        Sortinvkbn
        ,
        /** 前後ケース数 */
        Cloudcasenum
        ,
        /** 出荷区分 */
        Pulltype
        ,
        /** 保管場所 */
        Storageloc
        ,
        /** パレット追跡区分 */
        Pallettracetype
        ,
        /** 送信管理区分 */
        Datasendtype
        ,
        /** 追跡情報作成状態 */
        Tracecreatests
        ,
        /** 棚卸契機 */
        Sortinvtiming
        ,
        /** ケース補充先 */
        Casesupplytype
        ,
        /** 輸入在庫調査有無 */
        Importumu
        ,
        /** はり紙検品スキャン可否フラグ */
        Traceshiftflg
        ,
        /** 輸送形態コード */
        Shtypecd
        ,
        /** 輸入元コード */
        Allocpolicy
        ,
        /** 返送先拠点コード */
        Rtncompanyname
        ,
        /** 開差有無 */
        Opendiff
        ,
        /** 在庫有無 */
        ItemcdlookupAvailableflg
        ,
        /** 融通山出しリスト印刷区分 */
        Flexpickprflg
        ,
        /** 作業実績拡張マスタ */
        WorkmasterExp
        ,
        /** 作業実績区分 */
        Tasktype
        ,
        /** 作業実績区分詳細 */
        Tasktypedetail
        ,
        /** 融通山出しスキャン可否フラグ */
        Yztraceshiftflg
        ,
        /** 社員コード検索区分 */
        Workercdsearchtype
        ,
        /** 仕分場在庫調査製造年月日調査逆転リスト（仕分場）帳票出力定義（ＨＴ） */
        PrinterdefZ004
        ,
        /** 引取場在庫調査製造年月日調査逆転リスト（引取場）帳票出力定義（ＨＴ） */
        PrinterdefZ008
        ,
        /** 山出し先名称 */
        Pickdistname
        ,
        /** 製品追跡移行フラグ */
        Traceswitchflg
        ,
        /** ラベル区分 */
        Lblkbn
        ,
        /** 詰合せ区分 */
        Assortkbn
        ,
        /** ダミーケースコード */
        Dmycasecd
        ,
        /** 不適品ラベル削除区分 */
        Baditemdelkbn
        ,
        /** 最大検索件数 */
        Selectlimit
        ,
        /** 逆転補充リスト（うしろ補充）帳票出力定義（ＨＴ） */
        PrinterdefW001
        ,
        /** 逆転補充リスト（まえ補充）帳票出力定義（ＨＴ） */
        PrinterdefW002
        ,
        /** 決算たな卸月 */
        Settlementinvmonth
        ,
        /** 融通指示登録ステータス */
        Flexinstructsts
        ,
        /** 強制作成フラグ */
        Compulsionflg
        ,
        /** 月表示 */
        Displaymonth
        ,
        /** り災品取扱区分（検索用） */
        Sufferusagesearchflg
        ,
        /** 平置場基準在庫マスタ初期値 */
        Fltstdinv
        ,
        /** 販物Ⅲ移行フラグ */
        Cs3switchflg
        ,
        /** 過不足発生場所（不適品画面表示用） */
        Inadequacyarea
        ,
        /** 送信フラグ */
        Transmitflg
        ,
        /** 融通指示変更フラグ */
        Flalterflg
        ,
        /** 在庫照会処理ステータス */
        Invsts
        ,
        /** 同時実行ベース名 */
        Concurrentbase
        ,
        /** 同時実行名 */
        Concurrentname
        ,
        /** ケース単位出荷ステータス */
        Caseshipstatus
        ,
        /** NGP製品銘柄コード */
        Ngpitemcd
        ,
        /** 在庫凍結ロケーション */
        Fzloccd
        ,
        /** 拠点別仕分場在庫区分 */
        Whsortinvkbn
        ,
        /** 同期印刷帳票コード */
        Syncreportform
        ,
        /** 仕分場在庫調査対象外拠点コード */
        Sortwarehousecd
        ,
        /** 保税拠点コード */
        Hozeiwarehousecd
        ,
        /** 返品検品帳票出力定義（ＴＰＣ） */
        PrinterdefH002
        ,
        /** 帳票フォーム表示名称 */
        Reportformname
        ,
        /** 業務名称 */
        Taskname
        ,
        /** 情報元区分 */
        Whinvkbn
        ,
        /** 拠点別在庫照会明細取得処理区分 */
        Procflg
        ,
        /** 銘柄区分 */
        SyhnKbn
        ,
        /** パレット種別 */
        Pallettype
        ,
        /** 在庫調査区分 */
        InventoryInstKbn
        ,
        /** 出力帳票 */
        InventoryReport
        ,
        /** 山出し完了区分 */
        Completeflg
        ,
        /** 特定品目ロケフラグ */
        Oneitemonlyflg
        ,
        /** 特定荷主ロケフラグ */
        Oneowneronlyflg
        ,
        /** 保管タイプ */
        Picktype
        ,
        /** 入荷タイプ */
        Rcvtype
        ,
        /** 倉庫タイプ */
        Slottype
        ,
        /** CAP選択 */
        Capselect
        ,
        /** かし品・国税還付品区分 */
        Kashikokuzeikubn
        ,
        /** さしず有無区分 */
        Instructflg
        ,
        /** パレットはり紙出力方式 */
        Palleteoutputtype
        ,
        /** パレット分割区分 */
        Palletecuttingkbn
        ,
        /** フロントラック判定コード */
        Frontrackcd
        ,
        /** り災品区分 */
        Sufferflg
        ,
        /** 一致/不一致区分 */
        Unmatchflg
        ,
        /** 引当不能理由区分 */
        Alcimrsnflg
        ,
        /** 過不足発生場所 */
        Manyfewoccurarea
        ,
        /** 過不足発生場所（画面表示用） */
        Manyfewoccurareadisp
        ,
        /** 月替・デザイン切替区分 */
        Designchg
        ,
        /** 差異有無 */
        Differenceumu
        ,
        /** 在庫識別 */
        Stockdistinction
        ,
        /** 作業マスタ */
        Workmaster
        ,
        /** 山出しタイプ */
        Picklisttype
        ,
        /** 仕分場在庫区分 */
        Sortzaikbn
        ,
        /** 仕分単位 */
        Sorttype
        ,
        /** 取引方法 */
        Exchgmethod
        ,
        /** 状態コード */
        Conditionflg
        ,
        /** 数量調整未済区分 */
        Qtyadjustflg
        ,
        /** 送受信区分 */
        Inoutcode
        ,
        /** 棚卸方法 */
        Inventorytype
        ,
        /** 注意喚起区分 */
        Attensionflg
        ,
        /** 通常・異型品区分 */
        Formdiffflg
        ,
        /** 伝送区分 */
        Timingtype
        ,
        /** 内外区分 */
        Fcflg
        ,
        /** 日曜日フラグ */
        SundayFlg
        ,
        /** 複数製造月日区分 */
        Pluralproductionkbn
        ,
        /** 返品／取替区分 */
        Changeflg
        ,
        /** 返品ステータス */
        Rtnstatus
        ,
        /** 返品検品ステータス */
        Rtninspestatus
        ,
        /** 保管在庫区分 */
        Inventoryref
        ,
        /** 補充区分 */
        Restockflg
        ,
        /** 有効区分 */
        Validtype
        ,
        /** 返品変更理由 */
        Rtnchangedivision
        ,
        /** 格納場所 */
        Storagearea
        ,
        /** 在庫調査キーフラグ */
        Maxinvflg
        ,
        /** 保留区分 */
        Horyukbn
        ,
        /** 使用中区分 */
        Useflg
        ,
        /** 内外・国税還付品区分 */
        Fckokuflg
        ,
        /** カートン形状区分 */
        Bowltypeflg
        ,
        /** 保管場在庫区分 */
        Inventoryrefdisp
        ,
        /** 融通指示ステータス */
        Flinstrstatus
        ,
        /** 融通ステータス */
        Flexstatus
        ,
        /** 流通識別 */
        Distributioncd
        ,
        /** 格納場所区分 */
        Stocklocation
        ,
        /** 入庫ステータス */
        ResultStatus
        ,
        /** 箱種別 */
        BoxCategory
        ,
        /** 保管場所コード */
        Storagewarehousecd
        ,
        /** 売上種別 */
        Salestype
        ,
        /** 保税出庫関連リスト帳票区分(パレット内個体情報コード一覧以外) */
        Solistkbn2
        ,
        /** リスト発行区分 */
        PickingListType
        ,
        /** 対象管理区分 */
        CoveredClass
        ,
        /** 非対象管理区分 */
        NotCoveredClass
        ,
        /** 出庫作業ステータス */
        PickingWorkStatus
        ,
        /** 再印刷区分 */
        ReprintedFlg
        ,
        /** たばこ商品区分 */
        Cggdid
        ,
        /** 格納ステータス */
        RcvPlanSts
        ,
        /** 論理ロケーションフラグ */
        Virtuallocflg
        ,
        /** り災品取扱区分 */
        SufferUsageFlg
        ,
        /** 当日仕分完了フラグ */
        Thedaysortingcompleteflg
        ,
        /** 適品・不適品区分 */
        Gooditemkbn
        ,
        /** 伝票タイプ */
        Slptyp
        ,
        /** 出庫ステータス(検索用)（在庫引当） */
        SostatusForserch2
        ,
        /** 順番区分 */
        LineOrderKbn
        ,
        /** 個口圧縮（ライン） */
        Consolidationflg
        ,
        /** 仕分曜日 */
        DaysOfWeek
        ,
        /** ロケーション区分 */
        Lockbn
        ,
        /** 補充切上単位 */
        ReplenishmentRoundedupUnit
        ,
        /** 補充区分 */
        Restockkbn
        ,
        /** 在庫区分 */
        Zaikodiv
        ,
        /** 開封フラグ */
        Openflg
        ,
        /** 当日作成ラベル枚数 */
        TodayPrintOnlyFlg
        ,
        /** 開始終了 */
        StartEnd
        ,
        /** 銘柄区分_JT輸入込みリスト */
        SyhnKbnJt
        ,
        /** 輸送区分 */
        Transkbn
        ,
        /** 車種 */
        Carknd
        ,
        /** 0T表示拠点 */
        Cartypecmb0tdisp
        ,
        /** 一次ピッキングリスト */
        CenterPicListCls1
        ,
        /** 二次ピッキングリスト */
        CenterPicListCls2
        ,
        /** 送り状・荷札 */
        CenterPicListCls3
        ,
        /** 佐川配達時間帯 */
        CenterSagawaDelivTz
        ,
        /** 便種(商品) */
        CenterTransportTypeItem
        ,
        /** 荷姿コード */
        CenterSlipShapeCd
        ,
        /** 便種(スピードで選択) */
        CenterTransportTypeSpeed
        ,
        /** 指定シール */
        CenterSealType
        ,
        /** データ種別 */
        CenterTagClass
        ,
        /** 送り状データ種別 */
        CenterTagDataType
        ,
        /** 送り状種別 */
        CenterTagType
        ,
        /** 送り状種別(代引時、2枚目以降) */
        CenterTagTypeAfter
        ,
        /** WebAPI便種コード */
        CenterApiBinsyuCode
        ,
        /** WebAPI代引フラグ */
        CenterApiDaibikiFlg
        ,
        /** WebAPI代引支払方法区分 */
        CenterApiDaibikiType
        ,
        /** WebAPI営止フラグ */
        CenterApiEidomeFlg
        ,
        /** WebAPI重量コード */
        CenterApiWeightCd
        ,
        /** 発行対象のみ表示 */
        CenterOutputTargetFlg
        ,
        /** 未発行のみ表示 */
        CenterPrintCondition
        ,
        /** デザイン区分 */
        CenterDesignflg
        ;
        public String classificationName() {
            return name(); // same as definition name
        }

        public OptionalThing<? extends Classification> of(Object code) {
            if (ProcessTypeCd.name().equals(name())) { return CDef.ProcessTypeCd.of(code); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return CDef.AfterDelivSlipOutTgt.of(code); }
            if (AfterTagOutFlg.name().equals(name())) { return CDef.AfterTagOutFlg.of(code); }
            if (AllcNgDisplay.name().equals(name())) { return CDef.AllcNgDisplay.of(code); }
            if (AllcNgFlg.name().equals(name())) { return CDef.AllcNgFlg.of(code); }
            if (AllocSortKey.name().equals(name())) { return CDef.AllocSortKey.of(code); }
            if (AllShippingFlg.name().equals(name())) { return CDef.AllShippingFlg.of(code); }
            if (ArrivalStoreFormat.name().equals(name())) { return CDef.ArrivalStoreFormat.of(code); }
            if (AutoEmgSetFlg.name().equals(name())) { return CDef.AutoEmgSetFlg.of(code); }
            if (AutoEmgSetTgt.name().equals(name())) { return CDef.AutoEmgSetTgt.of(code); }
            if (AutoPrintTargetFlg.name().equals(name())) { return CDef.AutoPrintTargetFlg.of(code); }
            if (AutoShipInstFlg.name().equals(name())) { return CDef.AutoShipInstFlg.of(code); }
            if (BarcodeType.name().equals(name())) { return CDef.BarcodeType.of(code); }
            if (BatchProgressFlg.name().equals(name())) { return CDef.BatchProgressFlg.of(code); }
            if (BoxSelectSkip.name().equals(name())) { return CDef.BoxSelectSkip.of(code); }
            if (CancelDataDisplay.name().equals(name())) { return CDef.CancelDataDisplay.of(code); }
            if (CasePicFlg.name().equals(name())) { return CDef.CasePicFlg.of(code); }
            if (CenterClientCls.name().equals(name())) { return CDef.CenterClientCls.of(code); }
            if (CenterTransitFlg.name().equals(name())) { return CDef.CenterTransitFlg.of(code); }
            if (CharacterCd.name().equals(name())) { return CDef.CharacterCd.of(code); }
            if (ChargeQty0Display.name().equals(name())) { return CDef.ChargeQty0Display.of(code); }
            if (CheckDigit.name().equals(name())) { return CDef.CheckDigit.of(code); }
            if (CodeFlg.name().equals(name())) { return CDef.CodeFlg.of(code); }
            if (CodeType.name().equals(name())) { return CDef.CodeType.of(code); }
            if (CodCls.name().equals(name())) { return CDef.CodCls.of(code); }
            if (CodType.name().equals(name())) { return CDef.CodType.of(code); }
            if (ColType.name().equals(name())) { return CDef.ColType.of(code); }
            if (CommentFlg.name().equals(name())) { return CDef.CommentFlg.of(code); }
            if (CompanyFlg.name().equals(name())) { return CDef.CompanyFlg.of(code); }
            if (CoolCls.name().equals(name())) { return CDef.CoolCls.of(code); }
            if (CoolType.name().equals(name())) { return CDef.CoolType.of(code); }
            if (CopyTargetTable.name().equals(name())) { return CDef.CopyTargetTable.of(code); }
            if (CorrectType.name().equals(name())) { return CDef.CorrectType.of(code); }
            if (DataInputCommitType.name().equals(name())) { return CDef.DataInputCommitType.of(code); }
            if (DataInputOperationType.name().equals(name())) { return CDef.DataInputOperationType.of(code); }
            if (DataInputProcessType.name().equals(name())) { return CDef.DataInputProcessType.of(code); }
            if (DataInputRange.name().equals(name())) { return CDef.DataInputRange.of(code); }
            if (DataInputType.name().equals(name())) { return CDef.DataInputType.of(code); }
            if (DataType.name().equals(name())) { return CDef.DataType.of(code); }
            if (Default.name().equals(name())) { return CDef.Default.of(code); }
            if (DefaultFlg.name().equals(name())) { return CDef.DefaultFlg.of(code); }
            if (DeleteDataDisplay.name().equals(name())) { return CDef.DeleteDataDisplay.of(code); }
            if (DeliveryFlg.name().equals(name())) { return CDef.DeliveryFlg.of(code); }
            if (DelivMatchFlg.name().equals(name())) { return CDef.DelivMatchFlg.of(code); }
            if (DelivTz.name().equals(name())) { return CDef.DelivTz.of(code); }
            if (DelFlg.name().equals(name())) { return CDef.DelFlg.of(code); }
            if (DepositFlg.name().equals(name())) { return CDef.DepositFlg.of(code); }
            if (DisplayRequired.name().equals(name())) { return CDef.DisplayRequired.of(code); }
            if (DtCls.name().equals(name())) { return CDef.DtCls.of(code); }
            if (Editable.name().equals(name())) { return CDef.Editable.of(code); }
            if (EmergencyDisplay.name().equals(name())) { return CDef.EmergencyDisplay.of(code); }
            if (EmergencyFlg.name().equals(name())) { return CDef.EmergencyFlg.of(code); }
            if (ErrorFlg.name().equals(name())) { return CDef.ErrorFlg.of(code); }
            if (ErrorProcessMet.name().equals(name())) { return CDef.ErrorProcessMet.of(code); }
            if (FixedPoint.name().equals(name())) { return CDef.FixedPoint.of(code); }
            if (ForceFixedFlg.name().equals(name())) { return CDef.ForceFixedFlg.of(code); }
            if (ForeignFlg.name().equals(name())) { return CDef.ForeignFlg.of(code); }
            if (GiftFlg.name().equals(name())) { return CDef.GiftFlg.of(code); }
            if (GiftStatementType.name().equals(name())) { return CDef.GiftStatementType.of(code); }
            if (HtCharReadFlg.name().equals(name())) { return CDef.HtCharReadFlg.of(code); }
            if (ImportFlg.name().equals(name())) { return CDef.ImportFlg.of(code); }
            if (InfoFlg.name().equals(name())) { return CDef.InfoFlg.of(code); }
            if (InoutType.name().equals(name())) { return CDef.InoutType.of(code); }
            if (InputType.name().equals(name())) { return CDef.InputType.of(code); }
            if (InspectionFlg.name().equals(name())) { return CDef.InspectionFlg.of(code); }
            if (InventoryLocationProduct.name().equals(name())) { return CDef.InventoryLocationProduct.of(code); }
            if (InvoiceCreateFlg.name().equals(name())) { return CDef.InvoiceCreateFlg.of(code); }
            if (ItemType.name().equals(name())) { return CDef.ItemType.of(code); }
            if (LastFlg.name().equals(name())) { return CDef.LastFlg.of(code); }
            if (LimitDtManagFlg.name().equals(name())) { return CDef.LimitDtManagFlg.of(code); }
            if (LimitDtReverseFlg.name().equals(name())) { return CDef.LimitDtReverseFlg.of(code); }
            if (LimitMessageCd.name().equals(name())) { return CDef.LimitMessageCd.of(code); }
            if (LineFeedCd.name().equals(name())) { return CDef.LineFeedCd.of(code); }
            if (ListOutFlg.name().equals(name())) { return CDef.ListOutFlg.of(code); }
            if (ListOutFlgDisp.name().equals(name())) { return CDef.ListOutFlgDisp.of(code); }
            if (ListOutKbn.name().equals(name())) { return CDef.ListOutKbn.of(code); }
            if (LoadingFlg.name().equals(name())) { return CDef.LoadingFlg.of(code); }
            if (LocationType.name().equals(name())) { return CDef.LocationType.of(code); }
            if (Lockout.name().equals(name())) { return CDef.Lockout.of(code); }
            if (LogDtlStatus.name().equals(name())) { return CDef.LogDtlStatus.of(code); }
            if (LogDtlType.name().equals(name())) { return CDef.LogDtlType.of(code); }
            if (LogStatus.name().equals(name())) { return CDef.LogStatus.of(code); }
            if (LotManagFlg.name().equals(name())) { return CDef.LotManagFlg.of(code); }
            if (LotReverseFlg.name().equals(name())) { return CDef.LotReverseFlg.of(code); }
            if (MergeCls.name().equals(name())) { return CDef.MergeCls.of(code); }
            if (MergeFlg.name().equals(name())) { return CDef.MergeFlg.of(code); }
            if (MessageType.name().equals(name())) { return CDef.MessageType.of(code); }
            if (MixedFlg.name().equals(name())) { return CDef.MixedFlg.of(code); }
            if (MoveInstStatus.name().equals(name())) { return CDef.MoveInstStatus.of(code); }
            if (MultiPicCls.name().equals(name())) { return CDef.MultiPicCls.of(code); }
            if (MultiPicFlg.name().equals(name())) { return CDef.MultiPicFlg.of(code); }
            if (Necessary.name().equals(name())) { return CDef.Necessary.of(code); }
            if (NotCompletedFlg.name().equals(name())) { return CDef.NotCompletedFlg.of(code); }
            if (NoAllcDisplayFlg.name().equals(name())) { return CDef.NoAllcDisplayFlg.of(code); }
            if (NoConfirmedFlg.name().equals(name())) { return CDef.NoConfirmedFlg.of(code); }
            if (NoStockCls.name().equals(name())) { return CDef.NoStockCls.of(code); }
            if (NoStockOutFlg.name().equals(name())) { return CDef.NoStockOutFlg.of(code); }
            if (NoUpsideDownCls.name().equals(name())) { return CDef.NoUpsideDownCls.of(code); }
            if (OnetimeFlg.name().equals(name())) { return CDef.OnetimeFlg.of(code); }
            if (OverStoreNumFlg.name().equals(name())) { return CDef.OverStoreNumFlg.of(code); }
            if (PackingCalCls.name().equals(name())) { return CDef.PackingCalCls.of(code); }
            if (PackingProcessCls.name().equals(name())) { return CDef.PackingProcessCls.of(code); }
            if (PackingShowFlg.name().equals(name())) { return CDef.PackingShowFlg.of(code); }
            if (PackingStatus.name().equals(name())) { return CDef.PackingStatus.of(code); }
            if (PasswordReset.name().equals(name())) { return CDef.PasswordReset.of(code); }
            if (PastStoreDtFlg.name().equals(name())) { return CDef.PastStoreDtFlg.of(code); }
            if (PhysicalDelete.name().equals(name())) { return CDef.PhysicalDelete.of(code); }
            if (PickingFlg.name().equals(name())) { return CDef.PickingFlg.of(code); }
            if (PickingLocationFlg.name().equals(name())) { return CDef.PickingLocationFlg.of(code); }
            if (PickingStatus.name().equals(name())) { return CDef.PickingStatus.of(code); }
            if (PicCls.name().equals(name())) { return CDef.PicCls.of(code); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return CDef.PicMthdRcmdBreakKey.of(code); }
            if (PicMthdRcmdFlg.name().equals(name())) { return CDef.PicMthdRcmdFlg.of(code); }
            if (PicMthdRcmdListOut.name().equals(name())) { return CDef.PicMthdRcmdListOut.of(code); }
            if (PostType.name().equals(name())) { return CDef.PostType.of(code); }
            if (PrintedFlg.name().equals(name())) { return CDef.PrintedFlg.of(code); }
            if (PrintDataType.name().equals(name())) { return CDef.PrintDataType.of(code); }
            if (PrintErrorFlg.name().equals(name())) { return CDef.PrintErrorFlg.of(code); }
            if (PrintQueueStatus.name().equals(name())) { return CDef.PrintQueueStatus.of(code); }
            if (PrintResultClass.name().equals(name())) { return CDef.PrintResultClass.of(code); }
            if (PrintServiceStatus.name().equals(name())) { return CDef.PrintServiceStatus.of(code); }
            if (PrintStatus.name().equals(name())) { return CDef.PrintStatus.of(code); }
            if (PriorityFlg.name().equals(name())) { return CDef.PriorityFlg.of(code); }
            if (ProductLabelJanBarcode.name().equals(name())) { return CDef.ProductLabelJanBarcode.of(code); }
            if (ProductLabelOutUnit.name().equals(name())) { return CDef.ProductLabelOutUnit.of(code); }
            if (ProductLabelProdBarcode.name().equals(name())) { return CDef.ProductLabelProdBarcode.of(code); }
            if (ProductPartPacking.name().equals(name())) { return CDef.ProductPartPacking.of(code); }
            if (ProductTypeCode.name().equals(name())) { return CDef.ProductTypeCode.of(code); }
            if (Qty0Display.name().equals(name())) { return CDef.Qty0Display.of(code); }
            if (ReasonType.name().equals(name())) { return CDef.ReasonType.of(code); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return CDef.ReceiveDeliveryStatus.of(code); }
            if (ReceiveFlg.name().equals(name())) { return CDef.ReceiveFlg.of(code); }
            if (ReceiveStatus.name().equals(name())) { return CDef.ReceiveStatus.of(code); }
            if (ReplenishAllocCls.name().equals(name())) { return CDef.ReplenishAllocCls.of(code); }
            if (ReplenishProductCdUnset.name().equals(name())) { return CDef.ReplenishProductCdUnset.of(code); }
            if (ReplenishSearchCls.name().equals(name())) { return CDef.ReplenishSearchCls.of(code); }
            if (ReplenishUnitCls.name().equals(name())) { return CDef.ReplenishUnitCls.of(code); }
            if (ReportLayoutItemType.name().equals(name())) { return CDef.ReportLayoutItemType.of(code); }
            if (RestockType.name().equals(name())) { return CDef.RestockType.of(code); }
            if (ResultAfterProductLabel.name().equals(name())) { return CDef.ResultAfterProductLabel.of(code); }
            if (ResultAfterProductTarget.name().equals(name())) { return CDef.ResultAfterProductTarget.of(code); }
            if (ReverseValidFlg.name().equals(name())) { return CDef.ReverseValidFlg.of(code); }
            if (RoleControlClass.name().equals(name())) { return CDef.RoleControlClass.of(code); }
            if (Select.name().equals(name())) { return CDef.Select.of(code); }
            if (SelectPrintServiceStatus.name().equals(name())) { return CDef.SelectPrintServiceStatus.of(code); }
            if (SerialOperationType.name().equals(name())) { return CDef.SerialOperationType.of(code); }
            if (SettlementType.name().equals(name())) { return CDef.SettlementType.of(code); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return CDef.SglRowInspAfterOutCls.of(code); }
            if (SglRowPicFlg.name().equals(name())) { return CDef.SglRowPicFlg.of(code); }
            if (SheetCollate.name().equals(name())) { return CDef.SheetCollate.of(code); }
            if (ShippingFlg.name().equals(name())) { return CDef.ShippingFlg.of(code); }
            if (ShippingStatus.name().equals(name())) { return CDef.ShippingStatus.of(code); }
            if (ShippingStopFlg.name().equals(name())) { return CDef.ShippingStopFlg.of(code); }
            if (ShortStockDisplay.name().equals(name())) { return CDef.ShortStockDisplay.of(code); }
            if (ShpCheckCls.name().equals(name())) { return CDef.ShpCheckCls.of(code); }
            if (ShpCheckDisplay.name().equals(name())) { return CDef.ShpCheckDisplay.of(code); }
            if (SlipType.name().equals(name())) { return CDef.SlipType.of(code); }
            if (SoundPlayFlg.name().equals(name())) { return CDef.SoundPlayFlg.of(code); }
            if (StockAdjustFlg.name().equals(name())) { return CDef.StockAdjustFlg.of(code); }
            if (StockDisplayFld.name().equals(name())) { return CDef.StockDisplayFld.of(code); }
            if (StockExistOnlyFlg.name().equals(name())) { return CDef.StockExistOnlyFlg.of(code); }
            if (StockMoveFlg.name().equals(name())) { return CDef.StockMoveFlg.of(code); }
            if (StockNum0Display.name().equals(name())) { return CDef.StockNum0Display.of(code); }
            if (StockOutAllocCls.name().equals(name())) { return CDef.StockOutAllocCls.of(code); }
            if (StockOutAutoInstFlg.name().equals(name())) { return CDef.StockOutAutoInstFlg.of(code); }
            if (StockOutFlg.name().equals(name())) { return CDef.StockOutFlg.of(code); }
            if (StockOutInstCxlFlg.name().equals(name())) { return CDef.StockOutInstCxlFlg.of(code); }
            if (StockOutInstSplitFlg.name().equals(name())) { return CDef.StockOutInstSplitFlg.of(code); }
            if (StockQtyDisplay.name().equals(name())) { return CDef.StockQtyDisplay.of(code); }
            if (StockTakingInput.name().equals(name())) { return CDef.StockTakingInput.of(code); }
            if (StockTarget.name().equals(name())) { return CDef.StockTarget.of(code); }
            if (StoreDtFlg.name().equals(name())) { return CDef.StoreDtFlg.of(code); }
            if (StoreFlg.name().equals(name())) { return CDef.StoreFlg.of(code); }
            if (StoreNoDivideDisplay.name().equals(name())) { return CDef.StoreNoDivideDisplay.of(code); }
            if (StoreNoFlg.name().equals(name())) { return CDef.StoreNoFlg.of(code); }
            if (StoreNoMergeFlg.name().equals(name())) { return CDef.StoreNoMergeFlg.of(code); }
            if (SystemLogStatus.name().equals(name())) { return CDef.SystemLogStatus.of(code); }
            if (SystemLogType.name().equals(name())) { return CDef.SystemLogType.of(code); }
            if (SystemType.name().equals(name())) { return CDef.SystemType.of(code); }
            if (TagDeliveryOutFlg.name().equals(name())) { return CDef.TagDeliveryOutFlg.of(code); }
            if (TakingShippingDtFlg.name().equals(name())) { return CDef.TakingShippingDtFlg.of(code); }
            if (TakingShippingFlg.name().equals(name())) { return CDef.TakingShippingFlg.of(code); }
            if (TargetWindow.name().equals(name())) { return CDef.TargetWindow.of(code); }
            if (TextAlign.name().equals(name())) { return CDef.TextAlign.of(code); }
            if (TotalPicFlg.name().equals(name())) { return CDef.TotalPicFlg.of(code); }
            if (TrackingNumberingUnit.name().equals(name())) { return CDef.TrackingNumberingUnit.of(code); }
            if (TransitDisplay.name().equals(name())) { return CDef.TransitDisplay.of(code); }
            if (Unmatch.name().equals(name())) { return CDef.Unmatch.of(code); }
            if (Updatable.name().equals(name())) { return CDef.Updatable.of(code); }
            if (UpdCd.name().equals(name())) { return CDef.UpdCd.of(code); }
            if (UpdType.name().equals(name())) { return CDef.UpdType.of(code); }
            if (UploadTableNm.name().equals(name())) { return CDef.UploadTableNm.of(code); }
            if (UserEditable.name().equals(name())) { return CDef.UserEditable.of(code); }
            if (UseHtShipFlg.name().equals(name())) { return CDef.UseHtShipFlg.of(code); }
            if (VendorFlg.name().equals(name())) { return CDef.VendorFlg.of(code); }
            if (Visible.name().equals(name())) { return CDef.Visible.of(code); }
            if (WorkFlg.name().equals(name())) { return CDef.WorkFlg.of(code); }
            if (WorkMessageFlg.name().equals(name())) { return CDef.WorkMessageFlg.of(code); }
            if (YamatoDelivTz.name().equals(name())) { return CDef.YamatoDelivTz.of(code); }
            if (YupackDelivTz.name().equals(name())) { return CDef.YupackDelivTz.of(code); }
            if (ZipFlg.name().equals(name())) { return CDef.ZipFlg.of(code); }
            if (AttendanceLeavingRest.name().equals(name())) { return CDef.AttendanceLeavingRest.of(code); }
            if (BolOutputTargetFlg.name().equals(name())) { return CDef.BolOutputTargetFlg.of(code); }
            if (BolOutFlg.name().equals(name())) { return CDef.BolOutFlg.of(code); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return CDef.CallBeforeDeliveryFlg.of(code); }
            if (CasePickFlg.name().equals(name())) { return CDef.CasePickFlg.of(code); }
            if (CasePicTarget.name().equals(name())) { return CDef.CasePicTarget.of(code); }
            if (CesIntegrationFlg.name().equals(name())) { return CDef.CesIntegrationFlg.of(code); }
            if (CodFlg.name().equals(name())) { return CDef.CodFlg.of(code); }
            if (DecimalExistFlg.name().equals(name())) { return CDef.DecimalExistFlg.of(code); }
            if (DecimalProductPacking.name().equals(name())) { return CDef.DecimalProductPacking.of(code); }
            if (DoNotStackStackFlg.name().equals(name())) { return CDef.DoNotStackStackFlg.of(code); }
            if (EmReplenishShapeFlg.name().equals(name())) { return CDef.EmReplenishShapeFlg.of(code); }
            if (FoogFlg.name().equals(name())) { return CDef.FoogFlg.of(code); }
            if (FreezableProtectionFlg.name().equals(name())) { return CDef.FreezableProtectionFlg.of(code); }
            if (FreightCls.name().equals(name())) { return CDef.FreightCls.of(code); }
            if (GuaranteedPlusFlg.name().equals(name())) { return CDef.GuaranteedPlusFlg.of(code); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return CDef.InsideDeliveryCollectFlg.of(code); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return CDef.InsideDeliveryPrepaidFlg.of(code); }
            if (InsidePickupCollectFlg.name().equals(name())) { return CDef.InsidePickupCollectFlg.of(code); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return CDef.InsidePickupPrepaidFlg.of(code); }
            if (InspectionLabelOutFlg.name().equals(name())) { return CDef.InspectionLabelOutFlg.of(code); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return CDef.LiftgateDeliveryCollectFlg.of(code); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return CDef.LiftgateDeliveryPrepaidFlg.of(code); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return CDef.LiftgatePickupCollectFlg.of(code); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return CDef.LiftgatePickupPrepaidFlg.of(code); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return CDef.LimitedAccessDeliveryFlg.of(code); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return CDef.LimitedAccessPickupFlg.of(code); }
            if (OverSizedFlg.name().equals(name())) { return CDef.OverSizedFlg.of(code); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return CDef.PackingSlipAutoOutputFlg.of(code); }
            if (PaymentTerm.name().equals(name())) { return CDef.PaymentTerm.of(code); }
            if (PickingType.name().equals(name())) { return CDef.PickingType.of(code); }
            if (PoisonFlg.name().equals(name())) { return CDef.PoisonFlg.of(code); }
            if (RcmdPickingCls.name().equals(name())) { return CDef.RcmdPickingCls.of(code); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return CDef.ResidentialDeliveryFlg.of(code); }
            if (ResidentialPickupFlg.name().equals(name())) { return CDef.ResidentialPickupFlg.of(code); }
            if (SatDeliveryFlg.name().equals(name())) { return CDef.SatDeliveryFlg.of(code); }
            if (SglRowPicTarget.name().equals(name())) { return CDef.SglRowPicTarget.of(code); }
            if (SignatureReleaseFlg.name().equals(name())) { return CDef.SignatureReleaseFlg.of(code); }
            if (SignatureRequiredFlg.name().equals(name())) { return CDef.SignatureRequiredFlg.of(code); }
            if (UploadZipType.name().equals(name())) { return CDef.UploadZipType.of(code); }
            if (WorkLogOutFlg.name().equals(name())) { return CDef.WorkLogOutFlg.of(code); }
            if (WorkStatus.name().equals(name())) { return CDef.WorkStatus.of(code); }
            if (Adjuststatus.name().equals(name())) { return CDef.Adjuststatus.of(code); }
            if (Companygroup.name().equals(name())) { return CDef.Companygroup.of(code); }
            if (LocGroup.name().equals(name())) { return CDef.LocGroup.of(code); }
            if (Worktype.name().equals(name())) { return CDef.Worktype.of(code); }
            if (Capitemflg.name().equals(name())) { return CDef.Capitemflg.of(code); }
            if (Palletests.name().equals(name())) { return CDef.Palletests.of(code); }
            if (Usid.name().equals(name())) { return CDef.Usid.of(code); }
            if (Itemusedflg.name().equals(name())) { return CDef.Itemusedflg.of(code); }
            if (Symbolsts.name().equals(name())) { return CDef.Symbolsts.of(code); }
            if (Solistkbn.name().equals(name())) { return CDef.Solistkbn.of(code); }
            if (Palletaddflg.name().equals(name())) { return CDef.Palletaddflg.of(code); }
            if (Productdiv.name().equals(name())) { return CDef.Productdiv.of(code); }
            if (Soroutediv.name().equals(name())) { return CDef.Soroutediv.of(code); }
            if (Requesttype.name().equals(name())) { return CDef.Requesttype.of(code); }
            if (Examsts.name().equals(name())) { return CDef.Examsts.of(code); }
            if (Ordernoaddcd.name().equals(name())) { return CDef.Ordernoaddcd.of(code); }
            if (Tracetype.name().equals(name())) { return CDef.Tracetype.of(code); }
            if (Warehouseid.name().equals(name())) { return CDef.Warehouseid.of(code); }
            if (Markettype.name().equals(name())) { return CDef.Markettype.of(code); }
            if (Reservationflg.name().equals(name())) { return CDef.Reservationflg.of(code); }
            if (Packingtype.name().equals(name())) { return CDef.Packingtype.of(code); }
            if (Productmarkptn.name().equals(name())) { return CDef.Productmarkptn.of(code); }
            if (Productmarkptnbatj.name().equals(name())) { return CDef.Productmarkptnbatj.of(code); }
            if (Productmarkmonth.name().equals(name())) { return CDef.Productmarkmonth.of(code); }
            if (Limitdatemonth.name().equals(name())) { return CDef.Limitdatemonth.of(code); }
            if (Alclimitdatemonth.name().equals(name())) { return CDef.Alclimitdatemonth.of(code); }
            if (Labellayoutmaster.name().equals(name())) { return CDef.Labellayoutmaster.of(code); }
            if (Trafficpattern.name().equals(name())) { return CDef.Trafficpattern.of(code); }
            if (Cgrid.name().equals(name())) { return CDef.Cgrid.of(code); }
            if (Reportname.name().equals(name())) { return CDef.Reportname.of(code); }
            if (Jyokenflg.name().equals(name())) { return CDef.Jyokenflg.of(code); }
            if (Imshiptocode.name().equals(name())) { return CDef.Imshiptocode.of(code); }
            if (Fileinfo.name().equals(name())) { return CDef.Fileinfo.of(code); }
            if (Shiptocdchg.name().equals(name())) { return CDef.Shiptocdchg.of(code); }
            if (Tdwmscd.name().equals(name())) { return CDef.Tdwmscd.of(code); }
            if (Inoutdatatype.name().equals(name())) { return CDef.Inoutdatatype.of(code); }
            if (Invmoveterm.name().equals(name())) { return CDef.Invmoveterm.of(code); }
            if (Symbolsendhulftmaster.name().equals(name())) { return CDef.Symbolsendhulftmaster.of(code); }
            if (Logflag.name().equals(name())) { return CDef.Logflag.of(code); }
            if (Assortmentsts.name().equals(name())) { return CDef.Assortmentsts.of(code); }
            if (Assortmentflg.name().equals(name())) { return CDef.Assortmentflg.of(code); }
            if (Aststsforsearch.name().equals(name())) { return CDef.Aststsforsearch.of(code); }
            if (Firstexamsendflg.name().equals(name())) { return CDef.Firstexamsendflg.of(code); }
            if (Mossendflg.name().equals(name())) { return CDef.Mossendflg.of(code); }
            if (Casecreatetype.name().equals(name())) { return CDef.Casecreatetype.of(code); }
            if (Mosjtsendflg.name().equals(name())) { return CDef.Mosjtsendflg.of(code); }
            if (Batkeepwarehousecd.name().equals(name())) { return CDef.Batkeepwarehousecd.of(code); }
            if (Batwarehousecd.name().equals(name())) { return CDef.Batwarehousecd.of(code); }
            if (Datamakeflg.name().equals(name())) { return CDef.Datamakeflg.of(code); }
            if (Rcvresultqtytype.name().equals(name())) { return CDef.Rcvresultqtytype.of(code); }
            if (Qualityexamflg.name().equals(name())) { return CDef.Qualityexamflg.of(code); }
            if (Makercasecodefixedvalue.name().equals(name())) { return CDef.Makercasecodefixedvalue.of(code); }
            if (Productmarkjttaxfree.name().equals(name())) { return CDef.Productmarkjttaxfree.of(code); }
            if (PrinterdefS011.name().equals(name())) { return CDef.PrinterdefS011.of(code); }
            if (PrinterdefS012.name().equals(name())) { return CDef.PrinterdefS012.of(code); }
            if (PrinterdefN002.name().equals(name())) { return CDef.PrinterdefN002.of(code); }
            if (PrinterdefZ005.name().equals(name())) { return CDef.PrinterdefZ005.of(code); }
            if (Sortstockkbn.name().equals(name())) { return CDef.Sortstockkbn.of(code); }
            if (Tracetypedt.name().equals(name())) { return CDef.Tracetypedt.of(code); }
            if (Racklabelprflg.name().equals(name())) { return CDef.Racklabelprflg.of(code); }
            if (PrinterdefS0031.name().equals(name())) { return CDef.PrinterdefS0031.of(code); }
            if (PrinterdefS0032.name().equals(name())) { return CDef.PrinterdefS0032.of(code); }
            if (PrinterdefS0033.name().equals(name())) { return CDef.PrinterdefS0033.of(code); }
            if (PrinterdefS0034.name().equals(name())) { return CDef.PrinterdefS0034.of(code); }
            if (Unknowncaselimit.name().equals(name())) { return CDef.Unknowncaselimit.of(code); }
            if (Sortinvkbn.name().equals(name())) { return CDef.Sortinvkbn.of(code); }
            if (Cloudcasenum.name().equals(name())) { return CDef.Cloudcasenum.of(code); }
            if (Pulltype.name().equals(name())) { return CDef.Pulltype.of(code); }
            if (Storageloc.name().equals(name())) { return CDef.Storageloc.of(code); }
            if (Pallettracetype.name().equals(name())) { return CDef.Pallettracetype.of(code); }
            if (Datasendtype.name().equals(name())) { return CDef.Datasendtype.of(code); }
            if (Tracecreatests.name().equals(name())) { return CDef.Tracecreatests.of(code); }
            if (Sortinvtiming.name().equals(name())) { return CDef.Sortinvtiming.of(code); }
            if (Casesupplytype.name().equals(name())) { return CDef.Casesupplytype.of(code); }
            if (Importumu.name().equals(name())) { return CDef.Importumu.of(code); }
            if (Traceshiftflg.name().equals(name())) { return CDef.Traceshiftflg.of(code); }
            if (Shtypecd.name().equals(name())) { return CDef.Shtypecd.of(code); }
            if (Allocpolicy.name().equals(name())) { return CDef.Allocpolicy.of(code); }
            if (Rtncompanyname.name().equals(name())) { return CDef.Rtncompanyname.of(code); }
            if (Opendiff.name().equals(name())) { return CDef.Opendiff.of(code); }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return CDef.ItemcdlookupAvailableflg.of(code); }
            if (Flexpickprflg.name().equals(name())) { return CDef.Flexpickprflg.of(code); }
            if (WorkmasterExp.name().equals(name())) { return CDef.WorkmasterExp.of(code); }
            if (Tasktype.name().equals(name())) { return CDef.Tasktype.of(code); }
            if (Tasktypedetail.name().equals(name())) { return CDef.Tasktypedetail.of(code); }
            if (Yztraceshiftflg.name().equals(name())) { return CDef.Yztraceshiftflg.of(code); }
            if (Workercdsearchtype.name().equals(name())) { return CDef.Workercdsearchtype.of(code); }
            if (PrinterdefZ004.name().equals(name())) { return CDef.PrinterdefZ004.of(code); }
            if (PrinterdefZ008.name().equals(name())) { return CDef.PrinterdefZ008.of(code); }
            if (Pickdistname.name().equals(name())) { return CDef.Pickdistname.of(code); }
            if (Traceswitchflg.name().equals(name())) { return CDef.Traceswitchflg.of(code); }
            if (Lblkbn.name().equals(name())) { return CDef.Lblkbn.of(code); }
            if (Assortkbn.name().equals(name())) { return CDef.Assortkbn.of(code); }
            if (Dmycasecd.name().equals(name())) { return CDef.Dmycasecd.of(code); }
            if (Baditemdelkbn.name().equals(name())) { return CDef.Baditemdelkbn.of(code); }
            if (Selectlimit.name().equals(name())) { return CDef.Selectlimit.of(code); }
            if (PrinterdefW001.name().equals(name())) { return CDef.PrinterdefW001.of(code); }
            if (PrinterdefW002.name().equals(name())) { return CDef.PrinterdefW002.of(code); }
            if (Settlementinvmonth.name().equals(name())) { return CDef.Settlementinvmonth.of(code); }
            if (Flexinstructsts.name().equals(name())) { return CDef.Flexinstructsts.of(code); }
            if (Compulsionflg.name().equals(name())) { return CDef.Compulsionflg.of(code); }
            if (Displaymonth.name().equals(name())) { return CDef.Displaymonth.of(code); }
            if (Sufferusagesearchflg.name().equals(name())) { return CDef.Sufferusagesearchflg.of(code); }
            if (Fltstdinv.name().equals(name())) { return CDef.Fltstdinv.of(code); }
            if (Cs3switchflg.name().equals(name())) { return CDef.Cs3switchflg.of(code); }
            if (Inadequacyarea.name().equals(name())) { return CDef.Inadequacyarea.of(code); }
            if (Transmitflg.name().equals(name())) { return CDef.Transmitflg.of(code); }
            if (Flalterflg.name().equals(name())) { return CDef.Flalterflg.of(code); }
            if (Invsts.name().equals(name())) { return CDef.Invsts.of(code); }
            if (Concurrentbase.name().equals(name())) { return CDef.Concurrentbase.of(code); }
            if (Concurrentname.name().equals(name())) { return CDef.Concurrentname.of(code); }
            if (Caseshipstatus.name().equals(name())) { return CDef.Caseshipstatus.of(code); }
            if (Ngpitemcd.name().equals(name())) { return CDef.Ngpitemcd.of(code); }
            if (Fzloccd.name().equals(name())) { return CDef.Fzloccd.of(code); }
            if (Whsortinvkbn.name().equals(name())) { return CDef.Whsortinvkbn.of(code); }
            if (Syncreportform.name().equals(name())) { return CDef.Syncreportform.of(code); }
            if (Sortwarehousecd.name().equals(name())) { return CDef.Sortwarehousecd.of(code); }
            if (Hozeiwarehousecd.name().equals(name())) { return CDef.Hozeiwarehousecd.of(code); }
            if (PrinterdefH002.name().equals(name())) { return CDef.PrinterdefH002.of(code); }
            if (Reportformname.name().equals(name())) { return CDef.Reportformname.of(code); }
            if (Taskname.name().equals(name())) { return CDef.Taskname.of(code); }
            if (Whinvkbn.name().equals(name())) { return CDef.Whinvkbn.of(code); }
            if (Procflg.name().equals(name())) { return CDef.Procflg.of(code); }
            if (SyhnKbn.name().equals(name())) { return CDef.SyhnKbn.of(code); }
            if (Pallettype.name().equals(name())) { return CDef.Pallettype.of(code); }
            if (InventoryInstKbn.name().equals(name())) { return CDef.InventoryInstKbn.of(code); }
            if (InventoryReport.name().equals(name())) { return CDef.InventoryReport.of(code); }
            if (Completeflg.name().equals(name())) { return CDef.Completeflg.of(code); }
            if (Oneitemonlyflg.name().equals(name())) { return CDef.Oneitemonlyflg.of(code); }
            if (Oneowneronlyflg.name().equals(name())) { return CDef.Oneowneronlyflg.of(code); }
            if (Picktype.name().equals(name())) { return CDef.Picktype.of(code); }
            if (Rcvtype.name().equals(name())) { return CDef.Rcvtype.of(code); }
            if (Slottype.name().equals(name())) { return CDef.Slottype.of(code); }
            if (Capselect.name().equals(name())) { return CDef.Capselect.of(code); }
            if (Kashikokuzeikubn.name().equals(name())) { return CDef.Kashikokuzeikubn.of(code); }
            if (Instructflg.name().equals(name())) { return CDef.Instructflg.of(code); }
            if (Palleteoutputtype.name().equals(name())) { return CDef.Palleteoutputtype.of(code); }
            if (Palletecuttingkbn.name().equals(name())) { return CDef.Palletecuttingkbn.of(code); }
            if (Frontrackcd.name().equals(name())) { return CDef.Frontrackcd.of(code); }
            if (Sufferflg.name().equals(name())) { return CDef.Sufferflg.of(code); }
            if (Unmatchflg.name().equals(name())) { return CDef.Unmatchflg.of(code); }
            if (Alcimrsnflg.name().equals(name())) { return CDef.Alcimrsnflg.of(code); }
            if (Manyfewoccurarea.name().equals(name())) { return CDef.Manyfewoccurarea.of(code); }
            if (Manyfewoccurareadisp.name().equals(name())) { return CDef.Manyfewoccurareadisp.of(code); }
            if (Designchg.name().equals(name())) { return CDef.Designchg.of(code); }
            if (Differenceumu.name().equals(name())) { return CDef.Differenceumu.of(code); }
            if (Stockdistinction.name().equals(name())) { return CDef.Stockdistinction.of(code); }
            if (Workmaster.name().equals(name())) { return CDef.Workmaster.of(code); }
            if (Picklisttype.name().equals(name())) { return CDef.Picklisttype.of(code); }
            if (Sortzaikbn.name().equals(name())) { return CDef.Sortzaikbn.of(code); }
            if (Sorttype.name().equals(name())) { return CDef.Sorttype.of(code); }
            if (Exchgmethod.name().equals(name())) { return CDef.Exchgmethod.of(code); }
            if (Conditionflg.name().equals(name())) { return CDef.Conditionflg.of(code); }
            if (Qtyadjustflg.name().equals(name())) { return CDef.Qtyadjustflg.of(code); }
            if (Inoutcode.name().equals(name())) { return CDef.Inoutcode.of(code); }
            if (Inventorytype.name().equals(name())) { return CDef.Inventorytype.of(code); }
            if (Attensionflg.name().equals(name())) { return CDef.Attensionflg.of(code); }
            if (Formdiffflg.name().equals(name())) { return CDef.Formdiffflg.of(code); }
            if (Timingtype.name().equals(name())) { return CDef.Timingtype.of(code); }
            if (Fcflg.name().equals(name())) { return CDef.Fcflg.of(code); }
            if (SundayFlg.name().equals(name())) { return CDef.SundayFlg.of(code); }
            if (Pluralproductionkbn.name().equals(name())) { return CDef.Pluralproductionkbn.of(code); }
            if (Changeflg.name().equals(name())) { return CDef.Changeflg.of(code); }
            if (Rtnstatus.name().equals(name())) { return CDef.Rtnstatus.of(code); }
            if (Rtninspestatus.name().equals(name())) { return CDef.Rtninspestatus.of(code); }
            if (Inventoryref.name().equals(name())) { return CDef.Inventoryref.of(code); }
            if (Restockflg.name().equals(name())) { return CDef.Restockflg.of(code); }
            if (Validtype.name().equals(name())) { return CDef.Validtype.of(code); }
            if (Rtnchangedivision.name().equals(name())) { return CDef.Rtnchangedivision.of(code); }
            if (Storagearea.name().equals(name())) { return CDef.Storagearea.of(code); }
            if (Maxinvflg.name().equals(name())) { return CDef.Maxinvflg.of(code); }
            if (Horyukbn.name().equals(name())) { return CDef.Horyukbn.of(code); }
            if (Useflg.name().equals(name())) { return CDef.Useflg.of(code); }
            if (Fckokuflg.name().equals(name())) { return CDef.Fckokuflg.of(code); }
            if (Bowltypeflg.name().equals(name())) { return CDef.Bowltypeflg.of(code); }
            if (Inventoryrefdisp.name().equals(name())) { return CDef.Inventoryrefdisp.of(code); }
            if (Flinstrstatus.name().equals(name())) { return CDef.Flinstrstatus.of(code); }
            if (Flexstatus.name().equals(name())) { return CDef.Flexstatus.of(code); }
            if (Distributioncd.name().equals(name())) { return CDef.Distributioncd.of(code); }
            if (Stocklocation.name().equals(name())) { return CDef.Stocklocation.of(code); }
            if (ResultStatus.name().equals(name())) { return CDef.ResultStatus.of(code); }
            if (BoxCategory.name().equals(name())) { return CDef.BoxCategory.of(code); }
            if (Storagewarehousecd.name().equals(name())) { return CDef.Storagewarehousecd.of(code); }
            if (Salestype.name().equals(name())) { return CDef.Salestype.of(code); }
            if (Solistkbn2.name().equals(name())) { return CDef.Solistkbn2.of(code); }
            if (PickingListType.name().equals(name())) { return CDef.PickingListType.of(code); }
            if (CoveredClass.name().equals(name())) { return CDef.CoveredClass.of(code); }
            if (NotCoveredClass.name().equals(name())) { return CDef.NotCoveredClass.of(code); }
            if (PickingWorkStatus.name().equals(name())) { return CDef.PickingWorkStatus.of(code); }
            if (ReprintedFlg.name().equals(name())) { return CDef.ReprintedFlg.of(code); }
            if (Cggdid.name().equals(name())) { return CDef.Cggdid.of(code); }
            if (RcvPlanSts.name().equals(name())) { return CDef.RcvPlanSts.of(code); }
            if (Virtuallocflg.name().equals(name())) { return CDef.Virtuallocflg.of(code); }
            if (SufferUsageFlg.name().equals(name())) { return CDef.SufferUsageFlg.of(code); }
            if (Thedaysortingcompleteflg.name().equals(name())) { return CDef.Thedaysortingcompleteflg.of(code); }
            if (Gooditemkbn.name().equals(name())) { return CDef.Gooditemkbn.of(code); }
            if (Slptyp.name().equals(name())) { return CDef.Slptyp.of(code); }
            if (SostatusForserch2.name().equals(name())) { return CDef.SostatusForserch2.of(code); }
            if (LineOrderKbn.name().equals(name())) { return CDef.LineOrderKbn.of(code); }
            if (Consolidationflg.name().equals(name())) { return CDef.Consolidationflg.of(code); }
            if (DaysOfWeek.name().equals(name())) { return CDef.DaysOfWeek.of(code); }
            if (Lockbn.name().equals(name())) { return CDef.Lockbn.of(code); }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return CDef.ReplenishmentRoundedupUnit.of(code); }
            if (Restockkbn.name().equals(name())) { return CDef.Restockkbn.of(code); }
            if (Zaikodiv.name().equals(name())) { return CDef.Zaikodiv.of(code); }
            if (Openflg.name().equals(name())) { return CDef.Openflg.of(code); }
            if (TodayPrintOnlyFlg.name().equals(name())) { return CDef.TodayPrintOnlyFlg.of(code); }
            if (StartEnd.name().equals(name())) { return CDef.StartEnd.of(code); }
            if (SyhnKbnJt.name().equals(name())) { return CDef.SyhnKbnJt.of(code); }
            if (Transkbn.name().equals(name())) { return CDef.Transkbn.of(code); }
            if (Carknd.name().equals(name())) { return CDef.Carknd.of(code); }
            if (Cartypecmb0tdisp.name().equals(name())) { return CDef.Cartypecmb0tdisp.of(code); }
            if (CenterPicListCls1.name().equals(name())) { return CDef.CenterPicListCls1.of(code); }
            if (CenterPicListCls2.name().equals(name())) { return CDef.CenterPicListCls2.of(code); }
            if (CenterPicListCls3.name().equals(name())) { return CDef.CenterPicListCls3.of(code); }
            if (CenterSagawaDelivTz.name().equals(name())) { return CDef.CenterSagawaDelivTz.of(code); }
            if (CenterTransportTypeItem.name().equals(name())) { return CDef.CenterTransportTypeItem.of(code); }
            if (CenterSlipShapeCd.name().equals(name())) { return CDef.CenterSlipShapeCd.of(code); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return CDef.CenterTransportTypeSpeed.of(code); }
            if (CenterSealType.name().equals(name())) { return CDef.CenterSealType.of(code); }
            if (CenterTagClass.name().equals(name())) { return CDef.CenterTagClass.of(code); }
            if (CenterTagDataType.name().equals(name())) { return CDef.CenterTagDataType.of(code); }
            if (CenterTagType.name().equals(name())) { return CDef.CenterTagType.of(code); }
            if (CenterTagTypeAfter.name().equals(name())) { return CDef.CenterTagTypeAfter.of(code); }
            if (CenterApiBinsyuCode.name().equals(name())) { return CDef.CenterApiBinsyuCode.of(code); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return CDef.CenterApiDaibikiFlg.of(code); }
            if (CenterApiDaibikiType.name().equals(name())) { return CDef.CenterApiDaibikiType.of(code); }
            if (CenterApiEidomeFlg.name().equals(name())) { return CDef.CenterApiEidomeFlg.of(code); }
            if (CenterApiWeightCd.name().equals(name())) { return CDef.CenterApiWeightCd.of(code); }
            if (CenterOutputTargetFlg.name().equals(name())) { return CDef.CenterOutputTargetFlg.of(code); }
            if (CenterPrintCondition.name().equals(name())) { return CDef.CenterPrintCondition.of(code); }
            if (CenterDesignflg.name().equals(name())) { return CDef.CenterDesignflg.of(code); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public OptionalThing<? extends Classification> byName(String name) {
            if (ProcessTypeCd.name().equals(name())) { return CDef.ProcessTypeCd.byName(name); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return CDef.AfterDelivSlipOutTgt.byName(name); }
            if (AfterTagOutFlg.name().equals(name())) { return CDef.AfterTagOutFlg.byName(name); }
            if (AllcNgDisplay.name().equals(name())) { return CDef.AllcNgDisplay.byName(name); }
            if (AllcNgFlg.name().equals(name())) { return CDef.AllcNgFlg.byName(name); }
            if (AllocSortKey.name().equals(name())) { return CDef.AllocSortKey.byName(name); }
            if (AllShippingFlg.name().equals(name())) { return CDef.AllShippingFlg.byName(name); }
            if (ArrivalStoreFormat.name().equals(name())) { return CDef.ArrivalStoreFormat.byName(name); }
            if (AutoEmgSetFlg.name().equals(name())) { return CDef.AutoEmgSetFlg.byName(name); }
            if (AutoEmgSetTgt.name().equals(name())) { return CDef.AutoEmgSetTgt.byName(name); }
            if (AutoPrintTargetFlg.name().equals(name())) { return CDef.AutoPrintTargetFlg.byName(name); }
            if (AutoShipInstFlg.name().equals(name())) { return CDef.AutoShipInstFlg.byName(name); }
            if (BarcodeType.name().equals(name())) { return CDef.BarcodeType.byName(name); }
            if (BatchProgressFlg.name().equals(name())) { return CDef.BatchProgressFlg.byName(name); }
            if (BoxSelectSkip.name().equals(name())) { return CDef.BoxSelectSkip.byName(name); }
            if (CancelDataDisplay.name().equals(name())) { return CDef.CancelDataDisplay.byName(name); }
            if (CasePicFlg.name().equals(name())) { return CDef.CasePicFlg.byName(name); }
            if (CenterClientCls.name().equals(name())) { return CDef.CenterClientCls.byName(name); }
            if (CenterTransitFlg.name().equals(name())) { return CDef.CenterTransitFlg.byName(name); }
            if (CharacterCd.name().equals(name())) { return CDef.CharacterCd.byName(name); }
            if (ChargeQty0Display.name().equals(name())) { return CDef.ChargeQty0Display.byName(name); }
            if (CheckDigit.name().equals(name())) { return CDef.CheckDigit.byName(name); }
            if (CodeFlg.name().equals(name())) { return CDef.CodeFlg.byName(name); }
            if (CodeType.name().equals(name())) { return CDef.CodeType.byName(name); }
            if (CodCls.name().equals(name())) { return CDef.CodCls.byName(name); }
            if (CodType.name().equals(name())) { return CDef.CodType.byName(name); }
            if (ColType.name().equals(name())) { return CDef.ColType.byName(name); }
            if (CommentFlg.name().equals(name())) { return CDef.CommentFlg.byName(name); }
            if (CompanyFlg.name().equals(name())) { return CDef.CompanyFlg.byName(name); }
            if (CoolCls.name().equals(name())) { return CDef.CoolCls.byName(name); }
            if (CoolType.name().equals(name())) { return CDef.CoolType.byName(name); }
            if (CopyTargetTable.name().equals(name())) { return CDef.CopyTargetTable.byName(name); }
            if (CorrectType.name().equals(name())) { return CDef.CorrectType.byName(name); }
            if (DataInputCommitType.name().equals(name())) { return CDef.DataInputCommitType.byName(name); }
            if (DataInputOperationType.name().equals(name())) { return CDef.DataInputOperationType.byName(name); }
            if (DataInputProcessType.name().equals(name())) { return CDef.DataInputProcessType.byName(name); }
            if (DataInputRange.name().equals(name())) { return CDef.DataInputRange.byName(name); }
            if (DataInputType.name().equals(name())) { return CDef.DataInputType.byName(name); }
            if (DataType.name().equals(name())) { return CDef.DataType.byName(name); }
            if (Default.name().equals(name())) { return CDef.Default.byName(name); }
            if (DefaultFlg.name().equals(name())) { return CDef.DefaultFlg.byName(name); }
            if (DeleteDataDisplay.name().equals(name())) { return CDef.DeleteDataDisplay.byName(name); }
            if (DeliveryFlg.name().equals(name())) { return CDef.DeliveryFlg.byName(name); }
            if (DelivMatchFlg.name().equals(name())) { return CDef.DelivMatchFlg.byName(name); }
            if (DelivTz.name().equals(name())) { return CDef.DelivTz.byName(name); }
            if (DelFlg.name().equals(name())) { return CDef.DelFlg.byName(name); }
            if (DepositFlg.name().equals(name())) { return CDef.DepositFlg.byName(name); }
            if (DisplayRequired.name().equals(name())) { return CDef.DisplayRequired.byName(name); }
            if (DtCls.name().equals(name())) { return CDef.DtCls.byName(name); }
            if (Editable.name().equals(name())) { return CDef.Editable.byName(name); }
            if (EmergencyDisplay.name().equals(name())) { return CDef.EmergencyDisplay.byName(name); }
            if (EmergencyFlg.name().equals(name())) { return CDef.EmergencyFlg.byName(name); }
            if (ErrorFlg.name().equals(name())) { return CDef.ErrorFlg.byName(name); }
            if (ErrorProcessMet.name().equals(name())) { return CDef.ErrorProcessMet.byName(name); }
            if (FixedPoint.name().equals(name())) { return CDef.FixedPoint.byName(name); }
            if (ForceFixedFlg.name().equals(name())) { return CDef.ForceFixedFlg.byName(name); }
            if (ForeignFlg.name().equals(name())) { return CDef.ForeignFlg.byName(name); }
            if (GiftFlg.name().equals(name())) { return CDef.GiftFlg.byName(name); }
            if (GiftStatementType.name().equals(name())) { return CDef.GiftStatementType.byName(name); }
            if (HtCharReadFlg.name().equals(name())) { return CDef.HtCharReadFlg.byName(name); }
            if (ImportFlg.name().equals(name())) { return CDef.ImportFlg.byName(name); }
            if (InfoFlg.name().equals(name())) { return CDef.InfoFlg.byName(name); }
            if (InoutType.name().equals(name())) { return CDef.InoutType.byName(name); }
            if (InputType.name().equals(name())) { return CDef.InputType.byName(name); }
            if (InspectionFlg.name().equals(name())) { return CDef.InspectionFlg.byName(name); }
            if (InventoryLocationProduct.name().equals(name())) { return CDef.InventoryLocationProduct.byName(name); }
            if (InvoiceCreateFlg.name().equals(name())) { return CDef.InvoiceCreateFlg.byName(name); }
            if (ItemType.name().equals(name())) { return CDef.ItemType.byName(name); }
            if (LastFlg.name().equals(name())) { return CDef.LastFlg.byName(name); }
            if (LimitDtManagFlg.name().equals(name())) { return CDef.LimitDtManagFlg.byName(name); }
            if (LimitDtReverseFlg.name().equals(name())) { return CDef.LimitDtReverseFlg.byName(name); }
            if (LimitMessageCd.name().equals(name())) { return CDef.LimitMessageCd.byName(name); }
            if (LineFeedCd.name().equals(name())) { return CDef.LineFeedCd.byName(name); }
            if (ListOutFlg.name().equals(name())) { return CDef.ListOutFlg.byName(name); }
            if (ListOutFlgDisp.name().equals(name())) { return CDef.ListOutFlgDisp.byName(name); }
            if (ListOutKbn.name().equals(name())) { return CDef.ListOutKbn.byName(name); }
            if (LoadingFlg.name().equals(name())) { return CDef.LoadingFlg.byName(name); }
            if (LocationType.name().equals(name())) { return CDef.LocationType.byName(name); }
            if (Lockout.name().equals(name())) { return CDef.Lockout.byName(name); }
            if (LogDtlStatus.name().equals(name())) { return CDef.LogDtlStatus.byName(name); }
            if (LogDtlType.name().equals(name())) { return CDef.LogDtlType.byName(name); }
            if (LogStatus.name().equals(name())) { return CDef.LogStatus.byName(name); }
            if (LotManagFlg.name().equals(name())) { return CDef.LotManagFlg.byName(name); }
            if (LotReverseFlg.name().equals(name())) { return CDef.LotReverseFlg.byName(name); }
            if (MergeCls.name().equals(name())) { return CDef.MergeCls.byName(name); }
            if (MergeFlg.name().equals(name())) { return CDef.MergeFlg.byName(name); }
            if (MessageType.name().equals(name())) { return CDef.MessageType.byName(name); }
            if (MixedFlg.name().equals(name())) { return CDef.MixedFlg.byName(name); }
            if (MoveInstStatus.name().equals(name())) { return CDef.MoveInstStatus.byName(name); }
            if (MultiPicCls.name().equals(name())) { return CDef.MultiPicCls.byName(name); }
            if (MultiPicFlg.name().equals(name())) { return CDef.MultiPicFlg.byName(name); }
            if (Necessary.name().equals(name())) { return CDef.Necessary.byName(name); }
            if (NotCompletedFlg.name().equals(name())) { return CDef.NotCompletedFlg.byName(name); }
            if (NoAllcDisplayFlg.name().equals(name())) { return CDef.NoAllcDisplayFlg.byName(name); }
            if (NoConfirmedFlg.name().equals(name())) { return CDef.NoConfirmedFlg.byName(name); }
            if (NoStockCls.name().equals(name())) { return CDef.NoStockCls.byName(name); }
            if (NoStockOutFlg.name().equals(name())) { return CDef.NoStockOutFlg.byName(name); }
            if (NoUpsideDownCls.name().equals(name())) { return CDef.NoUpsideDownCls.byName(name); }
            if (OnetimeFlg.name().equals(name())) { return CDef.OnetimeFlg.byName(name); }
            if (OverStoreNumFlg.name().equals(name())) { return CDef.OverStoreNumFlg.byName(name); }
            if (PackingCalCls.name().equals(name())) { return CDef.PackingCalCls.byName(name); }
            if (PackingProcessCls.name().equals(name())) { return CDef.PackingProcessCls.byName(name); }
            if (PackingShowFlg.name().equals(name())) { return CDef.PackingShowFlg.byName(name); }
            if (PackingStatus.name().equals(name())) { return CDef.PackingStatus.byName(name); }
            if (PasswordReset.name().equals(name())) { return CDef.PasswordReset.byName(name); }
            if (PastStoreDtFlg.name().equals(name())) { return CDef.PastStoreDtFlg.byName(name); }
            if (PhysicalDelete.name().equals(name())) { return CDef.PhysicalDelete.byName(name); }
            if (PickingFlg.name().equals(name())) { return CDef.PickingFlg.byName(name); }
            if (PickingLocationFlg.name().equals(name())) { return CDef.PickingLocationFlg.byName(name); }
            if (PickingStatus.name().equals(name())) { return CDef.PickingStatus.byName(name); }
            if (PicCls.name().equals(name())) { return CDef.PicCls.byName(name); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return CDef.PicMthdRcmdBreakKey.byName(name); }
            if (PicMthdRcmdFlg.name().equals(name())) { return CDef.PicMthdRcmdFlg.byName(name); }
            if (PicMthdRcmdListOut.name().equals(name())) { return CDef.PicMthdRcmdListOut.byName(name); }
            if (PostType.name().equals(name())) { return CDef.PostType.byName(name); }
            if (PrintedFlg.name().equals(name())) { return CDef.PrintedFlg.byName(name); }
            if (PrintDataType.name().equals(name())) { return CDef.PrintDataType.byName(name); }
            if (PrintErrorFlg.name().equals(name())) { return CDef.PrintErrorFlg.byName(name); }
            if (PrintQueueStatus.name().equals(name())) { return CDef.PrintQueueStatus.byName(name); }
            if (PrintResultClass.name().equals(name())) { return CDef.PrintResultClass.byName(name); }
            if (PrintServiceStatus.name().equals(name())) { return CDef.PrintServiceStatus.byName(name); }
            if (PrintStatus.name().equals(name())) { return CDef.PrintStatus.byName(name); }
            if (PriorityFlg.name().equals(name())) { return CDef.PriorityFlg.byName(name); }
            if (ProductLabelJanBarcode.name().equals(name())) { return CDef.ProductLabelJanBarcode.byName(name); }
            if (ProductLabelOutUnit.name().equals(name())) { return CDef.ProductLabelOutUnit.byName(name); }
            if (ProductLabelProdBarcode.name().equals(name())) { return CDef.ProductLabelProdBarcode.byName(name); }
            if (ProductPartPacking.name().equals(name())) { return CDef.ProductPartPacking.byName(name); }
            if (ProductTypeCode.name().equals(name())) { return CDef.ProductTypeCode.byName(name); }
            if (Qty0Display.name().equals(name())) { return CDef.Qty0Display.byName(name); }
            if (ReasonType.name().equals(name())) { return CDef.ReasonType.byName(name); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return CDef.ReceiveDeliveryStatus.byName(name); }
            if (ReceiveFlg.name().equals(name())) { return CDef.ReceiveFlg.byName(name); }
            if (ReceiveStatus.name().equals(name())) { return CDef.ReceiveStatus.byName(name); }
            if (ReplenishAllocCls.name().equals(name())) { return CDef.ReplenishAllocCls.byName(name); }
            if (ReplenishProductCdUnset.name().equals(name())) { return CDef.ReplenishProductCdUnset.byName(name); }
            if (ReplenishSearchCls.name().equals(name())) { return CDef.ReplenishSearchCls.byName(name); }
            if (ReplenishUnitCls.name().equals(name())) { return CDef.ReplenishUnitCls.byName(name); }
            if (ReportLayoutItemType.name().equals(name())) { return CDef.ReportLayoutItemType.byName(name); }
            if (RestockType.name().equals(name())) { return CDef.RestockType.byName(name); }
            if (ResultAfterProductLabel.name().equals(name())) { return CDef.ResultAfterProductLabel.byName(name); }
            if (ResultAfterProductTarget.name().equals(name())) { return CDef.ResultAfterProductTarget.byName(name); }
            if (ReverseValidFlg.name().equals(name())) { return CDef.ReverseValidFlg.byName(name); }
            if (RoleControlClass.name().equals(name())) { return CDef.RoleControlClass.byName(name); }
            if (Select.name().equals(name())) { return CDef.Select.byName(name); }
            if (SelectPrintServiceStatus.name().equals(name())) { return CDef.SelectPrintServiceStatus.byName(name); }
            if (SerialOperationType.name().equals(name())) { return CDef.SerialOperationType.byName(name); }
            if (SettlementType.name().equals(name())) { return CDef.SettlementType.byName(name); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return CDef.SglRowInspAfterOutCls.byName(name); }
            if (SglRowPicFlg.name().equals(name())) { return CDef.SglRowPicFlg.byName(name); }
            if (SheetCollate.name().equals(name())) { return CDef.SheetCollate.byName(name); }
            if (ShippingFlg.name().equals(name())) { return CDef.ShippingFlg.byName(name); }
            if (ShippingStatus.name().equals(name())) { return CDef.ShippingStatus.byName(name); }
            if (ShippingStopFlg.name().equals(name())) { return CDef.ShippingStopFlg.byName(name); }
            if (ShortStockDisplay.name().equals(name())) { return CDef.ShortStockDisplay.byName(name); }
            if (ShpCheckCls.name().equals(name())) { return CDef.ShpCheckCls.byName(name); }
            if (ShpCheckDisplay.name().equals(name())) { return CDef.ShpCheckDisplay.byName(name); }
            if (SlipType.name().equals(name())) { return CDef.SlipType.byName(name); }
            if (SoundPlayFlg.name().equals(name())) { return CDef.SoundPlayFlg.byName(name); }
            if (StockAdjustFlg.name().equals(name())) { return CDef.StockAdjustFlg.byName(name); }
            if (StockDisplayFld.name().equals(name())) { return CDef.StockDisplayFld.byName(name); }
            if (StockExistOnlyFlg.name().equals(name())) { return CDef.StockExistOnlyFlg.byName(name); }
            if (StockMoveFlg.name().equals(name())) { return CDef.StockMoveFlg.byName(name); }
            if (StockNum0Display.name().equals(name())) { return CDef.StockNum0Display.byName(name); }
            if (StockOutAllocCls.name().equals(name())) { return CDef.StockOutAllocCls.byName(name); }
            if (StockOutAutoInstFlg.name().equals(name())) { return CDef.StockOutAutoInstFlg.byName(name); }
            if (StockOutFlg.name().equals(name())) { return CDef.StockOutFlg.byName(name); }
            if (StockOutInstCxlFlg.name().equals(name())) { return CDef.StockOutInstCxlFlg.byName(name); }
            if (StockOutInstSplitFlg.name().equals(name())) { return CDef.StockOutInstSplitFlg.byName(name); }
            if (StockQtyDisplay.name().equals(name())) { return CDef.StockQtyDisplay.byName(name); }
            if (StockTakingInput.name().equals(name())) { return CDef.StockTakingInput.byName(name); }
            if (StockTarget.name().equals(name())) { return CDef.StockTarget.byName(name); }
            if (StoreDtFlg.name().equals(name())) { return CDef.StoreDtFlg.byName(name); }
            if (StoreFlg.name().equals(name())) { return CDef.StoreFlg.byName(name); }
            if (StoreNoDivideDisplay.name().equals(name())) { return CDef.StoreNoDivideDisplay.byName(name); }
            if (StoreNoFlg.name().equals(name())) { return CDef.StoreNoFlg.byName(name); }
            if (StoreNoMergeFlg.name().equals(name())) { return CDef.StoreNoMergeFlg.byName(name); }
            if (SystemLogStatus.name().equals(name())) { return CDef.SystemLogStatus.byName(name); }
            if (SystemLogType.name().equals(name())) { return CDef.SystemLogType.byName(name); }
            if (SystemType.name().equals(name())) { return CDef.SystemType.byName(name); }
            if (TagDeliveryOutFlg.name().equals(name())) { return CDef.TagDeliveryOutFlg.byName(name); }
            if (TakingShippingDtFlg.name().equals(name())) { return CDef.TakingShippingDtFlg.byName(name); }
            if (TakingShippingFlg.name().equals(name())) { return CDef.TakingShippingFlg.byName(name); }
            if (TargetWindow.name().equals(name())) { return CDef.TargetWindow.byName(name); }
            if (TextAlign.name().equals(name())) { return CDef.TextAlign.byName(name); }
            if (TotalPicFlg.name().equals(name())) { return CDef.TotalPicFlg.byName(name); }
            if (TrackingNumberingUnit.name().equals(name())) { return CDef.TrackingNumberingUnit.byName(name); }
            if (TransitDisplay.name().equals(name())) { return CDef.TransitDisplay.byName(name); }
            if (Unmatch.name().equals(name())) { return CDef.Unmatch.byName(name); }
            if (Updatable.name().equals(name())) { return CDef.Updatable.byName(name); }
            if (UpdCd.name().equals(name())) { return CDef.UpdCd.byName(name); }
            if (UpdType.name().equals(name())) { return CDef.UpdType.byName(name); }
            if (UploadTableNm.name().equals(name())) { return CDef.UploadTableNm.byName(name); }
            if (UserEditable.name().equals(name())) { return CDef.UserEditable.byName(name); }
            if (UseHtShipFlg.name().equals(name())) { return CDef.UseHtShipFlg.byName(name); }
            if (VendorFlg.name().equals(name())) { return CDef.VendorFlg.byName(name); }
            if (Visible.name().equals(name())) { return CDef.Visible.byName(name); }
            if (WorkFlg.name().equals(name())) { return CDef.WorkFlg.byName(name); }
            if (WorkMessageFlg.name().equals(name())) { return CDef.WorkMessageFlg.byName(name); }
            if (YamatoDelivTz.name().equals(name())) { return CDef.YamatoDelivTz.byName(name); }
            if (YupackDelivTz.name().equals(name())) { return CDef.YupackDelivTz.byName(name); }
            if (ZipFlg.name().equals(name())) { return CDef.ZipFlg.byName(name); }
            if (AttendanceLeavingRest.name().equals(name())) { return CDef.AttendanceLeavingRest.byName(name); }
            if (BolOutputTargetFlg.name().equals(name())) { return CDef.BolOutputTargetFlg.byName(name); }
            if (BolOutFlg.name().equals(name())) { return CDef.BolOutFlg.byName(name); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return CDef.CallBeforeDeliveryFlg.byName(name); }
            if (CasePickFlg.name().equals(name())) { return CDef.CasePickFlg.byName(name); }
            if (CasePicTarget.name().equals(name())) { return CDef.CasePicTarget.byName(name); }
            if (CesIntegrationFlg.name().equals(name())) { return CDef.CesIntegrationFlg.byName(name); }
            if (CodFlg.name().equals(name())) { return CDef.CodFlg.byName(name); }
            if (DecimalExistFlg.name().equals(name())) { return CDef.DecimalExistFlg.byName(name); }
            if (DecimalProductPacking.name().equals(name())) { return CDef.DecimalProductPacking.byName(name); }
            if (DoNotStackStackFlg.name().equals(name())) { return CDef.DoNotStackStackFlg.byName(name); }
            if (EmReplenishShapeFlg.name().equals(name())) { return CDef.EmReplenishShapeFlg.byName(name); }
            if (FoogFlg.name().equals(name())) { return CDef.FoogFlg.byName(name); }
            if (FreezableProtectionFlg.name().equals(name())) { return CDef.FreezableProtectionFlg.byName(name); }
            if (FreightCls.name().equals(name())) { return CDef.FreightCls.byName(name); }
            if (GuaranteedPlusFlg.name().equals(name())) { return CDef.GuaranteedPlusFlg.byName(name); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return CDef.InsideDeliveryCollectFlg.byName(name); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return CDef.InsideDeliveryPrepaidFlg.byName(name); }
            if (InsidePickupCollectFlg.name().equals(name())) { return CDef.InsidePickupCollectFlg.byName(name); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return CDef.InsidePickupPrepaidFlg.byName(name); }
            if (InspectionLabelOutFlg.name().equals(name())) { return CDef.InspectionLabelOutFlg.byName(name); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return CDef.LiftgateDeliveryCollectFlg.byName(name); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return CDef.LiftgateDeliveryPrepaidFlg.byName(name); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return CDef.LiftgatePickupCollectFlg.byName(name); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return CDef.LiftgatePickupPrepaidFlg.byName(name); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return CDef.LimitedAccessDeliveryFlg.byName(name); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return CDef.LimitedAccessPickupFlg.byName(name); }
            if (OverSizedFlg.name().equals(name())) { return CDef.OverSizedFlg.byName(name); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return CDef.PackingSlipAutoOutputFlg.byName(name); }
            if (PaymentTerm.name().equals(name())) { return CDef.PaymentTerm.byName(name); }
            if (PickingType.name().equals(name())) { return CDef.PickingType.byName(name); }
            if (PoisonFlg.name().equals(name())) { return CDef.PoisonFlg.byName(name); }
            if (RcmdPickingCls.name().equals(name())) { return CDef.RcmdPickingCls.byName(name); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return CDef.ResidentialDeliveryFlg.byName(name); }
            if (ResidentialPickupFlg.name().equals(name())) { return CDef.ResidentialPickupFlg.byName(name); }
            if (SatDeliveryFlg.name().equals(name())) { return CDef.SatDeliveryFlg.byName(name); }
            if (SglRowPicTarget.name().equals(name())) { return CDef.SglRowPicTarget.byName(name); }
            if (SignatureReleaseFlg.name().equals(name())) { return CDef.SignatureReleaseFlg.byName(name); }
            if (SignatureRequiredFlg.name().equals(name())) { return CDef.SignatureRequiredFlg.byName(name); }
            if (UploadZipType.name().equals(name())) { return CDef.UploadZipType.byName(name); }
            if (WorkLogOutFlg.name().equals(name())) { return CDef.WorkLogOutFlg.byName(name); }
            if (WorkStatus.name().equals(name())) { return CDef.WorkStatus.byName(name); }
            if (Adjuststatus.name().equals(name())) { return CDef.Adjuststatus.byName(name); }
            if (Companygroup.name().equals(name())) { return CDef.Companygroup.byName(name); }
            if (LocGroup.name().equals(name())) { return CDef.LocGroup.byName(name); }
            if (Worktype.name().equals(name())) { return CDef.Worktype.byName(name); }
            if (Capitemflg.name().equals(name())) { return CDef.Capitemflg.byName(name); }
            if (Palletests.name().equals(name())) { return CDef.Palletests.byName(name); }
            if (Usid.name().equals(name())) { return CDef.Usid.byName(name); }
            if (Itemusedflg.name().equals(name())) { return CDef.Itemusedflg.byName(name); }
            if (Symbolsts.name().equals(name())) { return CDef.Symbolsts.byName(name); }
            if (Solistkbn.name().equals(name())) { return CDef.Solistkbn.byName(name); }
            if (Palletaddflg.name().equals(name())) { return CDef.Palletaddflg.byName(name); }
            if (Productdiv.name().equals(name())) { return CDef.Productdiv.byName(name); }
            if (Soroutediv.name().equals(name())) { return CDef.Soroutediv.byName(name); }
            if (Requesttype.name().equals(name())) { return CDef.Requesttype.byName(name); }
            if (Examsts.name().equals(name())) { return CDef.Examsts.byName(name); }
            if (Ordernoaddcd.name().equals(name())) { return CDef.Ordernoaddcd.byName(name); }
            if (Tracetype.name().equals(name())) { return CDef.Tracetype.byName(name); }
            if (Warehouseid.name().equals(name())) { return CDef.Warehouseid.byName(name); }
            if (Markettype.name().equals(name())) { return CDef.Markettype.byName(name); }
            if (Reservationflg.name().equals(name())) { return CDef.Reservationflg.byName(name); }
            if (Packingtype.name().equals(name())) { return CDef.Packingtype.byName(name); }
            if (Productmarkptn.name().equals(name())) { return CDef.Productmarkptn.byName(name); }
            if (Productmarkptnbatj.name().equals(name())) { return CDef.Productmarkptnbatj.byName(name); }
            if (Productmarkmonth.name().equals(name())) { return CDef.Productmarkmonth.byName(name); }
            if (Limitdatemonth.name().equals(name())) { return CDef.Limitdatemonth.byName(name); }
            if (Alclimitdatemonth.name().equals(name())) { return CDef.Alclimitdatemonth.byName(name); }
            if (Labellayoutmaster.name().equals(name())) { return CDef.Labellayoutmaster.byName(name); }
            if (Trafficpattern.name().equals(name())) { return CDef.Trafficpattern.byName(name); }
            if (Cgrid.name().equals(name())) { return CDef.Cgrid.byName(name); }
            if (Reportname.name().equals(name())) { return CDef.Reportname.byName(name); }
            if (Jyokenflg.name().equals(name())) { return CDef.Jyokenflg.byName(name); }
            if (Imshiptocode.name().equals(name())) { return CDef.Imshiptocode.byName(name); }
            if (Fileinfo.name().equals(name())) { return CDef.Fileinfo.byName(name); }
            if (Shiptocdchg.name().equals(name())) { return CDef.Shiptocdchg.byName(name); }
            if (Tdwmscd.name().equals(name())) { return CDef.Tdwmscd.byName(name); }
            if (Inoutdatatype.name().equals(name())) { return CDef.Inoutdatatype.byName(name); }
            if (Invmoveterm.name().equals(name())) { return CDef.Invmoveterm.byName(name); }
            if (Symbolsendhulftmaster.name().equals(name())) { return CDef.Symbolsendhulftmaster.byName(name); }
            if (Logflag.name().equals(name())) { return CDef.Logflag.byName(name); }
            if (Assortmentsts.name().equals(name())) { return CDef.Assortmentsts.byName(name); }
            if (Assortmentflg.name().equals(name())) { return CDef.Assortmentflg.byName(name); }
            if (Aststsforsearch.name().equals(name())) { return CDef.Aststsforsearch.byName(name); }
            if (Firstexamsendflg.name().equals(name())) { return CDef.Firstexamsendflg.byName(name); }
            if (Mossendflg.name().equals(name())) { return CDef.Mossendflg.byName(name); }
            if (Casecreatetype.name().equals(name())) { return CDef.Casecreatetype.byName(name); }
            if (Mosjtsendflg.name().equals(name())) { return CDef.Mosjtsendflg.byName(name); }
            if (Batkeepwarehousecd.name().equals(name())) { return CDef.Batkeepwarehousecd.byName(name); }
            if (Batwarehousecd.name().equals(name())) { return CDef.Batwarehousecd.byName(name); }
            if (Datamakeflg.name().equals(name())) { return CDef.Datamakeflg.byName(name); }
            if (Rcvresultqtytype.name().equals(name())) { return CDef.Rcvresultqtytype.byName(name); }
            if (Qualityexamflg.name().equals(name())) { return CDef.Qualityexamflg.byName(name); }
            if (Makercasecodefixedvalue.name().equals(name())) { return CDef.Makercasecodefixedvalue.byName(name); }
            if (Productmarkjttaxfree.name().equals(name())) { return CDef.Productmarkjttaxfree.byName(name); }
            if (PrinterdefS011.name().equals(name())) { return CDef.PrinterdefS011.byName(name); }
            if (PrinterdefS012.name().equals(name())) { return CDef.PrinterdefS012.byName(name); }
            if (PrinterdefN002.name().equals(name())) { return CDef.PrinterdefN002.byName(name); }
            if (PrinterdefZ005.name().equals(name())) { return CDef.PrinterdefZ005.byName(name); }
            if (Sortstockkbn.name().equals(name())) { return CDef.Sortstockkbn.byName(name); }
            if (Tracetypedt.name().equals(name())) { return CDef.Tracetypedt.byName(name); }
            if (Racklabelprflg.name().equals(name())) { return CDef.Racklabelprflg.byName(name); }
            if (PrinterdefS0031.name().equals(name())) { return CDef.PrinterdefS0031.byName(name); }
            if (PrinterdefS0032.name().equals(name())) { return CDef.PrinterdefS0032.byName(name); }
            if (PrinterdefS0033.name().equals(name())) { return CDef.PrinterdefS0033.byName(name); }
            if (PrinterdefS0034.name().equals(name())) { return CDef.PrinterdefS0034.byName(name); }
            if (Unknowncaselimit.name().equals(name())) { return CDef.Unknowncaselimit.byName(name); }
            if (Sortinvkbn.name().equals(name())) { return CDef.Sortinvkbn.byName(name); }
            if (Cloudcasenum.name().equals(name())) { return CDef.Cloudcasenum.byName(name); }
            if (Pulltype.name().equals(name())) { return CDef.Pulltype.byName(name); }
            if (Storageloc.name().equals(name())) { return CDef.Storageloc.byName(name); }
            if (Pallettracetype.name().equals(name())) { return CDef.Pallettracetype.byName(name); }
            if (Datasendtype.name().equals(name())) { return CDef.Datasendtype.byName(name); }
            if (Tracecreatests.name().equals(name())) { return CDef.Tracecreatests.byName(name); }
            if (Sortinvtiming.name().equals(name())) { return CDef.Sortinvtiming.byName(name); }
            if (Casesupplytype.name().equals(name())) { return CDef.Casesupplytype.byName(name); }
            if (Importumu.name().equals(name())) { return CDef.Importumu.byName(name); }
            if (Traceshiftflg.name().equals(name())) { return CDef.Traceshiftflg.byName(name); }
            if (Shtypecd.name().equals(name())) { return CDef.Shtypecd.byName(name); }
            if (Allocpolicy.name().equals(name())) { return CDef.Allocpolicy.byName(name); }
            if (Rtncompanyname.name().equals(name())) { return CDef.Rtncompanyname.byName(name); }
            if (Opendiff.name().equals(name())) { return CDef.Opendiff.byName(name); }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return CDef.ItemcdlookupAvailableflg.byName(name); }
            if (Flexpickprflg.name().equals(name())) { return CDef.Flexpickprflg.byName(name); }
            if (WorkmasterExp.name().equals(name())) { return CDef.WorkmasterExp.byName(name); }
            if (Tasktype.name().equals(name())) { return CDef.Tasktype.byName(name); }
            if (Tasktypedetail.name().equals(name())) { return CDef.Tasktypedetail.byName(name); }
            if (Yztraceshiftflg.name().equals(name())) { return CDef.Yztraceshiftflg.byName(name); }
            if (Workercdsearchtype.name().equals(name())) { return CDef.Workercdsearchtype.byName(name); }
            if (PrinterdefZ004.name().equals(name())) { return CDef.PrinterdefZ004.byName(name); }
            if (PrinterdefZ008.name().equals(name())) { return CDef.PrinterdefZ008.byName(name); }
            if (Pickdistname.name().equals(name())) { return CDef.Pickdistname.byName(name); }
            if (Traceswitchflg.name().equals(name())) { return CDef.Traceswitchflg.byName(name); }
            if (Lblkbn.name().equals(name())) { return CDef.Lblkbn.byName(name); }
            if (Assortkbn.name().equals(name())) { return CDef.Assortkbn.byName(name); }
            if (Dmycasecd.name().equals(name())) { return CDef.Dmycasecd.byName(name); }
            if (Baditemdelkbn.name().equals(name())) { return CDef.Baditemdelkbn.byName(name); }
            if (Selectlimit.name().equals(name())) { return CDef.Selectlimit.byName(name); }
            if (PrinterdefW001.name().equals(name())) { return CDef.PrinterdefW001.byName(name); }
            if (PrinterdefW002.name().equals(name())) { return CDef.PrinterdefW002.byName(name); }
            if (Settlementinvmonth.name().equals(name())) { return CDef.Settlementinvmonth.byName(name); }
            if (Flexinstructsts.name().equals(name())) { return CDef.Flexinstructsts.byName(name); }
            if (Compulsionflg.name().equals(name())) { return CDef.Compulsionflg.byName(name); }
            if (Displaymonth.name().equals(name())) { return CDef.Displaymonth.byName(name); }
            if (Sufferusagesearchflg.name().equals(name())) { return CDef.Sufferusagesearchflg.byName(name); }
            if (Fltstdinv.name().equals(name())) { return CDef.Fltstdinv.byName(name); }
            if (Cs3switchflg.name().equals(name())) { return CDef.Cs3switchflg.byName(name); }
            if (Inadequacyarea.name().equals(name())) { return CDef.Inadequacyarea.byName(name); }
            if (Transmitflg.name().equals(name())) { return CDef.Transmitflg.byName(name); }
            if (Flalterflg.name().equals(name())) { return CDef.Flalterflg.byName(name); }
            if (Invsts.name().equals(name())) { return CDef.Invsts.byName(name); }
            if (Concurrentbase.name().equals(name())) { return CDef.Concurrentbase.byName(name); }
            if (Concurrentname.name().equals(name())) { return CDef.Concurrentname.byName(name); }
            if (Caseshipstatus.name().equals(name())) { return CDef.Caseshipstatus.byName(name); }
            if (Ngpitemcd.name().equals(name())) { return CDef.Ngpitemcd.byName(name); }
            if (Fzloccd.name().equals(name())) { return CDef.Fzloccd.byName(name); }
            if (Whsortinvkbn.name().equals(name())) { return CDef.Whsortinvkbn.byName(name); }
            if (Syncreportform.name().equals(name())) { return CDef.Syncreportform.byName(name); }
            if (Sortwarehousecd.name().equals(name())) { return CDef.Sortwarehousecd.byName(name); }
            if (Hozeiwarehousecd.name().equals(name())) { return CDef.Hozeiwarehousecd.byName(name); }
            if (PrinterdefH002.name().equals(name())) { return CDef.PrinterdefH002.byName(name); }
            if (Reportformname.name().equals(name())) { return CDef.Reportformname.byName(name); }
            if (Taskname.name().equals(name())) { return CDef.Taskname.byName(name); }
            if (Whinvkbn.name().equals(name())) { return CDef.Whinvkbn.byName(name); }
            if (Procflg.name().equals(name())) { return CDef.Procflg.byName(name); }
            if (SyhnKbn.name().equals(name())) { return CDef.SyhnKbn.byName(name); }
            if (Pallettype.name().equals(name())) { return CDef.Pallettype.byName(name); }
            if (InventoryInstKbn.name().equals(name())) { return CDef.InventoryInstKbn.byName(name); }
            if (InventoryReport.name().equals(name())) { return CDef.InventoryReport.byName(name); }
            if (Completeflg.name().equals(name())) { return CDef.Completeflg.byName(name); }
            if (Oneitemonlyflg.name().equals(name())) { return CDef.Oneitemonlyflg.byName(name); }
            if (Oneowneronlyflg.name().equals(name())) { return CDef.Oneowneronlyflg.byName(name); }
            if (Picktype.name().equals(name())) { return CDef.Picktype.byName(name); }
            if (Rcvtype.name().equals(name())) { return CDef.Rcvtype.byName(name); }
            if (Slottype.name().equals(name())) { return CDef.Slottype.byName(name); }
            if (Capselect.name().equals(name())) { return CDef.Capselect.byName(name); }
            if (Kashikokuzeikubn.name().equals(name())) { return CDef.Kashikokuzeikubn.byName(name); }
            if (Instructflg.name().equals(name())) { return CDef.Instructflg.byName(name); }
            if (Palleteoutputtype.name().equals(name())) { return CDef.Palleteoutputtype.byName(name); }
            if (Palletecuttingkbn.name().equals(name())) { return CDef.Palletecuttingkbn.byName(name); }
            if (Frontrackcd.name().equals(name())) { return CDef.Frontrackcd.byName(name); }
            if (Sufferflg.name().equals(name())) { return CDef.Sufferflg.byName(name); }
            if (Unmatchflg.name().equals(name())) { return CDef.Unmatchflg.byName(name); }
            if (Alcimrsnflg.name().equals(name())) { return CDef.Alcimrsnflg.byName(name); }
            if (Manyfewoccurarea.name().equals(name())) { return CDef.Manyfewoccurarea.byName(name); }
            if (Manyfewoccurareadisp.name().equals(name())) { return CDef.Manyfewoccurareadisp.byName(name); }
            if (Designchg.name().equals(name())) { return CDef.Designchg.byName(name); }
            if (Differenceumu.name().equals(name())) { return CDef.Differenceumu.byName(name); }
            if (Stockdistinction.name().equals(name())) { return CDef.Stockdistinction.byName(name); }
            if (Workmaster.name().equals(name())) { return CDef.Workmaster.byName(name); }
            if (Picklisttype.name().equals(name())) { return CDef.Picklisttype.byName(name); }
            if (Sortzaikbn.name().equals(name())) { return CDef.Sortzaikbn.byName(name); }
            if (Sorttype.name().equals(name())) { return CDef.Sorttype.byName(name); }
            if (Exchgmethod.name().equals(name())) { return CDef.Exchgmethod.byName(name); }
            if (Conditionflg.name().equals(name())) { return CDef.Conditionflg.byName(name); }
            if (Qtyadjustflg.name().equals(name())) { return CDef.Qtyadjustflg.byName(name); }
            if (Inoutcode.name().equals(name())) { return CDef.Inoutcode.byName(name); }
            if (Inventorytype.name().equals(name())) { return CDef.Inventorytype.byName(name); }
            if (Attensionflg.name().equals(name())) { return CDef.Attensionflg.byName(name); }
            if (Formdiffflg.name().equals(name())) { return CDef.Formdiffflg.byName(name); }
            if (Timingtype.name().equals(name())) { return CDef.Timingtype.byName(name); }
            if (Fcflg.name().equals(name())) { return CDef.Fcflg.byName(name); }
            if (SundayFlg.name().equals(name())) { return CDef.SundayFlg.byName(name); }
            if (Pluralproductionkbn.name().equals(name())) { return CDef.Pluralproductionkbn.byName(name); }
            if (Changeflg.name().equals(name())) { return CDef.Changeflg.byName(name); }
            if (Rtnstatus.name().equals(name())) { return CDef.Rtnstatus.byName(name); }
            if (Rtninspestatus.name().equals(name())) { return CDef.Rtninspestatus.byName(name); }
            if (Inventoryref.name().equals(name())) { return CDef.Inventoryref.byName(name); }
            if (Restockflg.name().equals(name())) { return CDef.Restockflg.byName(name); }
            if (Validtype.name().equals(name())) { return CDef.Validtype.byName(name); }
            if (Rtnchangedivision.name().equals(name())) { return CDef.Rtnchangedivision.byName(name); }
            if (Storagearea.name().equals(name())) { return CDef.Storagearea.byName(name); }
            if (Maxinvflg.name().equals(name())) { return CDef.Maxinvflg.byName(name); }
            if (Horyukbn.name().equals(name())) { return CDef.Horyukbn.byName(name); }
            if (Useflg.name().equals(name())) { return CDef.Useflg.byName(name); }
            if (Fckokuflg.name().equals(name())) { return CDef.Fckokuflg.byName(name); }
            if (Bowltypeflg.name().equals(name())) { return CDef.Bowltypeflg.byName(name); }
            if (Inventoryrefdisp.name().equals(name())) { return CDef.Inventoryrefdisp.byName(name); }
            if (Flinstrstatus.name().equals(name())) { return CDef.Flinstrstatus.byName(name); }
            if (Flexstatus.name().equals(name())) { return CDef.Flexstatus.byName(name); }
            if (Distributioncd.name().equals(name())) { return CDef.Distributioncd.byName(name); }
            if (Stocklocation.name().equals(name())) { return CDef.Stocklocation.byName(name); }
            if (ResultStatus.name().equals(name())) { return CDef.ResultStatus.byName(name); }
            if (BoxCategory.name().equals(name())) { return CDef.BoxCategory.byName(name); }
            if (Storagewarehousecd.name().equals(name())) { return CDef.Storagewarehousecd.byName(name); }
            if (Salestype.name().equals(name())) { return CDef.Salestype.byName(name); }
            if (Solistkbn2.name().equals(name())) { return CDef.Solistkbn2.byName(name); }
            if (PickingListType.name().equals(name())) { return CDef.PickingListType.byName(name); }
            if (CoveredClass.name().equals(name())) { return CDef.CoveredClass.byName(name); }
            if (NotCoveredClass.name().equals(name())) { return CDef.NotCoveredClass.byName(name); }
            if (PickingWorkStatus.name().equals(name())) { return CDef.PickingWorkStatus.byName(name); }
            if (ReprintedFlg.name().equals(name())) { return CDef.ReprintedFlg.byName(name); }
            if (Cggdid.name().equals(name())) { return CDef.Cggdid.byName(name); }
            if (RcvPlanSts.name().equals(name())) { return CDef.RcvPlanSts.byName(name); }
            if (Virtuallocflg.name().equals(name())) { return CDef.Virtuallocflg.byName(name); }
            if (SufferUsageFlg.name().equals(name())) { return CDef.SufferUsageFlg.byName(name); }
            if (Thedaysortingcompleteflg.name().equals(name())) { return CDef.Thedaysortingcompleteflg.byName(name); }
            if (Gooditemkbn.name().equals(name())) { return CDef.Gooditemkbn.byName(name); }
            if (Slptyp.name().equals(name())) { return CDef.Slptyp.byName(name); }
            if (SostatusForserch2.name().equals(name())) { return CDef.SostatusForserch2.byName(name); }
            if (LineOrderKbn.name().equals(name())) { return CDef.LineOrderKbn.byName(name); }
            if (Consolidationflg.name().equals(name())) { return CDef.Consolidationflg.byName(name); }
            if (DaysOfWeek.name().equals(name())) { return CDef.DaysOfWeek.byName(name); }
            if (Lockbn.name().equals(name())) { return CDef.Lockbn.byName(name); }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return CDef.ReplenishmentRoundedupUnit.byName(name); }
            if (Restockkbn.name().equals(name())) { return CDef.Restockkbn.byName(name); }
            if (Zaikodiv.name().equals(name())) { return CDef.Zaikodiv.byName(name); }
            if (Openflg.name().equals(name())) { return CDef.Openflg.byName(name); }
            if (TodayPrintOnlyFlg.name().equals(name())) { return CDef.TodayPrintOnlyFlg.byName(name); }
            if (StartEnd.name().equals(name())) { return CDef.StartEnd.byName(name); }
            if (SyhnKbnJt.name().equals(name())) { return CDef.SyhnKbnJt.byName(name); }
            if (Transkbn.name().equals(name())) { return CDef.Transkbn.byName(name); }
            if (Carknd.name().equals(name())) { return CDef.Carknd.byName(name); }
            if (Cartypecmb0tdisp.name().equals(name())) { return CDef.Cartypecmb0tdisp.byName(name); }
            if (CenterPicListCls1.name().equals(name())) { return CDef.CenterPicListCls1.byName(name); }
            if (CenterPicListCls2.name().equals(name())) { return CDef.CenterPicListCls2.byName(name); }
            if (CenterPicListCls3.name().equals(name())) { return CDef.CenterPicListCls3.byName(name); }
            if (CenterSagawaDelivTz.name().equals(name())) { return CDef.CenterSagawaDelivTz.byName(name); }
            if (CenterTransportTypeItem.name().equals(name())) { return CDef.CenterTransportTypeItem.byName(name); }
            if (CenterSlipShapeCd.name().equals(name())) { return CDef.CenterSlipShapeCd.byName(name); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return CDef.CenterTransportTypeSpeed.byName(name); }
            if (CenterSealType.name().equals(name())) { return CDef.CenterSealType.byName(name); }
            if (CenterTagClass.name().equals(name())) { return CDef.CenterTagClass.byName(name); }
            if (CenterTagDataType.name().equals(name())) { return CDef.CenterTagDataType.byName(name); }
            if (CenterTagType.name().equals(name())) { return CDef.CenterTagType.byName(name); }
            if (CenterTagTypeAfter.name().equals(name())) { return CDef.CenterTagTypeAfter.byName(name); }
            if (CenterApiBinsyuCode.name().equals(name())) { return CDef.CenterApiBinsyuCode.byName(name); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return CDef.CenterApiDaibikiFlg.byName(name); }
            if (CenterApiDaibikiType.name().equals(name())) { return CDef.CenterApiDaibikiType.byName(name); }
            if (CenterApiEidomeFlg.name().equals(name())) { return CDef.CenterApiEidomeFlg.byName(name); }
            if (CenterApiWeightCd.name().equals(name())) { return CDef.CenterApiWeightCd.byName(name); }
            if (CenterOutputTargetFlg.name().equals(name())) { return CDef.CenterOutputTargetFlg.byName(name); }
            if (CenterPrintCondition.name().equals(name())) { return CDef.CenterPrintCondition.byName(name); }
            if (CenterDesignflg.name().equals(name())) { return CDef.CenterDesignflg.byName(name); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public Classification codeOf(Object code) { // null if not found, old style so use of(code)
            if (ProcessTypeCd.name().equals(name())) { return CDef.ProcessTypeCd.codeOf(code); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return CDef.AfterDelivSlipOutTgt.codeOf(code); }
            if (AfterTagOutFlg.name().equals(name())) { return CDef.AfterTagOutFlg.codeOf(code); }
            if (AllcNgDisplay.name().equals(name())) { return CDef.AllcNgDisplay.codeOf(code); }
            if (AllcNgFlg.name().equals(name())) { return CDef.AllcNgFlg.codeOf(code); }
            if (AllocSortKey.name().equals(name())) { return CDef.AllocSortKey.codeOf(code); }
            if (AllShippingFlg.name().equals(name())) { return CDef.AllShippingFlg.codeOf(code); }
            if (ArrivalStoreFormat.name().equals(name())) { return CDef.ArrivalStoreFormat.codeOf(code); }
            if (AutoEmgSetFlg.name().equals(name())) { return CDef.AutoEmgSetFlg.codeOf(code); }
            if (AutoEmgSetTgt.name().equals(name())) { return CDef.AutoEmgSetTgt.codeOf(code); }
            if (AutoPrintTargetFlg.name().equals(name())) { return CDef.AutoPrintTargetFlg.codeOf(code); }
            if (AutoShipInstFlg.name().equals(name())) { return CDef.AutoShipInstFlg.codeOf(code); }
            if (BarcodeType.name().equals(name())) { return CDef.BarcodeType.codeOf(code); }
            if (BatchProgressFlg.name().equals(name())) { return CDef.BatchProgressFlg.codeOf(code); }
            if (BoxSelectSkip.name().equals(name())) { return CDef.BoxSelectSkip.codeOf(code); }
            if (CancelDataDisplay.name().equals(name())) { return CDef.CancelDataDisplay.codeOf(code); }
            if (CasePicFlg.name().equals(name())) { return CDef.CasePicFlg.codeOf(code); }
            if (CenterClientCls.name().equals(name())) { return CDef.CenterClientCls.codeOf(code); }
            if (CenterTransitFlg.name().equals(name())) { return CDef.CenterTransitFlg.codeOf(code); }
            if (CharacterCd.name().equals(name())) { return CDef.CharacterCd.codeOf(code); }
            if (ChargeQty0Display.name().equals(name())) { return CDef.ChargeQty0Display.codeOf(code); }
            if (CheckDigit.name().equals(name())) { return CDef.CheckDigit.codeOf(code); }
            if (CodeFlg.name().equals(name())) { return CDef.CodeFlg.codeOf(code); }
            if (CodeType.name().equals(name())) { return CDef.CodeType.codeOf(code); }
            if (CodCls.name().equals(name())) { return CDef.CodCls.codeOf(code); }
            if (CodType.name().equals(name())) { return CDef.CodType.codeOf(code); }
            if (ColType.name().equals(name())) { return CDef.ColType.codeOf(code); }
            if (CommentFlg.name().equals(name())) { return CDef.CommentFlg.codeOf(code); }
            if (CompanyFlg.name().equals(name())) { return CDef.CompanyFlg.codeOf(code); }
            if (CoolCls.name().equals(name())) { return CDef.CoolCls.codeOf(code); }
            if (CoolType.name().equals(name())) { return CDef.CoolType.codeOf(code); }
            if (CopyTargetTable.name().equals(name())) { return CDef.CopyTargetTable.codeOf(code); }
            if (CorrectType.name().equals(name())) { return CDef.CorrectType.codeOf(code); }
            if (DataInputCommitType.name().equals(name())) { return CDef.DataInputCommitType.codeOf(code); }
            if (DataInputOperationType.name().equals(name())) { return CDef.DataInputOperationType.codeOf(code); }
            if (DataInputProcessType.name().equals(name())) { return CDef.DataInputProcessType.codeOf(code); }
            if (DataInputRange.name().equals(name())) { return CDef.DataInputRange.codeOf(code); }
            if (DataInputType.name().equals(name())) { return CDef.DataInputType.codeOf(code); }
            if (DataType.name().equals(name())) { return CDef.DataType.codeOf(code); }
            if (Default.name().equals(name())) { return CDef.Default.codeOf(code); }
            if (DefaultFlg.name().equals(name())) { return CDef.DefaultFlg.codeOf(code); }
            if (DeleteDataDisplay.name().equals(name())) { return CDef.DeleteDataDisplay.codeOf(code); }
            if (DeliveryFlg.name().equals(name())) { return CDef.DeliveryFlg.codeOf(code); }
            if (DelivMatchFlg.name().equals(name())) { return CDef.DelivMatchFlg.codeOf(code); }
            if (DelivTz.name().equals(name())) { return CDef.DelivTz.codeOf(code); }
            if (DelFlg.name().equals(name())) { return CDef.DelFlg.codeOf(code); }
            if (DepositFlg.name().equals(name())) { return CDef.DepositFlg.codeOf(code); }
            if (DisplayRequired.name().equals(name())) { return CDef.DisplayRequired.codeOf(code); }
            if (DtCls.name().equals(name())) { return CDef.DtCls.codeOf(code); }
            if (Editable.name().equals(name())) { return CDef.Editable.codeOf(code); }
            if (EmergencyDisplay.name().equals(name())) { return CDef.EmergencyDisplay.codeOf(code); }
            if (EmergencyFlg.name().equals(name())) { return CDef.EmergencyFlg.codeOf(code); }
            if (ErrorFlg.name().equals(name())) { return CDef.ErrorFlg.codeOf(code); }
            if (ErrorProcessMet.name().equals(name())) { return CDef.ErrorProcessMet.codeOf(code); }
            if (FixedPoint.name().equals(name())) { return CDef.FixedPoint.codeOf(code); }
            if (ForceFixedFlg.name().equals(name())) { return CDef.ForceFixedFlg.codeOf(code); }
            if (ForeignFlg.name().equals(name())) { return CDef.ForeignFlg.codeOf(code); }
            if (GiftFlg.name().equals(name())) { return CDef.GiftFlg.codeOf(code); }
            if (GiftStatementType.name().equals(name())) { return CDef.GiftStatementType.codeOf(code); }
            if (HtCharReadFlg.name().equals(name())) { return CDef.HtCharReadFlg.codeOf(code); }
            if (ImportFlg.name().equals(name())) { return CDef.ImportFlg.codeOf(code); }
            if (InfoFlg.name().equals(name())) { return CDef.InfoFlg.codeOf(code); }
            if (InoutType.name().equals(name())) { return CDef.InoutType.codeOf(code); }
            if (InputType.name().equals(name())) { return CDef.InputType.codeOf(code); }
            if (InspectionFlg.name().equals(name())) { return CDef.InspectionFlg.codeOf(code); }
            if (InventoryLocationProduct.name().equals(name())) { return CDef.InventoryLocationProduct.codeOf(code); }
            if (InvoiceCreateFlg.name().equals(name())) { return CDef.InvoiceCreateFlg.codeOf(code); }
            if (ItemType.name().equals(name())) { return CDef.ItemType.codeOf(code); }
            if (LastFlg.name().equals(name())) { return CDef.LastFlg.codeOf(code); }
            if (LimitDtManagFlg.name().equals(name())) { return CDef.LimitDtManagFlg.codeOf(code); }
            if (LimitDtReverseFlg.name().equals(name())) { return CDef.LimitDtReverseFlg.codeOf(code); }
            if (LimitMessageCd.name().equals(name())) { return CDef.LimitMessageCd.codeOf(code); }
            if (LineFeedCd.name().equals(name())) { return CDef.LineFeedCd.codeOf(code); }
            if (ListOutFlg.name().equals(name())) { return CDef.ListOutFlg.codeOf(code); }
            if (ListOutFlgDisp.name().equals(name())) { return CDef.ListOutFlgDisp.codeOf(code); }
            if (ListOutKbn.name().equals(name())) { return CDef.ListOutKbn.codeOf(code); }
            if (LoadingFlg.name().equals(name())) { return CDef.LoadingFlg.codeOf(code); }
            if (LocationType.name().equals(name())) { return CDef.LocationType.codeOf(code); }
            if (Lockout.name().equals(name())) { return CDef.Lockout.codeOf(code); }
            if (LogDtlStatus.name().equals(name())) { return CDef.LogDtlStatus.codeOf(code); }
            if (LogDtlType.name().equals(name())) { return CDef.LogDtlType.codeOf(code); }
            if (LogStatus.name().equals(name())) { return CDef.LogStatus.codeOf(code); }
            if (LotManagFlg.name().equals(name())) { return CDef.LotManagFlg.codeOf(code); }
            if (LotReverseFlg.name().equals(name())) { return CDef.LotReverseFlg.codeOf(code); }
            if (MergeCls.name().equals(name())) { return CDef.MergeCls.codeOf(code); }
            if (MergeFlg.name().equals(name())) { return CDef.MergeFlg.codeOf(code); }
            if (MessageType.name().equals(name())) { return CDef.MessageType.codeOf(code); }
            if (MixedFlg.name().equals(name())) { return CDef.MixedFlg.codeOf(code); }
            if (MoveInstStatus.name().equals(name())) { return CDef.MoveInstStatus.codeOf(code); }
            if (MultiPicCls.name().equals(name())) { return CDef.MultiPicCls.codeOf(code); }
            if (MultiPicFlg.name().equals(name())) { return CDef.MultiPicFlg.codeOf(code); }
            if (Necessary.name().equals(name())) { return CDef.Necessary.codeOf(code); }
            if (NotCompletedFlg.name().equals(name())) { return CDef.NotCompletedFlg.codeOf(code); }
            if (NoAllcDisplayFlg.name().equals(name())) { return CDef.NoAllcDisplayFlg.codeOf(code); }
            if (NoConfirmedFlg.name().equals(name())) { return CDef.NoConfirmedFlg.codeOf(code); }
            if (NoStockCls.name().equals(name())) { return CDef.NoStockCls.codeOf(code); }
            if (NoStockOutFlg.name().equals(name())) { return CDef.NoStockOutFlg.codeOf(code); }
            if (NoUpsideDownCls.name().equals(name())) { return CDef.NoUpsideDownCls.codeOf(code); }
            if (OnetimeFlg.name().equals(name())) { return CDef.OnetimeFlg.codeOf(code); }
            if (OverStoreNumFlg.name().equals(name())) { return CDef.OverStoreNumFlg.codeOf(code); }
            if (PackingCalCls.name().equals(name())) { return CDef.PackingCalCls.codeOf(code); }
            if (PackingProcessCls.name().equals(name())) { return CDef.PackingProcessCls.codeOf(code); }
            if (PackingShowFlg.name().equals(name())) { return CDef.PackingShowFlg.codeOf(code); }
            if (PackingStatus.name().equals(name())) { return CDef.PackingStatus.codeOf(code); }
            if (PasswordReset.name().equals(name())) { return CDef.PasswordReset.codeOf(code); }
            if (PastStoreDtFlg.name().equals(name())) { return CDef.PastStoreDtFlg.codeOf(code); }
            if (PhysicalDelete.name().equals(name())) { return CDef.PhysicalDelete.codeOf(code); }
            if (PickingFlg.name().equals(name())) { return CDef.PickingFlg.codeOf(code); }
            if (PickingLocationFlg.name().equals(name())) { return CDef.PickingLocationFlg.codeOf(code); }
            if (PickingStatus.name().equals(name())) { return CDef.PickingStatus.codeOf(code); }
            if (PicCls.name().equals(name())) { return CDef.PicCls.codeOf(code); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return CDef.PicMthdRcmdBreakKey.codeOf(code); }
            if (PicMthdRcmdFlg.name().equals(name())) { return CDef.PicMthdRcmdFlg.codeOf(code); }
            if (PicMthdRcmdListOut.name().equals(name())) { return CDef.PicMthdRcmdListOut.codeOf(code); }
            if (PostType.name().equals(name())) { return CDef.PostType.codeOf(code); }
            if (PrintedFlg.name().equals(name())) { return CDef.PrintedFlg.codeOf(code); }
            if (PrintDataType.name().equals(name())) { return CDef.PrintDataType.codeOf(code); }
            if (PrintErrorFlg.name().equals(name())) { return CDef.PrintErrorFlg.codeOf(code); }
            if (PrintQueueStatus.name().equals(name())) { return CDef.PrintQueueStatus.codeOf(code); }
            if (PrintResultClass.name().equals(name())) { return CDef.PrintResultClass.codeOf(code); }
            if (PrintServiceStatus.name().equals(name())) { return CDef.PrintServiceStatus.codeOf(code); }
            if (PrintStatus.name().equals(name())) { return CDef.PrintStatus.codeOf(code); }
            if (PriorityFlg.name().equals(name())) { return CDef.PriorityFlg.codeOf(code); }
            if (ProductLabelJanBarcode.name().equals(name())) { return CDef.ProductLabelJanBarcode.codeOf(code); }
            if (ProductLabelOutUnit.name().equals(name())) { return CDef.ProductLabelOutUnit.codeOf(code); }
            if (ProductLabelProdBarcode.name().equals(name())) { return CDef.ProductLabelProdBarcode.codeOf(code); }
            if (ProductPartPacking.name().equals(name())) { return CDef.ProductPartPacking.codeOf(code); }
            if (ProductTypeCode.name().equals(name())) { return CDef.ProductTypeCode.codeOf(code); }
            if (Qty0Display.name().equals(name())) { return CDef.Qty0Display.codeOf(code); }
            if (ReasonType.name().equals(name())) { return CDef.ReasonType.codeOf(code); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return CDef.ReceiveDeliveryStatus.codeOf(code); }
            if (ReceiveFlg.name().equals(name())) { return CDef.ReceiveFlg.codeOf(code); }
            if (ReceiveStatus.name().equals(name())) { return CDef.ReceiveStatus.codeOf(code); }
            if (ReplenishAllocCls.name().equals(name())) { return CDef.ReplenishAllocCls.codeOf(code); }
            if (ReplenishProductCdUnset.name().equals(name())) { return CDef.ReplenishProductCdUnset.codeOf(code); }
            if (ReplenishSearchCls.name().equals(name())) { return CDef.ReplenishSearchCls.codeOf(code); }
            if (ReplenishUnitCls.name().equals(name())) { return CDef.ReplenishUnitCls.codeOf(code); }
            if (ReportLayoutItemType.name().equals(name())) { return CDef.ReportLayoutItemType.codeOf(code); }
            if (RestockType.name().equals(name())) { return CDef.RestockType.codeOf(code); }
            if (ResultAfterProductLabel.name().equals(name())) { return CDef.ResultAfterProductLabel.codeOf(code); }
            if (ResultAfterProductTarget.name().equals(name())) { return CDef.ResultAfterProductTarget.codeOf(code); }
            if (ReverseValidFlg.name().equals(name())) { return CDef.ReverseValidFlg.codeOf(code); }
            if (RoleControlClass.name().equals(name())) { return CDef.RoleControlClass.codeOf(code); }
            if (Select.name().equals(name())) { return CDef.Select.codeOf(code); }
            if (SelectPrintServiceStatus.name().equals(name())) { return CDef.SelectPrintServiceStatus.codeOf(code); }
            if (SerialOperationType.name().equals(name())) { return CDef.SerialOperationType.codeOf(code); }
            if (SettlementType.name().equals(name())) { return CDef.SettlementType.codeOf(code); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return CDef.SglRowInspAfterOutCls.codeOf(code); }
            if (SglRowPicFlg.name().equals(name())) { return CDef.SglRowPicFlg.codeOf(code); }
            if (SheetCollate.name().equals(name())) { return CDef.SheetCollate.codeOf(code); }
            if (ShippingFlg.name().equals(name())) { return CDef.ShippingFlg.codeOf(code); }
            if (ShippingStatus.name().equals(name())) { return CDef.ShippingStatus.codeOf(code); }
            if (ShippingStopFlg.name().equals(name())) { return CDef.ShippingStopFlg.codeOf(code); }
            if (ShortStockDisplay.name().equals(name())) { return CDef.ShortStockDisplay.codeOf(code); }
            if (ShpCheckCls.name().equals(name())) { return CDef.ShpCheckCls.codeOf(code); }
            if (ShpCheckDisplay.name().equals(name())) { return CDef.ShpCheckDisplay.codeOf(code); }
            if (SlipType.name().equals(name())) { return CDef.SlipType.codeOf(code); }
            if (SoundPlayFlg.name().equals(name())) { return CDef.SoundPlayFlg.codeOf(code); }
            if (StockAdjustFlg.name().equals(name())) { return CDef.StockAdjustFlg.codeOf(code); }
            if (StockDisplayFld.name().equals(name())) { return CDef.StockDisplayFld.codeOf(code); }
            if (StockExistOnlyFlg.name().equals(name())) { return CDef.StockExistOnlyFlg.codeOf(code); }
            if (StockMoveFlg.name().equals(name())) { return CDef.StockMoveFlg.codeOf(code); }
            if (StockNum0Display.name().equals(name())) { return CDef.StockNum0Display.codeOf(code); }
            if (StockOutAllocCls.name().equals(name())) { return CDef.StockOutAllocCls.codeOf(code); }
            if (StockOutAutoInstFlg.name().equals(name())) { return CDef.StockOutAutoInstFlg.codeOf(code); }
            if (StockOutFlg.name().equals(name())) { return CDef.StockOutFlg.codeOf(code); }
            if (StockOutInstCxlFlg.name().equals(name())) { return CDef.StockOutInstCxlFlg.codeOf(code); }
            if (StockOutInstSplitFlg.name().equals(name())) { return CDef.StockOutInstSplitFlg.codeOf(code); }
            if (StockQtyDisplay.name().equals(name())) { return CDef.StockQtyDisplay.codeOf(code); }
            if (StockTakingInput.name().equals(name())) { return CDef.StockTakingInput.codeOf(code); }
            if (StockTarget.name().equals(name())) { return CDef.StockTarget.codeOf(code); }
            if (StoreDtFlg.name().equals(name())) { return CDef.StoreDtFlg.codeOf(code); }
            if (StoreFlg.name().equals(name())) { return CDef.StoreFlg.codeOf(code); }
            if (StoreNoDivideDisplay.name().equals(name())) { return CDef.StoreNoDivideDisplay.codeOf(code); }
            if (StoreNoFlg.name().equals(name())) { return CDef.StoreNoFlg.codeOf(code); }
            if (StoreNoMergeFlg.name().equals(name())) { return CDef.StoreNoMergeFlg.codeOf(code); }
            if (SystemLogStatus.name().equals(name())) { return CDef.SystemLogStatus.codeOf(code); }
            if (SystemLogType.name().equals(name())) { return CDef.SystemLogType.codeOf(code); }
            if (SystemType.name().equals(name())) { return CDef.SystemType.codeOf(code); }
            if (TagDeliveryOutFlg.name().equals(name())) { return CDef.TagDeliveryOutFlg.codeOf(code); }
            if (TakingShippingDtFlg.name().equals(name())) { return CDef.TakingShippingDtFlg.codeOf(code); }
            if (TakingShippingFlg.name().equals(name())) { return CDef.TakingShippingFlg.codeOf(code); }
            if (TargetWindow.name().equals(name())) { return CDef.TargetWindow.codeOf(code); }
            if (TextAlign.name().equals(name())) { return CDef.TextAlign.codeOf(code); }
            if (TotalPicFlg.name().equals(name())) { return CDef.TotalPicFlg.codeOf(code); }
            if (TrackingNumberingUnit.name().equals(name())) { return CDef.TrackingNumberingUnit.codeOf(code); }
            if (TransitDisplay.name().equals(name())) { return CDef.TransitDisplay.codeOf(code); }
            if (Unmatch.name().equals(name())) { return CDef.Unmatch.codeOf(code); }
            if (Updatable.name().equals(name())) { return CDef.Updatable.codeOf(code); }
            if (UpdCd.name().equals(name())) { return CDef.UpdCd.codeOf(code); }
            if (UpdType.name().equals(name())) { return CDef.UpdType.codeOf(code); }
            if (UploadTableNm.name().equals(name())) { return CDef.UploadTableNm.codeOf(code); }
            if (UserEditable.name().equals(name())) { return CDef.UserEditable.codeOf(code); }
            if (UseHtShipFlg.name().equals(name())) { return CDef.UseHtShipFlg.codeOf(code); }
            if (VendorFlg.name().equals(name())) { return CDef.VendorFlg.codeOf(code); }
            if (Visible.name().equals(name())) { return CDef.Visible.codeOf(code); }
            if (WorkFlg.name().equals(name())) { return CDef.WorkFlg.codeOf(code); }
            if (WorkMessageFlg.name().equals(name())) { return CDef.WorkMessageFlg.codeOf(code); }
            if (YamatoDelivTz.name().equals(name())) { return CDef.YamatoDelivTz.codeOf(code); }
            if (YupackDelivTz.name().equals(name())) { return CDef.YupackDelivTz.codeOf(code); }
            if (ZipFlg.name().equals(name())) { return CDef.ZipFlg.codeOf(code); }
            if (AttendanceLeavingRest.name().equals(name())) { return CDef.AttendanceLeavingRest.codeOf(code); }
            if (BolOutputTargetFlg.name().equals(name())) { return CDef.BolOutputTargetFlg.codeOf(code); }
            if (BolOutFlg.name().equals(name())) { return CDef.BolOutFlg.codeOf(code); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return CDef.CallBeforeDeliveryFlg.codeOf(code); }
            if (CasePickFlg.name().equals(name())) { return CDef.CasePickFlg.codeOf(code); }
            if (CasePicTarget.name().equals(name())) { return CDef.CasePicTarget.codeOf(code); }
            if (CesIntegrationFlg.name().equals(name())) { return CDef.CesIntegrationFlg.codeOf(code); }
            if (CodFlg.name().equals(name())) { return CDef.CodFlg.codeOf(code); }
            if (DecimalExistFlg.name().equals(name())) { return CDef.DecimalExistFlg.codeOf(code); }
            if (DecimalProductPacking.name().equals(name())) { return CDef.DecimalProductPacking.codeOf(code); }
            if (DoNotStackStackFlg.name().equals(name())) { return CDef.DoNotStackStackFlg.codeOf(code); }
            if (EmReplenishShapeFlg.name().equals(name())) { return CDef.EmReplenishShapeFlg.codeOf(code); }
            if (FoogFlg.name().equals(name())) { return CDef.FoogFlg.codeOf(code); }
            if (FreezableProtectionFlg.name().equals(name())) { return CDef.FreezableProtectionFlg.codeOf(code); }
            if (FreightCls.name().equals(name())) { return CDef.FreightCls.codeOf(code); }
            if (GuaranteedPlusFlg.name().equals(name())) { return CDef.GuaranteedPlusFlg.codeOf(code); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return CDef.InsideDeliveryCollectFlg.codeOf(code); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return CDef.InsideDeliveryPrepaidFlg.codeOf(code); }
            if (InsidePickupCollectFlg.name().equals(name())) { return CDef.InsidePickupCollectFlg.codeOf(code); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return CDef.InsidePickupPrepaidFlg.codeOf(code); }
            if (InspectionLabelOutFlg.name().equals(name())) { return CDef.InspectionLabelOutFlg.codeOf(code); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return CDef.LiftgateDeliveryCollectFlg.codeOf(code); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return CDef.LiftgateDeliveryPrepaidFlg.codeOf(code); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return CDef.LiftgatePickupCollectFlg.codeOf(code); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return CDef.LiftgatePickupPrepaidFlg.codeOf(code); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return CDef.LimitedAccessDeliveryFlg.codeOf(code); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return CDef.LimitedAccessPickupFlg.codeOf(code); }
            if (OverSizedFlg.name().equals(name())) { return CDef.OverSizedFlg.codeOf(code); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return CDef.PackingSlipAutoOutputFlg.codeOf(code); }
            if (PaymentTerm.name().equals(name())) { return CDef.PaymentTerm.codeOf(code); }
            if (PickingType.name().equals(name())) { return CDef.PickingType.codeOf(code); }
            if (PoisonFlg.name().equals(name())) { return CDef.PoisonFlg.codeOf(code); }
            if (RcmdPickingCls.name().equals(name())) { return CDef.RcmdPickingCls.codeOf(code); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return CDef.ResidentialDeliveryFlg.codeOf(code); }
            if (ResidentialPickupFlg.name().equals(name())) { return CDef.ResidentialPickupFlg.codeOf(code); }
            if (SatDeliveryFlg.name().equals(name())) { return CDef.SatDeliveryFlg.codeOf(code); }
            if (SglRowPicTarget.name().equals(name())) { return CDef.SglRowPicTarget.codeOf(code); }
            if (SignatureReleaseFlg.name().equals(name())) { return CDef.SignatureReleaseFlg.codeOf(code); }
            if (SignatureRequiredFlg.name().equals(name())) { return CDef.SignatureRequiredFlg.codeOf(code); }
            if (UploadZipType.name().equals(name())) { return CDef.UploadZipType.codeOf(code); }
            if (WorkLogOutFlg.name().equals(name())) { return CDef.WorkLogOutFlg.codeOf(code); }
            if (WorkStatus.name().equals(name())) { return CDef.WorkStatus.codeOf(code); }
            if (Adjuststatus.name().equals(name())) { return CDef.Adjuststatus.codeOf(code); }
            if (Companygroup.name().equals(name())) { return CDef.Companygroup.codeOf(code); }
            if (LocGroup.name().equals(name())) { return CDef.LocGroup.codeOf(code); }
            if (Worktype.name().equals(name())) { return CDef.Worktype.codeOf(code); }
            if (Capitemflg.name().equals(name())) { return CDef.Capitemflg.codeOf(code); }
            if (Palletests.name().equals(name())) { return CDef.Palletests.codeOf(code); }
            if (Usid.name().equals(name())) { return CDef.Usid.codeOf(code); }
            if (Itemusedflg.name().equals(name())) { return CDef.Itemusedflg.codeOf(code); }
            if (Symbolsts.name().equals(name())) { return CDef.Symbolsts.codeOf(code); }
            if (Solistkbn.name().equals(name())) { return CDef.Solistkbn.codeOf(code); }
            if (Palletaddflg.name().equals(name())) { return CDef.Palletaddflg.codeOf(code); }
            if (Productdiv.name().equals(name())) { return CDef.Productdiv.codeOf(code); }
            if (Soroutediv.name().equals(name())) { return CDef.Soroutediv.codeOf(code); }
            if (Requesttype.name().equals(name())) { return CDef.Requesttype.codeOf(code); }
            if (Examsts.name().equals(name())) { return CDef.Examsts.codeOf(code); }
            if (Ordernoaddcd.name().equals(name())) { return CDef.Ordernoaddcd.codeOf(code); }
            if (Tracetype.name().equals(name())) { return CDef.Tracetype.codeOf(code); }
            if (Warehouseid.name().equals(name())) { return CDef.Warehouseid.codeOf(code); }
            if (Markettype.name().equals(name())) { return CDef.Markettype.codeOf(code); }
            if (Reservationflg.name().equals(name())) { return CDef.Reservationflg.codeOf(code); }
            if (Packingtype.name().equals(name())) { return CDef.Packingtype.codeOf(code); }
            if (Productmarkptn.name().equals(name())) { return CDef.Productmarkptn.codeOf(code); }
            if (Productmarkptnbatj.name().equals(name())) { return CDef.Productmarkptnbatj.codeOf(code); }
            if (Productmarkmonth.name().equals(name())) { return CDef.Productmarkmonth.codeOf(code); }
            if (Limitdatemonth.name().equals(name())) { return CDef.Limitdatemonth.codeOf(code); }
            if (Alclimitdatemonth.name().equals(name())) { return CDef.Alclimitdatemonth.codeOf(code); }
            if (Labellayoutmaster.name().equals(name())) { return CDef.Labellayoutmaster.codeOf(code); }
            if (Trafficpattern.name().equals(name())) { return CDef.Trafficpattern.codeOf(code); }
            if (Cgrid.name().equals(name())) { return CDef.Cgrid.codeOf(code); }
            if (Reportname.name().equals(name())) { return CDef.Reportname.codeOf(code); }
            if (Jyokenflg.name().equals(name())) { return CDef.Jyokenflg.codeOf(code); }
            if (Imshiptocode.name().equals(name())) { return CDef.Imshiptocode.codeOf(code); }
            if (Fileinfo.name().equals(name())) { return CDef.Fileinfo.codeOf(code); }
            if (Shiptocdchg.name().equals(name())) { return CDef.Shiptocdchg.codeOf(code); }
            if (Tdwmscd.name().equals(name())) { return CDef.Tdwmscd.codeOf(code); }
            if (Inoutdatatype.name().equals(name())) { return CDef.Inoutdatatype.codeOf(code); }
            if (Invmoveterm.name().equals(name())) { return CDef.Invmoveterm.codeOf(code); }
            if (Symbolsendhulftmaster.name().equals(name())) { return CDef.Symbolsendhulftmaster.codeOf(code); }
            if (Logflag.name().equals(name())) { return CDef.Logflag.codeOf(code); }
            if (Assortmentsts.name().equals(name())) { return CDef.Assortmentsts.codeOf(code); }
            if (Assortmentflg.name().equals(name())) { return CDef.Assortmentflg.codeOf(code); }
            if (Aststsforsearch.name().equals(name())) { return CDef.Aststsforsearch.codeOf(code); }
            if (Firstexamsendflg.name().equals(name())) { return CDef.Firstexamsendflg.codeOf(code); }
            if (Mossendflg.name().equals(name())) { return CDef.Mossendflg.codeOf(code); }
            if (Casecreatetype.name().equals(name())) { return CDef.Casecreatetype.codeOf(code); }
            if (Mosjtsendflg.name().equals(name())) { return CDef.Mosjtsendflg.codeOf(code); }
            if (Batkeepwarehousecd.name().equals(name())) { return CDef.Batkeepwarehousecd.codeOf(code); }
            if (Batwarehousecd.name().equals(name())) { return CDef.Batwarehousecd.codeOf(code); }
            if (Datamakeflg.name().equals(name())) { return CDef.Datamakeflg.codeOf(code); }
            if (Rcvresultqtytype.name().equals(name())) { return CDef.Rcvresultqtytype.codeOf(code); }
            if (Qualityexamflg.name().equals(name())) { return CDef.Qualityexamflg.codeOf(code); }
            if (Makercasecodefixedvalue.name().equals(name())) { return CDef.Makercasecodefixedvalue.codeOf(code); }
            if (Productmarkjttaxfree.name().equals(name())) { return CDef.Productmarkjttaxfree.codeOf(code); }
            if (PrinterdefS011.name().equals(name())) { return CDef.PrinterdefS011.codeOf(code); }
            if (PrinterdefS012.name().equals(name())) { return CDef.PrinterdefS012.codeOf(code); }
            if (PrinterdefN002.name().equals(name())) { return CDef.PrinterdefN002.codeOf(code); }
            if (PrinterdefZ005.name().equals(name())) { return CDef.PrinterdefZ005.codeOf(code); }
            if (Sortstockkbn.name().equals(name())) { return CDef.Sortstockkbn.codeOf(code); }
            if (Tracetypedt.name().equals(name())) { return CDef.Tracetypedt.codeOf(code); }
            if (Racklabelprflg.name().equals(name())) { return CDef.Racklabelprflg.codeOf(code); }
            if (PrinterdefS0031.name().equals(name())) { return CDef.PrinterdefS0031.codeOf(code); }
            if (PrinterdefS0032.name().equals(name())) { return CDef.PrinterdefS0032.codeOf(code); }
            if (PrinterdefS0033.name().equals(name())) { return CDef.PrinterdefS0033.codeOf(code); }
            if (PrinterdefS0034.name().equals(name())) { return CDef.PrinterdefS0034.codeOf(code); }
            if (Unknowncaselimit.name().equals(name())) { return CDef.Unknowncaselimit.codeOf(code); }
            if (Sortinvkbn.name().equals(name())) { return CDef.Sortinvkbn.codeOf(code); }
            if (Cloudcasenum.name().equals(name())) { return CDef.Cloudcasenum.codeOf(code); }
            if (Pulltype.name().equals(name())) { return CDef.Pulltype.codeOf(code); }
            if (Storageloc.name().equals(name())) { return CDef.Storageloc.codeOf(code); }
            if (Pallettracetype.name().equals(name())) { return CDef.Pallettracetype.codeOf(code); }
            if (Datasendtype.name().equals(name())) { return CDef.Datasendtype.codeOf(code); }
            if (Tracecreatests.name().equals(name())) { return CDef.Tracecreatests.codeOf(code); }
            if (Sortinvtiming.name().equals(name())) { return CDef.Sortinvtiming.codeOf(code); }
            if (Casesupplytype.name().equals(name())) { return CDef.Casesupplytype.codeOf(code); }
            if (Importumu.name().equals(name())) { return CDef.Importumu.codeOf(code); }
            if (Traceshiftflg.name().equals(name())) { return CDef.Traceshiftflg.codeOf(code); }
            if (Shtypecd.name().equals(name())) { return CDef.Shtypecd.codeOf(code); }
            if (Allocpolicy.name().equals(name())) { return CDef.Allocpolicy.codeOf(code); }
            if (Rtncompanyname.name().equals(name())) { return CDef.Rtncompanyname.codeOf(code); }
            if (Opendiff.name().equals(name())) { return CDef.Opendiff.codeOf(code); }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return CDef.ItemcdlookupAvailableflg.codeOf(code); }
            if (Flexpickprflg.name().equals(name())) { return CDef.Flexpickprflg.codeOf(code); }
            if (WorkmasterExp.name().equals(name())) { return CDef.WorkmasterExp.codeOf(code); }
            if (Tasktype.name().equals(name())) { return CDef.Tasktype.codeOf(code); }
            if (Tasktypedetail.name().equals(name())) { return CDef.Tasktypedetail.codeOf(code); }
            if (Yztraceshiftflg.name().equals(name())) { return CDef.Yztraceshiftflg.codeOf(code); }
            if (Workercdsearchtype.name().equals(name())) { return CDef.Workercdsearchtype.codeOf(code); }
            if (PrinterdefZ004.name().equals(name())) { return CDef.PrinterdefZ004.codeOf(code); }
            if (PrinterdefZ008.name().equals(name())) { return CDef.PrinterdefZ008.codeOf(code); }
            if (Pickdistname.name().equals(name())) { return CDef.Pickdistname.codeOf(code); }
            if (Traceswitchflg.name().equals(name())) { return CDef.Traceswitchflg.codeOf(code); }
            if (Lblkbn.name().equals(name())) { return CDef.Lblkbn.codeOf(code); }
            if (Assortkbn.name().equals(name())) { return CDef.Assortkbn.codeOf(code); }
            if (Dmycasecd.name().equals(name())) { return CDef.Dmycasecd.codeOf(code); }
            if (Baditemdelkbn.name().equals(name())) { return CDef.Baditemdelkbn.codeOf(code); }
            if (Selectlimit.name().equals(name())) { return CDef.Selectlimit.codeOf(code); }
            if (PrinterdefW001.name().equals(name())) { return CDef.PrinterdefW001.codeOf(code); }
            if (PrinterdefW002.name().equals(name())) { return CDef.PrinterdefW002.codeOf(code); }
            if (Settlementinvmonth.name().equals(name())) { return CDef.Settlementinvmonth.codeOf(code); }
            if (Flexinstructsts.name().equals(name())) { return CDef.Flexinstructsts.codeOf(code); }
            if (Compulsionflg.name().equals(name())) { return CDef.Compulsionflg.codeOf(code); }
            if (Displaymonth.name().equals(name())) { return CDef.Displaymonth.codeOf(code); }
            if (Sufferusagesearchflg.name().equals(name())) { return CDef.Sufferusagesearchflg.codeOf(code); }
            if (Fltstdinv.name().equals(name())) { return CDef.Fltstdinv.codeOf(code); }
            if (Cs3switchflg.name().equals(name())) { return CDef.Cs3switchflg.codeOf(code); }
            if (Inadequacyarea.name().equals(name())) { return CDef.Inadequacyarea.codeOf(code); }
            if (Transmitflg.name().equals(name())) { return CDef.Transmitflg.codeOf(code); }
            if (Flalterflg.name().equals(name())) { return CDef.Flalterflg.codeOf(code); }
            if (Invsts.name().equals(name())) { return CDef.Invsts.codeOf(code); }
            if (Concurrentbase.name().equals(name())) { return CDef.Concurrentbase.codeOf(code); }
            if (Concurrentname.name().equals(name())) { return CDef.Concurrentname.codeOf(code); }
            if (Caseshipstatus.name().equals(name())) { return CDef.Caseshipstatus.codeOf(code); }
            if (Ngpitemcd.name().equals(name())) { return CDef.Ngpitemcd.codeOf(code); }
            if (Fzloccd.name().equals(name())) { return CDef.Fzloccd.codeOf(code); }
            if (Whsortinvkbn.name().equals(name())) { return CDef.Whsortinvkbn.codeOf(code); }
            if (Syncreportform.name().equals(name())) { return CDef.Syncreportform.codeOf(code); }
            if (Sortwarehousecd.name().equals(name())) { return CDef.Sortwarehousecd.codeOf(code); }
            if (Hozeiwarehousecd.name().equals(name())) { return CDef.Hozeiwarehousecd.codeOf(code); }
            if (PrinterdefH002.name().equals(name())) { return CDef.PrinterdefH002.codeOf(code); }
            if (Reportformname.name().equals(name())) { return CDef.Reportformname.codeOf(code); }
            if (Taskname.name().equals(name())) { return CDef.Taskname.codeOf(code); }
            if (Whinvkbn.name().equals(name())) { return CDef.Whinvkbn.codeOf(code); }
            if (Procflg.name().equals(name())) { return CDef.Procflg.codeOf(code); }
            if (SyhnKbn.name().equals(name())) { return CDef.SyhnKbn.codeOf(code); }
            if (Pallettype.name().equals(name())) { return CDef.Pallettype.codeOf(code); }
            if (InventoryInstKbn.name().equals(name())) { return CDef.InventoryInstKbn.codeOf(code); }
            if (InventoryReport.name().equals(name())) { return CDef.InventoryReport.codeOf(code); }
            if (Completeflg.name().equals(name())) { return CDef.Completeflg.codeOf(code); }
            if (Oneitemonlyflg.name().equals(name())) { return CDef.Oneitemonlyflg.codeOf(code); }
            if (Oneowneronlyflg.name().equals(name())) { return CDef.Oneowneronlyflg.codeOf(code); }
            if (Picktype.name().equals(name())) { return CDef.Picktype.codeOf(code); }
            if (Rcvtype.name().equals(name())) { return CDef.Rcvtype.codeOf(code); }
            if (Slottype.name().equals(name())) { return CDef.Slottype.codeOf(code); }
            if (Capselect.name().equals(name())) { return CDef.Capselect.codeOf(code); }
            if (Kashikokuzeikubn.name().equals(name())) { return CDef.Kashikokuzeikubn.codeOf(code); }
            if (Instructflg.name().equals(name())) { return CDef.Instructflg.codeOf(code); }
            if (Palleteoutputtype.name().equals(name())) { return CDef.Palleteoutputtype.codeOf(code); }
            if (Palletecuttingkbn.name().equals(name())) { return CDef.Palletecuttingkbn.codeOf(code); }
            if (Frontrackcd.name().equals(name())) { return CDef.Frontrackcd.codeOf(code); }
            if (Sufferflg.name().equals(name())) { return CDef.Sufferflg.codeOf(code); }
            if (Unmatchflg.name().equals(name())) { return CDef.Unmatchflg.codeOf(code); }
            if (Alcimrsnflg.name().equals(name())) { return CDef.Alcimrsnflg.codeOf(code); }
            if (Manyfewoccurarea.name().equals(name())) { return CDef.Manyfewoccurarea.codeOf(code); }
            if (Manyfewoccurareadisp.name().equals(name())) { return CDef.Manyfewoccurareadisp.codeOf(code); }
            if (Designchg.name().equals(name())) { return CDef.Designchg.codeOf(code); }
            if (Differenceumu.name().equals(name())) { return CDef.Differenceumu.codeOf(code); }
            if (Stockdistinction.name().equals(name())) { return CDef.Stockdistinction.codeOf(code); }
            if (Workmaster.name().equals(name())) { return CDef.Workmaster.codeOf(code); }
            if (Picklisttype.name().equals(name())) { return CDef.Picklisttype.codeOf(code); }
            if (Sortzaikbn.name().equals(name())) { return CDef.Sortzaikbn.codeOf(code); }
            if (Sorttype.name().equals(name())) { return CDef.Sorttype.codeOf(code); }
            if (Exchgmethod.name().equals(name())) { return CDef.Exchgmethod.codeOf(code); }
            if (Conditionflg.name().equals(name())) { return CDef.Conditionflg.codeOf(code); }
            if (Qtyadjustflg.name().equals(name())) { return CDef.Qtyadjustflg.codeOf(code); }
            if (Inoutcode.name().equals(name())) { return CDef.Inoutcode.codeOf(code); }
            if (Inventorytype.name().equals(name())) { return CDef.Inventorytype.codeOf(code); }
            if (Attensionflg.name().equals(name())) { return CDef.Attensionflg.codeOf(code); }
            if (Formdiffflg.name().equals(name())) { return CDef.Formdiffflg.codeOf(code); }
            if (Timingtype.name().equals(name())) { return CDef.Timingtype.codeOf(code); }
            if (Fcflg.name().equals(name())) { return CDef.Fcflg.codeOf(code); }
            if (SundayFlg.name().equals(name())) { return CDef.SundayFlg.codeOf(code); }
            if (Pluralproductionkbn.name().equals(name())) { return CDef.Pluralproductionkbn.codeOf(code); }
            if (Changeflg.name().equals(name())) { return CDef.Changeflg.codeOf(code); }
            if (Rtnstatus.name().equals(name())) { return CDef.Rtnstatus.codeOf(code); }
            if (Rtninspestatus.name().equals(name())) { return CDef.Rtninspestatus.codeOf(code); }
            if (Inventoryref.name().equals(name())) { return CDef.Inventoryref.codeOf(code); }
            if (Restockflg.name().equals(name())) { return CDef.Restockflg.codeOf(code); }
            if (Validtype.name().equals(name())) { return CDef.Validtype.codeOf(code); }
            if (Rtnchangedivision.name().equals(name())) { return CDef.Rtnchangedivision.codeOf(code); }
            if (Storagearea.name().equals(name())) { return CDef.Storagearea.codeOf(code); }
            if (Maxinvflg.name().equals(name())) { return CDef.Maxinvflg.codeOf(code); }
            if (Horyukbn.name().equals(name())) { return CDef.Horyukbn.codeOf(code); }
            if (Useflg.name().equals(name())) { return CDef.Useflg.codeOf(code); }
            if (Fckokuflg.name().equals(name())) { return CDef.Fckokuflg.codeOf(code); }
            if (Bowltypeflg.name().equals(name())) { return CDef.Bowltypeflg.codeOf(code); }
            if (Inventoryrefdisp.name().equals(name())) { return CDef.Inventoryrefdisp.codeOf(code); }
            if (Flinstrstatus.name().equals(name())) { return CDef.Flinstrstatus.codeOf(code); }
            if (Flexstatus.name().equals(name())) { return CDef.Flexstatus.codeOf(code); }
            if (Distributioncd.name().equals(name())) { return CDef.Distributioncd.codeOf(code); }
            if (Stocklocation.name().equals(name())) { return CDef.Stocklocation.codeOf(code); }
            if (ResultStatus.name().equals(name())) { return CDef.ResultStatus.codeOf(code); }
            if (BoxCategory.name().equals(name())) { return CDef.BoxCategory.codeOf(code); }
            if (Storagewarehousecd.name().equals(name())) { return CDef.Storagewarehousecd.codeOf(code); }
            if (Salestype.name().equals(name())) { return CDef.Salestype.codeOf(code); }
            if (Solistkbn2.name().equals(name())) { return CDef.Solistkbn2.codeOf(code); }
            if (PickingListType.name().equals(name())) { return CDef.PickingListType.codeOf(code); }
            if (CoveredClass.name().equals(name())) { return CDef.CoveredClass.codeOf(code); }
            if (NotCoveredClass.name().equals(name())) { return CDef.NotCoveredClass.codeOf(code); }
            if (PickingWorkStatus.name().equals(name())) { return CDef.PickingWorkStatus.codeOf(code); }
            if (ReprintedFlg.name().equals(name())) { return CDef.ReprintedFlg.codeOf(code); }
            if (Cggdid.name().equals(name())) { return CDef.Cggdid.codeOf(code); }
            if (RcvPlanSts.name().equals(name())) { return CDef.RcvPlanSts.codeOf(code); }
            if (Virtuallocflg.name().equals(name())) { return CDef.Virtuallocflg.codeOf(code); }
            if (SufferUsageFlg.name().equals(name())) { return CDef.SufferUsageFlg.codeOf(code); }
            if (Thedaysortingcompleteflg.name().equals(name())) { return CDef.Thedaysortingcompleteflg.codeOf(code); }
            if (Gooditemkbn.name().equals(name())) { return CDef.Gooditemkbn.codeOf(code); }
            if (Slptyp.name().equals(name())) { return CDef.Slptyp.codeOf(code); }
            if (SostatusForserch2.name().equals(name())) { return CDef.SostatusForserch2.codeOf(code); }
            if (LineOrderKbn.name().equals(name())) { return CDef.LineOrderKbn.codeOf(code); }
            if (Consolidationflg.name().equals(name())) { return CDef.Consolidationflg.codeOf(code); }
            if (DaysOfWeek.name().equals(name())) { return CDef.DaysOfWeek.codeOf(code); }
            if (Lockbn.name().equals(name())) { return CDef.Lockbn.codeOf(code); }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return CDef.ReplenishmentRoundedupUnit.codeOf(code); }
            if (Restockkbn.name().equals(name())) { return CDef.Restockkbn.codeOf(code); }
            if (Zaikodiv.name().equals(name())) { return CDef.Zaikodiv.codeOf(code); }
            if (Openflg.name().equals(name())) { return CDef.Openflg.codeOf(code); }
            if (TodayPrintOnlyFlg.name().equals(name())) { return CDef.TodayPrintOnlyFlg.codeOf(code); }
            if (StartEnd.name().equals(name())) { return CDef.StartEnd.codeOf(code); }
            if (SyhnKbnJt.name().equals(name())) { return CDef.SyhnKbnJt.codeOf(code); }
            if (Transkbn.name().equals(name())) { return CDef.Transkbn.codeOf(code); }
            if (Carknd.name().equals(name())) { return CDef.Carknd.codeOf(code); }
            if (Cartypecmb0tdisp.name().equals(name())) { return CDef.Cartypecmb0tdisp.codeOf(code); }
            if (CenterPicListCls1.name().equals(name())) { return CDef.CenterPicListCls1.codeOf(code); }
            if (CenterPicListCls2.name().equals(name())) { return CDef.CenterPicListCls2.codeOf(code); }
            if (CenterPicListCls3.name().equals(name())) { return CDef.CenterPicListCls3.codeOf(code); }
            if (CenterSagawaDelivTz.name().equals(name())) { return CDef.CenterSagawaDelivTz.codeOf(code); }
            if (CenterTransportTypeItem.name().equals(name())) { return CDef.CenterTransportTypeItem.codeOf(code); }
            if (CenterSlipShapeCd.name().equals(name())) { return CDef.CenterSlipShapeCd.codeOf(code); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return CDef.CenterTransportTypeSpeed.codeOf(code); }
            if (CenterSealType.name().equals(name())) { return CDef.CenterSealType.codeOf(code); }
            if (CenterTagClass.name().equals(name())) { return CDef.CenterTagClass.codeOf(code); }
            if (CenterTagDataType.name().equals(name())) { return CDef.CenterTagDataType.codeOf(code); }
            if (CenterTagType.name().equals(name())) { return CDef.CenterTagType.codeOf(code); }
            if (CenterTagTypeAfter.name().equals(name())) { return CDef.CenterTagTypeAfter.codeOf(code); }
            if (CenterApiBinsyuCode.name().equals(name())) { return CDef.CenterApiBinsyuCode.codeOf(code); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return CDef.CenterApiDaibikiFlg.codeOf(code); }
            if (CenterApiDaibikiType.name().equals(name())) { return CDef.CenterApiDaibikiType.codeOf(code); }
            if (CenterApiEidomeFlg.name().equals(name())) { return CDef.CenterApiEidomeFlg.codeOf(code); }
            if (CenterApiWeightCd.name().equals(name())) { return CDef.CenterApiWeightCd.codeOf(code); }
            if (CenterOutputTargetFlg.name().equals(name())) { return CDef.CenterOutputTargetFlg.codeOf(code); }
            if (CenterPrintCondition.name().equals(name())) { return CDef.CenterPrintCondition.codeOf(code); }
            if (CenterDesignflg.name().equals(name())) { return CDef.CenterDesignflg.codeOf(code); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public Classification nameOf(String name) { // null if not found, old style so use byName(name)
            if (ProcessTypeCd.name().equals(name())) { return CDef.ProcessTypeCd.valueOf(name); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return CDef.AfterDelivSlipOutTgt.valueOf(name); }
            if (AfterTagOutFlg.name().equals(name())) { return CDef.AfterTagOutFlg.valueOf(name); }
            if (AllcNgDisplay.name().equals(name())) { return CDef.AllcNgDisplay.valueOf(name); }
            if (AllcNgFlg.name().equals(name())) { return CDef.AllcNgFlg.valueOf(name); }
            if (AllocSortKey.name().equals(name())) { return CDef.AllocSortKey.valueOf(name); }
            if (AllShippingFlg.name().equals(name())) { return CDef.AllShippingFlg.valueOf(name); }
            if (ArrivalStoreFormat.name().equals(name())) { return CDef.ArrivalStoreFormat.valueOf(name); }
            if (AutoEmgSetFlg.name().equals(name())) { return CDef.AutoEmgSetFlg.valueOf(name); }
            if (AutoEmgSetTgt.name().equals(name())) { return CDef.AutoEmgSetTgt.valueOf(name); }
            if (AutoPrintTargetFlg.name().equals(name())) { return CDef.AutoPrintTargetFlg.valueOf(name); }
            if (AutoShipInstFlg.name().equals(name())) { return CDef.AutoShipInstFlg.valueOf(name); }
            if (BarcodeType.name().equals(name())) { return CDef.BarcodeType.valueOf(name); }
            if (BatchProgressFlg.name().equals(name())) { return CDef.BatchProgressFlg.valueOf(name); }
            if (BoxSelectSkip.name().equals(name())) { return CDef.BoxSelectSkip.valueOf(name); }
            if (CancelDataDisplay.name().equals(name())) { return CDef.CancelDataDisplay.valueOf(name); }
            if (CasePicFlg.name().equals(name())) { return CDef.CasePicFlg.valueOf(name); }
            if (CenterClientCls.name().equals(name())) { return CDef.CenterClientCls.valueOf(name); }
            if (CenterTransitFlg.name().equals(name())) { return CDef.CenterTransitFlg.valueOf(name); }
            if (CharacterCd.name().equals(name())) { return CDef.CharacterCd.valueOf(name); }
            if (ChargeQty0Display.name().equals(name())) { return CDef.ChargeQty0Display.valueOf(name); }
            if (CheckDigit.name().equals(name())) { return CDef.CheckDigit.valueOf(name); }
            if (CodeFlg.name().equals(name())) { return CDef.CodeFlg.valueOf(name); }
            if (CodeType.name().equals(name())) { return CDef.CodeType.valueOf(name); }
            if (CodCls.name().equals(name())) { return CDef.CodCls.valueOf(name); }
            if (CodType.name().equals(name())) { return CDef.CodType.valueOf(name); }
            if (ColType.name().equals(name())) { return CDef.ColType.valueOf(name); }
            if (CommentFlg.name().equals(name())) { return CDef.CommentFlg.valueOf(name); }
            if (CompanyFlg.name().equals(name())) { return CDef.CompanyFlg.valueOf(name); }
            if (CoolCls.name().equals(name())) { return CDef.CoolCls.valueOf(name); }
            if (CoolType.name().equals(name())) { return CDef.CoolType.valueOf(name); }
            if (CopyTargetTable.name().equals(name())) { return CDef.CopyTargetTable.valueOf(name); }
            if (CorrectType.name().equals(name())) { return CDef.CorrectType.valueOf(name); }
            if (DataInputCommitType.name().equals(name())) { return CDef.DataInputCommitType.valueOf(name); }
            if (DataInputOperationType.name().equals(name())) { return CDef.DataInputOperationType.valueOf(name); }
            if (DataInputProcessType.name().equals(name())) { return CDef.DataInputProcessType.valueOf(name); }
            if (DataInputRange.name().equals(name())) { return CDef.DataInputRange.valueOf(name); }
            if (DataInputType.name().equals(name())) { return CDef.DataInputType.valueOf(name); }
            if (DataType.name().equals(name())) { return CDef.DataType.valueOf(name); }
            if (Default.name().equals(name())) { return CDef.Default.valueOf(name); }
            if (DefaultFlg.name().equals(name())) { return CDef.DefaultFlg.valueOf(name); }
            if (DeleteDataDisplay.name().equals(name())) { return CDef.DeleteDataDisplay.valueOf(name); }
            if (DeliveryFlg.name().equals(name())) { return CDef.DeliveryFlg.valueOf(name); }
            if (DelivMatchFlg.name().equals(name())) { return CDef.DelivMatchFlg.valueOf(name); }
            if (DelivTz.name().equals(name())) { return CDef.DelivTz.valueOf(name); }
            if (DelFlg.name().equals(name())) { return CDef.DelFlg.valueOf(name); }
            if (DepositFlg.name().equals(name())) { return CDef.DepositFlg.valueOf(name); }
            if (DisplayRequired.name().equals(name())) { return CDef.DisplayRequired.valueOf(name); }
            if (DtCls.name().equals(name())) { return CDef.DtCls.valueOf(name); }
            if (Editable.name().equals(name())) { return CDef.Editable.valueOf(name); }
            if (EmergencyDisplay.name().equals(name())) { return CDef.EmergencyDisplay.valueOf(name); }
            if (EmergencyFlg.name().equals(name())) { return CDef.EmergencyFlg.valueOf(name); }
            if (ErrorFlg.name().equals(name())) { return CDef.ErrorFlg.valueOf(name); }
            if (ErrorProcessMet.name().equals(name())) { return CDef.ErrorProcessMet.valueOf(name); }
            if (FixedPoint.name().equals(name())) { return CDef.FixedPoint.valueOf(name); }
            if (ForceFixedFlg.name().equals(name())) { return CDef.ForceFixedFlg.valueOf(name); }
            if (ForeignFlg.name().equals(name())) { return CDef.ForeignFlg.valueOf(name); }
            if (GiftFlg.name().equals(name())) { return CDef.GiftFlg.valueOf(name); }
            if (GiftStatementType.name().equals(name())) { return CDef.GiftStatementType.valueOf(name); }
            if (HtCharReadFlg.name().equals(name())) { return CDef.HtCharReadFlg.valueOf(name); }
            if (ImportFlg.name().equals(name())) { return CDef.ImportFlg.valueOf(name); }
            if (InfoFlg.name().equals(name())) { return CDef.InfoFlg.valueOf(name); }
            if (InoutType.name().equals(name())) { return CDef.InoutType.valueOf(name); }
            if (InputType.name().equals(name())) { return CDef.InputType.valueOf(name); }
            if (InspectionFlg.name().equals(name())) { return CDef.InspectionFlg.valueOf(name); }
            if (InventoryLocationProduct.name().equals(name())) { return CDef.InventoryLocationProduct.valueOf(name); }
            if (InvoiceCreateFlg.name().equals(name())) { return CDef.InvoiceCreateFlg.valueOf(name); }
            if (ItemType.name().equals(name())) { return CDef.ItemType.valueOf(name); }
            if (LastFlg.name().equals(name())) { return CDef.LastFlg.valueOf(name); }
            if (LimitDtManagFlg.name().equals(name())) { return CDef.LimitDtManagFlg.valueOf(name); }
            if (LimitDtReverseFlg.name().equals(name())) { return CDef.LimitDtReverseFlg.valueOf(name); }
            if (LimitMessageCd.name().equals(name())) { return CDef.LimitMessageCd.valueOf(name); }
            if (LineFeedCd.name().equals(name())) { return CDef.LineFeedCd.valueOf(name); }
            if (ListOutFlg.name().equals(name())) { return CDef.ListOutFlg.valueOf(name); }
            if (ListOutFlgDisp.name().equals(name())) { return CDef.ListOutFlgDisp.valueOf(name); }
            if (ListOutKbn.name().equals(name())) { return CDef.ListOutKbn.valueOf(name); }
            if (LoadingFlg.name().equals(name())) { return CDef.LoadingFlg.valueOf(name); }
            if (LocationType.name().equals(name())) { return CDef.LocationType.valueOf(name); }
            if (Lockout.name().equals(name())) { return CDef.Lockout.valueOf(name); }
            if (LogDtlStatus.name().equals(name())) { return CDef.LogDtlStatus.valueOf(name); }
            if (LogDtlType.name().equals(name())) { return CDef.LogDtlType.valueOf(name); }
            if (LogStatus.name().equals(name())) { return CDef.LogStatus.valueOf(name); }
            if (LotManagFlg.name().equals(name())) { return CDef.LotManagFlg.valueOf(name); }
            if (LotReverseFlg.name().equals(name())) { return CDef.LotReverseFlg.valueOf(name); }
            if (MergeCls.name().equals(name())) { return CDef.MergeCls.valueOf(name); }
            if (MergeFlg.name().equals(name())) { return CDef.MergeFlg.valueOf(name); }
            if (MessageType.name().equals(name())) { return CDef.MessageType.valueOf(name); }
            if (MixedFlg.name().equals(name())) { return CDef.MixedFlg.valueOf(name); }
            if (MoveInstStatus.name().equals(name())) { return CDef.MoveInstStatus.valueOf(name); }
            if (MultiPicCls.name().equals(name())) { return CDef.MultiPicCls.valueOf(name); }
            if (MultiPicFlg.name().equals(name())) { return CDef.MultiPicFlg.valueOf(name); }
            if (Necessary.name().equals(name())) { return CDef.Necessary.valueOf(name); }
            if (NotCompletedFlg.name().equals(name())) { return CDef.NotCompletedFlg.valueOf(name); }
            if (NoAllcDisplayFlg.name().equals(name())) { return CDef.NoAllcDisplayFlg.valueOf(name); }
            if (NoConfirmedFlg.name().equals(name())) { return CDef.NoConfirmedFlg.valueOf(name); }
            if (NoStockCls.name().equals(name())) { return CDef.NoStockCls.valueOf(name); }
            if (NoStockOutFlg.name().equals(name())) { return CDef.NoStockOutFlg.valueOf(name); }
            if (NoUpsideDownCls.name().equals(name())) { return CDef.NoUpsideDownCls.valueOf(name); }
            if (OnetimeFlg.name().equals(name())) { return CDef.OnetimeFlg.valueOf(name); }
            if (OverStoreNumFlg.name().equals(name())) { return CDef.OverStoreNumFlg.valueOf(name); }
            if (PackingCalCls.name().equals(name())) { return CDef.PackingCalCls.valueOf(name); }
            if (PackingProcessCls.name().equals(name())) { return CDef.PackingProcessCls.valueOf(name); }
            if (PackingShowFlg.name().equals(name())) { return CDef.PackingShowFlg.valueOf(name); }
            if (PackingStatus.name().equals(name())) { return CDef.PackingStatus.valueOf(name); }
            if (PasswordReset.name().equals(name())) { return CDef.PasswordReset.valueOf(name); }
            if (PastStoreDtFlg.name().equals(name())) { return CDef.PastStoreDtFlg.valueOf(name); }
            if (PhysicalDelete.name().equals(name())) { return CDef.PhysicalDelete.valueOf(name); }
            if (PickingFlg.name().equals(name())) { return CDef.PickingFlg.valueOf(name); }
            if (PickingLocationFlg.name().equals(name())) { return CDef.PickingLocationFlg.valueOf(name); }
            if (PickingStatus.name().equals(name())) { return CDef.PickingStatus.valueOf(name); }
            if (PicCls.name().equals(name())) { return CDef.PicCls.valueOf(name); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return CDef.PicMthdRcmdBreakKey.valueOf(name); }
            if (PicMthdRcmdFlg.name().equals(name())) { return CDef.PicMthdRcmdFlg.valueOf(name); }
            if (PicMthdRcmdListOut.name().equals(name())) { return CDef.PicMthdRcmdListOut.valueOf(name); }
            if (PostType.name().equals(name())) { return CDef.PostType.valueOf(name); }
            if (PrintedFlg.name().equals(name())) { return CDef.PrintedFlg.valueOf(name); }
            if (PrintDataType.name().equals(name())) { return CDef.PrintDataType.valueOf(name); }
            if (PrintErrorFlg.name().equals(name())) { return CDef.PrintErrorFlg.valueOf(name); }
            if (PrintQueueStatus.name().equals(name())) { return CDef.PrintQueueStatus.valueOf(name); }
            if (PrintResultClass.name().equals(name())) { return CDef.PrintResultClass.valueOf(name); }
            if (PrintServiceStatus.name().equals(name())) { return CDef.PrintServiceStatus.valueOf(name); }
            if (PrintStatus.name().equals(name())) { return CDef.PrintStatus.valueOf(name); }
            if (PriorityFlg.name().equals(name())) { return CDef.PriorityFlg.valueOf(name); }
            if (ProductLabelJanBarcode.name().equals(name())) { return CDef.ProductLabelJanBarcode.valueOf(name); }
            if (ProductLabelOutUnit.name().equals(name())) { return CDef.ProductLabelOutUnit.valueOf(name); }
            if (ProductLabelProdBarcode.name().equals(name())) { return CDef.ProductLabelProdBarcode.valueOf(name); }
            if (ProductPartPacking.name().equals(name())) { return CDef.ProductPartPacking.valueOf(name); }
            if (ProductTypeCode.name().equals(name())) { return CDef.ProductTypeCode.valueOf(name); }
            if (Qty0Display.name().equals(name())) { return CDef.Qty0Display.valueOf(name); }
            if (ReasonType.name().equals(name())) { return CDef.ReasonType.valueOf(name); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return CDef.ReceiveDeliveryStatus.valueOf(name); }
            if (ReceiveFlg.name().equals(name())) { return CDef.ReceiveFlg.valueOf(name); }
            if (ReceiveStatus.name().equals(name())) { return CDef.ReceiveStatus.valueOf(name); }
            if (ReplenishAllocCls.name().equals(name())) { return CDef.ReplenishAllocCls.valueOf(name); }
            if (ReplenishProductCdUnset.name().equals(name())) { return CDef.ReplenishProductCdUnset.valueOf(name); }
            if (ReplenishSearchCls.name().equals(name())) { return CDef.ReplenishSearchCls.valueOf(name); }
            if (ReplenishUnitCls.name().equals(name())) { return CDef.ReplenishUnitCls.valueOf(name); }
            if (ReportLayoutItemType.name().equals(name())) { return CDef.ReportLayoutItemType.valueOf(name); }
            if (RestockType.name().equals(name())) { return CDef.RestockType.valueOf(name); }
            if (ResultAfterProductLabel.name().equals(name())) { return CDef.ResultAfterProductLabel.valueOf(name); }
            if (ResultAfterProductTarget.name().equals(name())) { return CDef.ResultAfterProductTarget.valueOf(name); }
            if (ReverseValidFlg.name().equals(name())) { return CDef.ReverseValidFlg.valueOf(name); }
            if (RoleControlClass.name().equals(name())) { return CDef.RoleControlClass.valueOf(name); }
            if (Select.name().equals(name())) { return CDef.Select.valueOf(name); }
            if (SelectPrintServiceStatus.name().equals(name())) { return CDef.SelectPrintServiceStatus.valueOf(name); }
            if (SerialOperationType.name().equals(name())) { return CDef.SerialOperationType.valueOf(name); }
            if (SettlementType.name().equals(name())) { return CDef.SettlementType.valueOf(name); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return CDef.SglRowInspAfterOutCls.valueOf(name); }
            if (SglRowPicFlg.name().equals(name())) { return CDef.SglRowPicFlg.valueOf(name); }
            if (SheetCollate.name().equals(name())) { return CDef.SheetCollate.valueOf(name); }
            if (ShippingFlg.name().equals(name())) { return CDef.ShippingFlg.valueOf(name); }
            if (ShippingStatus.name().equals(name())) { return CDef.ShippingStatus.valueOf(name); }
            if (ShippingStopFlg.name().equals(name())) { return CDef.ShippingStopFlg.valueOf(name); }
            if (ShortStockDisplay.name().equals(name())) { return CDef.ShortStockDisplay.valueOf(name); }
            if (ShpCheckCls.name().equals(name())) { return CDef.ShpCheckCls.valueOf(name); }
            if (ShpCheckDisplay.name().equals(name())) { return CDef.ShpCheckDisplay.valueOf(name); }
            if (SlipType.name().equals(name())) { return CDef.SlipType.valueOf(name); }
            if (SoundPlayFlg.name().equals(name())) { return CDef.SoundPlayFlg.valueOf(name); }
            if (StockAdjustFlg.name().equals(name())) { return CDef.StockAdjustFlg.valueOf(name); }
            if (StockDisplayFld.name().equals(name())) { return CDef.StockDisplayFld.valueOf(name); }
            if (StockExistOnlyFlg.name().equals(name())) { return CDef.StockExistOnlyFlg.valueOf(name); }
            if (StockMoveFlg.name().equals(name())) { return CDef.StockMoveFlg.valueOf(name); }
            if (StockNum0Display.name().equals(name())) { return CDef.StockNum0Display.valueOf(name); }
            if (StockOutAllocCls.name().equals(name())) { return CDef.StockOutAllocCls.valueOf(name); }
            if (StockOutAutoInstFlg.name().equals(name())) { return CDef.StockOutAutoInstFlg.valueOf(name); }
            if (StockOutFlg.name().equals(name())) { return CDef.StockOutFlg.valueOf(name); }
            if (StockOutInstCxlFlg.name().equals(name())) { return CDef.StockOutInstCxlFlg.valueOf(name); }
            if (StockOutInstSplitFlg.name().equals(name())) { return CDef.StockOutInstSplitFlg.valueOf(name); }
            if (StockQtyDisplay.name().equals(name())) { return CDef.StockQtyDisplay.valueOf(name); }
            if (StockTakingInput.name().equals(name())) { return CDef.StockTakingInput.valueOf(name); }
            if (StockTarget.name().equals(name())) { return CDef.StockTarget.valueOf(name); }
            if (StoreDtFlg.name().equals(name())) { return CDef.StoreDtFlg.valueOf(name); }
            if (StoreFlg.name().equals(name())) { return CDef.StoreFlg.valueOf(name); }
            if (StoreNoDivideDisplay.name().equals(name())) { return CDef.StoreNoDivideDisplay.valueOf(name); }
            if (StoreNoFlg.name().equals(name())) { return CDef.StoreNoFlg.valueOf(name); }
            if (StoreNoMergeFlg.name().equals(name())) { return CDef.StoreNoMergeFlg.valueOf(name); }
            if (SystemLogStatus.name().equals(name())) { return CDef.SystemLogStatus.valueOf(name); }
            if (SystemLogType.name().equals(name())) { return CDef.SystemLogType.valueOf(name); }
            if (SystemType.name().equals(name())) { return CDef.SystemType.valueOf(name); }
            if (TagDeliveryOutFlg.name().equals(name())) { return CDef.TagDeliveryOutFlg.valueOf(name); }
            if (TakingShippingDtFlg.name().equals(name())) { return CDef.TakingShippingDtFlg.valueOf(name); }
            if (TakingShippingFlg.name().equals(name())) { return CDef.TakingShippingFlg.valueOf(name); }
            if (TargetWindow.name().equals(name())) { return CDef.TargetWindow.valueOf(name); }
            if (TextAlign.name().equals(name())) { return CDef.TextAlign.valueOf(name); }
            if (TotalPicFlg.name().equals(name())) { return CDef.TotalPicFlg.valueOf(name); }
            if (TrackingNumberingUnit.name().equals(name())) { return CDef.TrackingNumberingUnit.valueOf(name); }
            if (TransitDisplay.name().equals(name())) { return CDef.TransitDisplay.valueOf(name); }
            if (Unmatch.name().equals(name())) { return CDef.Unmatch.valueOf(name); }
            if (Updatable.name().equals(name())) { return CDef.Updatable.valueOf(name); }
            if (UpdCd.name().equals(name())) { return CDef.UpdCd.valueOf(name); }
            if (UpdType.name().equals(name())) { return CDef.UpdType.valueOf(name); }
            if (UploadTableNm.name().equals(name())) { return CDef.UploadTableNm.valueOf(name); }
            if (UserEditable.name().equals(name())) { return CDef.UserEditable.valueOf(name); }
            if (UseHtShipFlg.name().equals(name())) { return CDef.UseHtShipFlg.valueOf(name); }
            if (VendorFlg.name().equals(name())) { return CDef.VendorFlg.valueOf(name); }
            if (Visible.name().equals(name())) { return CDef.Visible.valueOf(name); }
            if (WorkFlg.name().equals(name())) { return CDef.WorkFlg.valueOf(name); }
            if (WorkMessageFlg.name().equals(name())) { return CDef.WorkMessageFlg.valueOf(name); }
            if (YamatoDelivTz.name().equals(name())) { return CDef.YamatoDelivTz.valueOf(name); }
            if (YupackDelivTz.name().equals(name())) { return CDef.YupackDelivTz.valueOf(name); }
            if (ZipFlg.name().equals(name())) { return CDef.ZipFlg.valueOf(name); }
            if (AttendanceLeavingRest.name().equals(name())) { return CDef.AttendanceLeavingRest.valueOf(name); }
            if (BolOutputTargetFlg.name().equals(name())) { return CDef.BolOutputTargetFlg.valueOf(name); }
            if (BolOutFlg.name().equals(name())) { return CDef.BolOutFlg.valueOf(name); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return CDef.CallBeforeDeliveryFlg.valueOf(name); }
            if (CasePickFlg.name().equals(name())) { return CDef.CasePickFlg.valueOf(name); }
            if (CasePicTarget.name().equals(name())) { return CDef.CasePicTarget.valueOf(name); }
            if (CesIntegrationFlg.name().equals(name())) { return CDef.CesIntegrationFlg.valueOf(name); }
            if (CodFlg.name().equals(name())) { return CDef.CodFlg.valueOf(name); }
            if (DecimalExistFlg.name().equals(name())) { return CDef.DecimalExistFlg.valueOf(name); }
            if (DecimalProductPacking.name().equals(name())) { return CDef.DecimalProductPacking.valueOf(name); }
            if (DoNotStackStackFlg.name().equals(name())) { return CDef.DoNotStackStackFlg.valueOf(name); }
            if (EmReplenishShapeFlg.name().equals(name())) { return CDef.EmReplenishShapeFlg.valueOf(name); }
            if (FoogFlg.name().equals(name())) { return CDef.FoogFlg.valueOf(name); }
            if (FreezableProtectionFlg.name().equals(name())) { return CDef.FreezableProtectionFlg.valueOf(name); }
            if (FreightCls.name().equals(name())) { return CDef.FreightCls.valueOf(name); }
            if (GuaranteedPlusFlg.name().equals(name())) { return CDef.GuaranteedPlusFlg.valueOf(name); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return CDef.InsideDeliveryCollectFlg.valueOf(name); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return CDef.InsideDeliveryPrepaidFlg.valueOf(name); }
            if (InsidePickupCollectFlg.name().equals(name())) { return CDef.InsidePickupCollectFlg.valueOf(name); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return CDef.InsidePickupPrepaidFlg.valueOf(name); }
            if (InspectionLabelOutFlg.name().equals(name())) { return CDef.InspectionLabelOutFlg.valueOf(name); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return CDef.LiftgateDeliveryCollectFlg.valueOf(name); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return CDef.LiftgateDeliveryPrepaidFlg.valueOf(name); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return CDef.LiftgatePickupCollectFlg.valueOf(name); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return CDef.LiftgatePickupPrepaidFlg.valueOf(name); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return CDef.LimitedAccessDeliveryFlg.valueOf(name); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return CDef.LimitedAccessPickupFlg.valueOf(name); }
            if (OverSizedFlg.name().equals(name())) { return CDef.OverSizedFlg.valueOf(name); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return CDef.PackingSlipAutoOutputFlg.valueOf(name); }
            if (PaymentTerm.name().equals(name())) { return CDef.PaymentTerm.valueOf(name); }
            if (PickingType.name().equals(name())) { return CDef.PickingType.valueOf(name); }
            if (PoisonFlg.name().equals(name())) { return CDef.PoisonFlg.valueOf(name); }
            if (RcmdPickingCls.name().equals(name())) { return CDef.RcmdPickingCls.valueOf(name); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return CDef.ResidentialDeliveryFlg.valueOf(name); }
            if (ResidentialPickupFlg.name().equals(name())) { return CDef.ResidentialPickupFlg.valueOf(name); }
            if (SatDeliveryFlg.name().equals(name())) { return CDef.SatDeliveryFlg.valueOf(name); }
            if (SglRowPicTarget.name().equals(name())) { return CDef.SglRowPicTarget.valueOf(name); }
            if (SignatureReleaseFlg.name().equals(name())) { return CDef.SignatureReleaseFlg.valueOf(name); }
            if (SignatureRequiredFlg.name().equals(name())) { return CDef.SignatureRequiredFlg.valueOf(name); }
            if (UploadZipType.name().equals(name())) { return CDef.UploadZipType.valueOf(name); }
            if (WorkLogOutFlg.name().equals(name())) { return CDef.WorkLogOutFlg.valueOf(name); }
            if (WorkStatus.name().equals(name())) { return CDef.WorkStatus.valueOf(name); }
            if (Adjuststatus.name().equals(name())) { return CDef.Adjuststatus.valueOf(name); }
            if (Companygroup.name().equals(name())) { return CDef.Companygroup.valueOf(name); }
            if (LocGroup.name().equals(name())) { return CDef.LocGroup.valueOf(name); }
            if (Worktype.name().equals(name())) { return CDef.Worktype.valueOf(name); }
            if (Capitemflg.name().equals(name())) { return CDef.Capitemflg.valueOf(name); }
            if (Palletests.name().equals(name())) { return CDef.Palletests.valueOf(name); }
            if (Usid.name().equals(name())) { return CDef.Usid.valueOf(name); }
            if (Itemusedflg.name().equals(name())) { return CDef.Itemusedflg.valueOf(name); }
            if (Symbolsts.name().equals(name())) { return CDef.Symbolsts.valueOf(name); }
            if (Solistkbn.name().equals(name())) { return CDef.Solistkbn.valueOf(name); }
            if (Palletaddflg.name().equals(name())) { return CDef.Palletaddflg.valueOf(name); }
            if (Productdiv.name().equals(name())) { return CDef.Productdiv.valueOf(name); }
            if (Soroutediv.name().equals(name())) { return CDef.Soroutediv.valueOf(name); }
            if (Requesttype.name().equals(name())) { return CDef.Requesttype.valueOf(name); }
            if (Examsts.name().equals(name())) { return CDef.Examsts.valueOf(name); }
            if (Ordernoaddcd.name().equals(name())) { return CDef.Ordernoaddcd.valueOf(name); }
            if (Tracetype.name().equals(name())) { return CDef.Tracetype.valueOf(name); }
            if (Warehouseid.name().equals(name())) { return CDef.Warehouseid.valueOf(name); }
            if (Markettype.name().equals(name())) { return CDef.Markettype.valueOf(name); }
            if (Reservationflg.name().equals(name())) { return CDef.Reservationflg.valueOf(name); }
            if (Packingtype.name().equals(name())) { return CDef.Packingtype.valueOf(name); }
            if (Productmarkptn.name().equals(name())) { return CDef.Productmarkptn.valueOf(name); }
            if (Productmarkptnbatj.name().equals(name())) { return CDef.Productmarkptnbatj.valueOf(name); }
            if (Productmarkmonth.name().equals(name())) { return CDef.Productmarkmonth.valueOf(name); }
            if (Limitdatemonth.name().equals(name())) { return CDef.Limitdatemonth.valueOf(name); }
            if (Alclimitdatemonth.name().equals(name())) { return CDef.Alclimitdatemonth.valueOf(name); }
            if (Labellayoutmaster.name().equals(name())) { return CDef.Labellayoutmaster.valueOf(name); }
            if (Trafficpattern.name().equals(name())) { return CDef.Trafficpattern.valueOf(name); }
            if (Cgrid.name().equals(name())) { return CDef.Cgrid.valueOf(name); }
            if (Reportname.name().equals(name())) { return CDef.Reportname.valueOf(name); }
            if (Jyokenflg.name().equals(name())) { return CDef.Jyokenflg.valueOf(name); }
            if (Imshiptocode.name().equals(name())) { return CDef.Imshiptocode.valueOf(name); }
            if (Fileinfo.name().equals(name())) { return CDef.Fileinfo.valueOf(name); }
            if (Shiptocdchg.name().equals(name())) { return CDef.Shiptocdchg.valueOf(name); }
            if (Tdwmscd.name().equals(name())) { return CDef.Tdwmscd.valueOf(name); }
            if (Inoutdatatype.name().equals(name())) { return CDef.Inoutdatatype.valueOf(name); }
            if (Invmoveterm.name().equals(name())) { return CDef.Invmoveterm.valueOf(name); }
            if (Symbolsendhulftmaster.name().equals(name())) { return CDef.Symbolsendhulftmaster.valueOf(name); }
            if (Logflag.name().equals(name())) { return CDef.Logflag.valueOf(name); }
            if (Assortmentsts.name().equals(name())) { return CDef.Assortmentsts.valueOf(name); }
            if (Assortmentflg.name().equals(name())) { return CDef.Assortmentflg.valueOf(name); }
            if (Aststsforsearch.name().equals(name())) { return CDef.Aststsforsearch.valueOf(name); }
            if (Firstexamsendflg.name().equals(name())) { return CDef.Firstexamsendflg.valueOf(name); }
            if (Mossendflg.name().equals(name())) { return CDef.Mossendflg.valueOf(name); }
            if (Casecreatetype.name().equals(name())) { return CDef.Casecreatetype.valueOf(name); }
            if (Mosjtsendflg.name().equals(name())) { return CDef.Mosjtsendflg.valueOf(name); }
            if (Batkeepwarehousecd.name().equals(name())) { return CDef.Batkeepwarehousecd.valueOf(name); }
            if (Batwarehousecd.name().equals(name())) { return CDef.Batwarehousecd.valueOf(name); }
            if (Datamakeflg.name().equals(name())) { return CDef.Datamakeflg.valueOf(name); }
            if (Rcvresultqtytype.name().equals(name())) { return CDef.Rcvresultqtytype.valueOf(name); }
            if (Qualityexamflg.name().equals(name())) { return CDef.Qualityexamflg.valueOf(name); }
            if (Makercasecodefixedvalue.name().equals(name())) { return CDef.Makercasecodefixedvalue.valueOf(name); }
            if (Productmarkjttaxfree.name().equals(name())) { return CDef.Productmarkjttaxfree.valueOf(name); }
            if (PrinterdefS011.name().equals(name())) { return CDef.PrinterdefS011.valueOf(name); }
            if (PrinterdefS012.name().equals(name())) { return CDef.PrinterdefS012.valueOf(name); }
            if (PrinterdefN002.name().equals(name())) { return CDef.PrinterdefN002.valueOf(name); }
            if (PrinterdefZ005.name().equals(name())) { return CDef.PrinterdefZ005.valueOf(name); }
            if (Sortstockkbn.name().equals(name())) { return CDef.Sortstockkbn.valueOf(name); }
            if (Tracetypedt.name().equals(name())) { return CDef.Tracetypedt.valueOf(name); }
            if (Racklabelprflg.name().equals(name())) { return CDef.Racklabelprflg.valueOf(name); }
            if (PrinterdefS0031.name().equals(name())) { return CDef.PrinterdefS0031.valueOf(name); }
            if (PrinterdefS0032.name().equals(name())) { return CDef.PrinterdefS0032.valueOf(name); }
            if (PrinterdefS0033.name().equals(name())) { return CDef.PrinterdefS0033.valueOf(name); }
            if (PrinterdefS0034.name().equals(name())) { return CDef.PrinterdefS0034.valueOf(name); }
            if (Unknowncaselimit.name().equals(name())) { return CDef.Unknowncaselimit.valueOf(name); }
            if (Sortinvkbn.name().equals(name())) { return CDef.Sortinvkbn.valueOf(name); }
            if (Cloudcasenum.name().equals(name())) { return CDef.Cloudcasenum.valueOf(name); }
            if (Pulltype.name().equals(name())) { return CDef.Pulltype.valueOf(name); }
            if (Storageloc.name().equals(name())) { return CDef.Storageloc.valueOf(name); }
            if (Pallettracetype.name().equals(name())) { return CDef.Pallettracetype.valueOf(name); }
            if (Datasendtype.name().equals(name())) { return CDef.Datasendtype.valueOf(name); }
            if (Tracecreatests.name().equals(name())) { return CDef.Tracecreatests.valueOf(name); }
            if (Sortinvtiming.name().equals(name())) { return CDef.Sortinvtiming.valueOf(name); }
            if (Casesupplytype.name().equals(name())) { return CDef.Casesupplytype.valueOf(name); }
            if (Importumu.name().equals(name())) { return CDef.Importumu.valueOf(name); }
            if (Traceshiftflg.name().equals(name())) { return CDef.Traceshiftflg.valueOf(name); }
            if (Shtypecd.name().equals(name())) { return CDef.Shtypecd.valueOf(name); }
            if (Allocpolicy.name().equals(name())) { return CDef.Allocpolicy.valueOf(name); }
            if (Rtncompanyname.name().equals(name())) { return CDef.Rtncompanyname.valueOf(name); }
            if (Opendiff.name().equals(name())) { return CDef.Opendiff.valueOf(name); }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return CDef.ItemcdlookupAvailableflg.valueOf(name); }
            if (Flexpickprflg.name().equals(name())) { return CDef.Flexpickprflg.valueOf(name); }
            if (WorkmasterExp.name().equals(name())) { return CDef.WorkmasterExp.valueOf(name); }
            if (Tasktype.name().equals(name())) { return CDef.Tasktype.valueOf(name); }
            if (Tasktypedetail.name().equals(name())) { return CDef.Tasktypedetail.valueOf(name); }
            if (Yztraceshiftflg.name().equals(name())) { return CDef.Yztraceshiftflg.valueOf(name); }
            if (Workercdsearchtype.name().equals(name())) { return CDef.Workercdsearchtype.valueOf(name); }
            if (PrinterdefZ004.name().equals(name())) { return CDef.PrinterdefZ004.valueOf(name); }
            if (PrinterdefZ008.name().equals(name())) { return CDef.PrinterdefZ008.valueOf(name); }
            if (Pickdistname.name().equals(name())) { return CDef.Pickdistname.valueOf(name); }
            if (Traceswitchflg.name().equals(name())) { return CDef.Traceswitchflg.valueOf(name); }
            if (Lblkbn.name().equals(name())) { return CDef.Lblkbn.valueOf(name); }
            if (Assortkbn.name().equals(name())) { return CDef.Assortkbn.valueOf(name); }
            if (Dmycasecd.name().equals(name())) { return CDef.Dmycasecd.valueOf(name); }
            if (Baditemdelkbn.name().equals(name())) { return CDef.Baditemdelkbn.valueOf(name); }
            if (Selectlimit.name().equals(name())) { return CDef.Selectlimit.valueOf(name); }
            if (PrinterdefW001.name().equals(name())) { return CDef.PrinterdefW001.valueOf(name); }
            if (PrinterdefW002.name().equals(name())) { return CDef.PrinterdefW002.valueOf(name); }
            if (Settlementinvmonth.name().equals(name())) { return CDef.Settlementinvmonth.valueOf(name); }
            if (Flexinstructsts.name().equals(name())) { return CDef.Flexinstructsts.valueOf(name); }
            if (Compulsionflg.name().equals(name())) { return CDef.Compulsionflg.valueOf(name); }
            if (Displaymonth.name().equals(name())) { return CDef.Displaymonth.valueOf(name); }
            if (Sufferusagesearchflg.name().equals(name())) { return CDef.Sufferusagesearchflg.valueOf(name); }
            if (Fltstdinv.name().equals(name())) { return CDef.Fltstdinv.valueOf(name); }
            if (Cs3switchflg.name().equals(name())) { return CDef.Cs3switchflg.valueOf(name); }
            if (Inadequacyarea.name().equals(name())) { return CDef.Inadequacyarea.valueOf(name); }
            if (Transmitflg.name().equals(name())) { return CDef.Transmitflg.valueOf(name); }
            if (Flalterflg.name().equals(name())) { return CDef.Flalterflg.valueOf(name); }
            if (Invsts.name().equals(name())) { return CDef.Invsts.valueOf(name); }
            if (Concurrentbase.name().equals(name())) { return CDef.Concurrentbase.valueOf(name); }
            if (Concurrentname.name().equals(name())) { return CDef.Concurrentname.valueOf(name); }
            if (Caseshipstatus.name().equals(name())) { return CDef.Caseshipstatus.valueOf(name); }
            if (Ngpitemcd.name().equals(name())) { return CDef.Ngpitemcd.valueOf(name); }
            if (Fzloccd.name().equals(name())) { return CDef.Fzloccd.valueOf(name); }
            if (Whsortinvkbn.name().equals(name())) { return CDef.Whsortinvkbn.valueOf(name); }
            if (Syncreportform.name().equals(name())) { return CDef.Syncreportform.valueOf(name); }
            if (Sortwarehousecd.name().equals(name())) { return CDef.Sortwarehousecd.valueOf(name); }
            if (Hozeiwarehousecd.name().equals(name())) { return CDef.Hozeiwarehousecd.valueOf(name); }
            if (PrinterdefH002.name().equals(name())) { return CDef.PrinterdefH002.valueOf(name); }
            if (Reportformname.name().equals(name())) { return CDef.Reportformname.valueOf(name); }
            if (Taskname.name().equals(name())) { return CDef.Taskname.valueOf(name); }
            if (Whinvkbn.name().equals(name())) { return CDef.Whinvkbn.valueOf(name); }
            if (Procflg.name().equals(name())) { return CDef.Procflg.valueOf(name); }
            if (SyhnKbn.name().equals(name())) { return CDef.SyhnKbn.valueOf(name); }
            if (Pallettype.name().equals(name())) { return CDef.Pallettype.valueOf(name); }
            if (InventoryInstKbn.name().equals(name())) { return CDef.InventoryInstKbn.valueOf(name); }
            if (InventoryReport.name().equals(name())) { return CDef.InventoryReport.valueOf(name); }
            if (Completeflg.name().equals(name())) { return CDef.Completeflg.valueOf(name); }
            if (Oneitemonlyflg.name().equals(name())) { return CDef.Oneitemonlyflg.valueOf(name); }
            if (Oneowneronlyflg.name().equals(name())) { return CDef.Oneowneronlyflg.valueOf(name); }
            if (Picktype.name().equals(name())) { return CDef.Picktype.valueOf(name); }
            if (Rcvtype.name().equals(name())) { return CDef.Rcvtype.valueOf(name); }
            if (Slottype.name().equals(name())) { return CDef.Slottype.valueOf(name); }
            if (Capselect.name().equals(name())) { return CDef.Capselect.valueOf(name); }
            if (Kashikokuzeikubn.name().equals(name())) { return CDef.Kashikokuzeikubn.valueOf(name); }
            if (Instructflg.name().equals(name())) { return CDef.Instructflg.valueOf(name); }
            if (Palleteoutputtype.name().equals(name())) { return CDef.Palleteoutputtype.valueOf(name); }
            if (Palletecuttingkbn.name().equals(name())) { return CDef.Palletecuttingkbn.valueOf(name); }
            if (Frontrackcd.name().equals(name())) { return CDef.Frontrackcd.valueOf(name); }
            if (Sufferflg.name().equals(name())) { return CDef.Sufferflg.valueOf(name); }
            if (Unmatchflg.name().equals(name())) { return CDef.Unmatchflg.valueOf(name); }
            if (Alcimrsnflg.name().equals(name())) { return CDef.Alcimrsnflg.valueOf(name); }
            if (Manyfewoccurarea.name().equals(name())) { return CDef.Manyfewoccurarea.valueOf(name); }
            if (Manyfewoccurareadisp.name().equals(name())) { return CDef.Manyfewoccurareadisp.valueOf(name); }
            if (Designchg.name().equals(name())) { return CDef.Designchg.valueOf(name); }
            if (Differenceumu.name().equals(name())) { return CDef.Differenceumu.valueOf(name); }
            if (Stockdistinction.name().equals(name())) { return CDef.Stockdistinction.valueOf(name); }
            if (Workmaster.name().equals(name())) { return CDef.Workmaster.valueOf(name); }
            if (Picklisttype.name().equals(name())) { return CDef.Picklisttype.valueOf(name); }
            if (Sortzaikbn.name().equals(name())) { return CDef.Sortzaikbn.valueOf(name); }
            if (Sorttype.name().equals(name())) { return CDef.Sorttype.valueOf(name); }
            if (Exchgmethod.name().equals(name())) { return CDef.Exchgmethod.valueOf(name); }
            if (Conditionflg.name().equals(name())) { return CDef.Conditionflg.valueOf(name); }
            if (Qtyadjustflg.name().equals(name())) { return CDef.Qtyadjustflg.valueOf(name); }
            if (Inoutcode.name().equals(name())) { return CDef.Inoutcode.valueOf(name); }
            if (Inventorytype.name().equals(name())) { return CDef.Inventorytype.valueOf(name); }
            if (Attensionflg.name().equals(name())) { return CDef.Attensionflg.valueOf(name); }
            if (Formdiffflg.name().equals(name())) { return CDef.Formdiffflg.valueOf(name); }
            if (Timingtype.name().equals(name())) { return CDef.Timingtype.valueOf(name); }
            if (Fcflg.name().equals(name())) { return CDef.Fcflg.valueOf(name); }
            if (SundayFlg.name().equals(name())) { return CDef.SundayFlg.valueOf(name); }
            if (Pluralproductionkbn.name().equals(name())) { return CDef.Pluralproductionkbn.valueOf(name); }
            if (Changeflg.name().equals(name())) { return CDef.Changeflg.valueOf(name); }
            if (Rtnstatus.name().equals(name())) { return CDef.Rtnstatus.valueOf(name); }
            if (Rtninspestatus.name().equals(name())) { return CDef.Rtninspestatus.valueOf(name); }
            if (Inventoryref.name().equals(name())) { return CDef.Inventoryref.valueOf(name); }
            if (Restockflg.name().equals(name())) { return CDef.Restockflg.valueOf(name); }
            if (Validtype.name().equals(name())) { return CDef.Validtype.valueOf(name); }
            if (Rtnchangedivision.name().equals(name())) { return CDef.Rtnchangedivision.valueOf(name); }
            if (Storagearea.name().equals(name())) { return CDef.Storagearea.valueOf(name); }
            if (Maxinvflg.name().equals(name())) { return CDef.Maxinvflg.valueOf(name); }
            if (Horyukbn.name().equals(name())) { return CDef.Horyukbn.valueOf(name); }
            if (Useflg.name().equals(name())) { return CDef.Useflg.valueOf(name); }
            if (Fckokuflg.name().equals(name())) { return CDef.Fckokuflg.valueOf(name); }
            if (Bowltypeflg.name().equals(name())) { return CDef.Bowltypeflg.valueOf(name); }
            if (Inventoryrefdisp.name().equals(name())) { return CDef.Inventoryrefdisp.valueOf(name); }
            if (Flinstrstatus.name().equals(name())) { return CDef.Flinstrstatus.valueOf(name); }
            if (Flexstatus.name().equals(name())) { return CDef.Flexstatus.valueOf(name); }
            if (Distributioncd.name().equals(name())) { return CDef.Distributioncd.valueOf(name); }
            if (Stocklocation.name().equals(name())) { return CDef.Stocklocation.valueOf(name); }
            if (ResultStatus.name().equals(name())) { return CDef.ResultStatus.valueOf(name); }
            if (BoxCategory.name().equals(name())) { return CDef.BoxCategory.valueOf(name); }
            if (Storagewarehousecd.name().equals(name())) { return CDef.Storagewarehousecd.valueOf(name); }
            if (Salestype.name().equals(name())) { return CDef.Salestype.valueOf(name); }
            if (Solistkbn2.name().equals(name())) { return CDef.Solistkbn2.valueOf(name); }
            if (PickingListType.name().equals(name())) { return CDef.PickingListType.valueOf(name); }
            if (CoveredClass.name().equals(name())) { return CDef.CoveredClass.valueOf(name); }
            if (NotCoveredClass.name().equals(name())) { return CDef.NotCoveredClass.valueOf(name); }
            if (PickingWorkStatus.name().equals(name())) { return CDef.PickingWorkStatus.valueOf(name); }
            if (ReprintedFlg.name().equals(name())) { return CDef.ReprintedFlg.valueOf(name); }
            if (Cggdid.name().equals(name())) { return CDef.Cggdid.valueOf(name); }
            if (RcvPlanSts.name().equals(name())) { return CDef.RcvPlanSts.valueOf(name); }
            if (Virtuallocflg.name().equals(name())) { return CDef.Virtuallocflg.valueOf(name); }
            if (SufferUsageFlg.name().equals(name())) { return CDef.SufferUsageFlg.valueOf(name); }
            if (Thedaysortingcompleteflg.name().equals(name())) { return CDef.Thedaysortingcompleteflg.valueOf(name); }
            if (Gooditemkbn.name().equals(name())) { return CDef.Gooditemkbn.valueOf(name); }
            if (Slptyp.name().equals(name())) { return CDef.Slptyp.valueOf(name); }
            if (SostatusForserch2.name().equals(name())) { return CDef.SostatusForserch2.valueOf(name); }
            if (LineOrderKbn.name().equals(name())) { return CDef.LineOrderKbn.valueOf(name); }
            if (Consolidationflg.name().equals(name())) { return CDef.Consolidationflg.valueOf(name); }
            if (DaysOfWeek.name().equals(name())) { return CDef.DaysOfWeek.valueOf(name); }
            if (Lockbn.name().equals(name())) { return CDef.Lockbn.valueOf(name); }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return CDef.ReplenishmentRoundedupUnit.valueOf(name); }
            if (Restockkbn.name().equals(name())) { return CDef.Restockkbn.valueOf(name); }
            if (Zaikodiv.name().equals(name())) { return CDef.Zaikodiv.valueOf(name); }
            if (Openflg.name().equals(name())) { return CDef.Openflg.valueOf(name); }
            if (TodayPrintOnlyFlg.name().equals(name())) { return CDef.TodayPrintOnlyFlg.valueOf(name); }
            if (StartEnd.name().equals(name())) { return CDef.StartEnd.valueOf(name); }
            if (SyhnKbnJt.name().equals(name())) { return CDef.SyhnKbnJt.valueOf(name); }
            if (Transkbn.name().equals(name())) { return CDef.Transkbn.valueOf(name); }
            if (Carknd.name().equals(name())) { return CDef.Carknd.valueOf(name); }
            if (Cartypecmb0tdisp.name().equals(name())) { return CDef.Cartypecmb0tdisp.valueOf(name); }
            if (CenterPicListCls1.name().equals(name())) { return CDef.CenterPicListCls1.valueOf(name); }
            if (CenterPicListCls2.name().equals(name())) { return CDef.CenterPicListCls2.valueOf(name); }
            if (CenterPicListCls3.name().equals(name())) { return CDef.CenterPicListCls3.valueOf(name); }
            if (CenterSagawaDelivTz.name().equals(name())) { return CDef.CenterSagawaDelivTz.valueOf(name); }
            if (CenterTransportTypeItem.name().equals(name())) { return CDef.CenterTransportTypeItem.valueOf(name); }
            if (CenterSlipShapeCd.name().equals(name())) { return CDef.CenterSlipShapeCd.valueOf(name); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return CDef.CenterTransportTypeSpeed.valueOf(name); }
            if (CenterSealType.name().equals(name())) { return CDef.CenterSealType.valueOf(name); }
            if (CenterTagClass.name().equals(name())) { return CDef.CenterTagClass.valueOf(name); }
            if (CenterTagDataType.name().equals(name())) { return CDef.CenterTagDataType.valueOf(name); }
            if (CenterTagType.name().equals(name())) { return CDef.CenterTagType.valueOf(name); }
            if (CenterTagTypeAfter.name().equals(name())) { return CDef.CenterTagTypeAfter.valueOf(name); }
            if (CenterApiBinsyuCode.name().equals(name())) { return CDef.CenterApiBinsyuCode.valueOf(name); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return CDef.CenterApiDaibikiFlg.valueOf(name); }
            if (CenterApiDaibikiType.name().equals(name())) { return CDef.CenterApiDaibikiType.valueOf(name); }
            if (CenterApiEidomeFlg.name().equals(name())) { return CDef.CenterApiEidomeFlg.valueOf(name); }
            if (CenterApiWeightCd.name().equals(name())) { return CDef.CenterApiWeightCd.valueOf(name); }
            if (CenterOutputTargetFlg.name().equals(name())) { return CDef.CenterOutputTargetFlg.valueOf(name); }
            if (CenterPrintCondition.name().equals(name())) { return CDef.CenterPrintCondition.valueOf(name); }
            if (CenterDesignflg.name().equals(name())) { return CDef.CenterDesignflg.valueOf(name); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public List<Classification> listAll() {
            if (ProcessTypeCd.name().equals(name())) { return toClsList(CDef.ProcessTypeCd.listAll()); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return toClsList(CDef.AfterDelivSlipOutTgt.listAll()); }
            if (AfterTagOutFlg.name().equals(name())) { return toClsList(CDef.AfterTagOutFlg.listAll()); }
            if (AllcNgDisplay.name().equals(name())) { return toClsList(CDef.AllcNgDisplay.listAll()); }
            if (AllcNgFlg.name().equals(name())) { return toClsList(CDef.AllcNgFlg.listAll()); }
            if (AllocSortKey.name().equals(name())) { return toClsList(CDef.AllocSortKey.listAll()); }
            if (AllShippingFlg.name().equals(name())) { return toClsList(CDef.AllShippingFlg.listAll()); }
            if (ArrivalStoreFormat.name().equals(name())) { return toClsList(CDef.ArrivalStoreFormat.listAll()); }
            if (AutoEmgSetFlg.name().equals(name())) { return toClsList(CDef.AutoEmgSetFlg.listAll()); }
            if (AutoEmgSetTgt.name().equals(name())) { return toClsList(CDef.AutoEmgSetTgt.listAll()); }
            if (AutoPrintTargetFlg.name().equals(name())) { return toClsList(CDef.AutoPrintTargetFlg.listAll()); }
            if (AutoShipInstFlg.name().equals(name())) { return toClsList(CDef.AutoShipInstFlg.listAll()); }
            if (BarcodeType.name().equals(name())) { return toClsList(CDef.BarcodeType.listAll()); }
            if (BatchProgressFlg.name().equals(name())) { return toClsList(CDef.BatchProgressFlg.listAll()); }
            if (BoxSelectSkip.name().equals(name())) { return toClsList(CDef.BoxSelectSkip.listAll()); }
            if (CancelDataDisplay.name().equals(name())) { return toClsList(CDef.CancelDataDisplay.listAll()); }
            if (CasePicFlg.name().equals(name())) { return toClsList(CDef.CasePicFlg.listAll()); }
            if (CenterClientCls.name().equals(name())) { return toClsList(CDef.CenterClientCls.listAll()); }
            if (CenterTransitFlg.name().equals(name())) { return toClsList(CDef.CenterTransitFlg.listAll()); }
            if (CharacterCd.name().equals(name())) { return toClsList(CDef.CharacterCd.listAll()); }
            if (ChargeQty0Display.name().equals(name())) { return toClsList(CDef.ChargeQty0Display.listAll()); }
            if (CheckDigit.name().equals(name())) { return toClsList(CDef.CheckDigit.listAll()); }
            if (CodeFlg.name().equals(name())) { return toClsList(CDef.CodeFlg.listAll()); }
            if (CodeType.name().equals(name())) { return toClsList(CDef.CodeType.listAll()); }
            if (CodCls.name().equals(name())) { return toClsList(CDef.CodCls.listAll()); }
            if (CodType.name().equals(name())) { return toClsList(CDef.CodType.listAll()); }
            if (ColType.name().equals(name())) { return toClsList(CDef.ColType.listAll()); }
            if (CommentFlg.name().equals(name())) { return toClsList(CDef.CommentFlg.listAll()); }
            if (CompanyFlg.name().equals(name())) { return toClsList(CDef.CompanyFlg.listAll()); }
            if (CoolCls.name().equals(name())) { return toClsList(CDef.CoolCls.listAll()); }
            if (CoolType.name().equals(name())) { return toClsList(CDef.CoolType.listAll()); }
            if (CopyTargetTable.name().equals(name())) { return toClsList(CDef.CopyTargetTable.listAll()); }
            if (CorrectType.name().equals(name())) { return toClsList(CDef.CorrectType.listAll()); }
            if (DataInputCommitType.name().equals(name())) { return toClsList(CDef.DataInputCommitType.listAll()); }
            if (DataInputOperationType.name().equals(name())) { return toClsList(CDef.DataInputOperationType.listAll()); }
            if (DataInputProcessType.name().equals(name())) { return toClsList(CDef.DataInputProcessType.listAll()); }
            if (DataInputRange.name().equals(name())) { return toClsList(CDef.DataInputRange.listAll()); }
            if (DataInputType.name().equals(name())) { return toClsList(CDef.DataInputType.listAll()); }
            if (DataType.name().equals(name())) { return toClsList(CDef.DataType.listAll()); }
            if (Default.name().equals(name())) { return toClsList(CDef.Default.listAll()); }
            if (DefaultFlg.name().equals(name())) { return toClsList(CDef.DefaultFlg.listAll()); }
            if (DeleteDataDisplay.name().equals(name())) { return toClsList(CDef.DeleteDataDisplay.listAll()); }
            if (DeliveryFlg.name().equals(name())) { return toClsList(CDef.DeliveryFlg.listAll()); }
            if (DelivMatchFlg.name().equals(name())) { return toClsList(CDef.DelivMatchFlg.listAll()); }
            if (DelivTz.name().equals(name())) { return toClsList(CDef.DelivTz.listAll()); }
            if (DelFlg.name().equals(name())) { return toClsList(CDef.DelFlg.listAll()); }
            if (DepositFlg.name().equals(name())) { return toClsList(CDef.DepositFlg.listAll()); }
            if (DisplayRequired.name().equals(name())) { return toClsList(CDef.DisplayRequired.listAll()); }
            if (DtCls.name().equals(name())) { return toClsList(CDef.DtCls.listAll()); }
            if (Editable.name().equals(name())) { return toClsList(CDef.Editable.listAll()); }
            if (EmergencyDisplay.name().equals(name())) { return toClsList(CDef.EmergencyDisplay.listAll()); }
            if (EmergencyFlg.name().equals(name())) { return toClsList(CDef.EmergencyFlg.listAll()); }
            if (ErrorFlg.name().equals(name())) { return toClsList(CDef.ErrorFlg.listAll()); }
            if (ErrorProcessMet.name().equals(name())) { return toClsList(CDef.ErrorProcessMet.listAll()); }
            if (FixedPoint.name().equals(name())) { return toClsList(CDef.FixedPoint.listAll()); }
            if (ForceFixedFlg.name().equals(name())) { return toClsList(CDef.ForceFixedFlg.listAll()); }
            if (ForeignFlg.name().equals(name())) { return toClsList(CDef.ForeignFlg.listAll()); }
            if (GiftFlg.name().equals(name())) { return toClsList(CDef.GiftFlg.listAll()); }
            if (GiftStatementType.name().equals(name())) { return toClsList(CDef.GiftStatementType.listAll()); }
            if (HtCharReadFlg.name().equals(name())) { return toClsList(CDef.HtCharReadFlg.listAll()); }
            if (ImportFlg.name().equals(name())) { return toClsList(CDef.ImportFlg.listAll()); }
            if (InfoFlg.name().equals(name())) { return toClsList(CDef.InfoFlg.listAll()); }
            if (InoutType.name().equals(name())) { return toClsList(CDef.InoutType.listAll()); }
            if (InputType.name().equals(name())) { return toClsList(CDef.InputType.listAll()); }
            if (InspectionFlg.name().equals(name())) { return toClsList(CDef.InspectionFlg.listAll()); }
            if (InventoryLocationProduct.name().equals(name())) { return toClsList(CDef.InventoryLocationProduct.listAll()); }
            if (InvoiceCreateFlg.name().equals(name())) { return toClsList(CDef.InvoiceCreateFlg.listAll()); }
            if (ItemType.name().equals(name())) { return toClsList(CDef.ItemType.listAll()); }
            if (LastFlg.name().equals(name())) { return toClsList(CDef.LastFlg.listAll()); }
            if (LimitDtManagFlg.name().equals(name())) { return toClsList(CDef.LimitDtManagFlg.listAll()); }
            if (LimitDtReverseFlg.name().equals(name())) { return toClsList(CDef.LimitDtReverseFlg.listAll()); }
            if (LimitMessageCd.name().equals(name())) { return toClsList(CDef.LimitMessageCd.listAll()); }
            if (LineFeedCd.name().equals(name())) { return toClsList(CDef.LineFeedCd.listAll()); }
            if (ListOutFlg.name().equals(name())) { return toClsList(CDef.ListOutFlg.listAll()); }
            if (ListOutFlgDisp.name().equals(name())) { return toClsList(CDef.ListOutFlgDisp.listAll()); }
            if (ListOutKbn.name().equals(name())) { return toClsList(CDef.ListOutKbn.listAll()); }
            if (LoadingFlg.name().equals(name())) { return toClsList(CDef.LoadingFlg.listAll()); }
            if (LocationType.name().equals(name())) { return toClsList(CDef.LocationType.listAll()); }
            if (Lockout.name().equals(name())) { return toClsList(CDef.Lockout.listAll()); }
            if (LogDtlStatus.name().equals(name())) { return toClsList(CDef.LogDtlStatus.listAll()); }
            if (LogDtlType.name().equals(name())) { return toClsList(CDef.LogDtlType.listAll()); }
            if (LogStatus.name().equals(name())) { return toClsList(CDef.LogStatus.listAll()); }
            if (LotManagFlg.name().equals(name())) { return toClsList(CDef.LotManagFlg.listAll()); }
            if (LotReverseFlg.name().equals(name())) { return toClsList(CDef.LotReverseFlg.listAll()); }
            if (MergeCls.name().equals(name())) { return toClsList(CDef.MergeCls.listAll()); }
            if (MergeFlg.name().equals(name())) { return toClsList(CDef.MergeFlg.listAll()); }
            if (MessageType.name().equals(name())) { return toClsList(CDef.MessageType.listAll()); }
            if (MixedFlg.name().equals(name())) { return toClsList(CDef.MixedFlg.listAll()); }
            if (MoveInstStatus.name().equals(name())) { return toClsList(CDef.MoveInstStatus.listAll()); }
            if (MultiPicCls.name().equals(name())) { return toClsList(CDef.MultiPicCls.listAll()); }
            if (MultiPicFlg.name().equals(name())) { return toClsList(CDef.MultiPicFlg.listAll()); }
            if (Necessary.name().equals(name())) { return toClsList(CDef.Necessary.listAll()); }
            if (NotCompletedFlg.name().equals(name())) { return toClsList(CDef.NotCompletedFlg.listAll()); }
            if (NoAllcDisplayFlg.name().equals(name())) { return toClsList(CDef.NoAllcDisplayFlg.listAll()); }
            if (NoConfirmedFlg.name().equals(name())) { return toClsList(CDef.NoConfirmedFlg.listAll()); }
            if (NoStockCls.name().equals(name())) { return toClsList(CDef.NoStockCls.listAll()); }
            if (NoStockOutFlg.name().equals(name())) { return toClsList(CDef.NoStockOutFlg.listAll()); }
            if (NoUpsideDownCls.name().equals(name())) { return toClsList(CDef.NoUpsideDownCls.listAll()); }
            if (OnetimeFlg.name().equals(name())) { return toClsList(CDef.OnetimeFlg.listAll()); }
            if (OverStoreNumFlg.name().equals(name())) { return toClsList(CDef.OverStoreNumFlg.listAll()); }
            if (PackingCalCls.name().equals(name())) { return toClsList(CDef.PackingCalCls.listAll()); }
            if (PackingProcessCls.name().equals(name())) { return toClsList(CDef.PackingProcessCls.listAll()); }
            if (PackingShowFlg.name().equals(name())) { return toClsList(CDef.PackingShowFlg.listAll()); }
            if (PackingStatus.name().equals(name())) { return toClsList(CDef.PackingStatus.listAll()); }
            if (PasswordReset.name().equals(name())) { return toClsList(CDef.PasswordReset.listAll()); }
            if (PastStoreDtFlg.name().equals(name())) { return toClsList(CDef.PastStoreDtFlg.listAll()); }
            if (PhysicalDelete.name().equals(name())) { return toClsList(CDef.PhysicalDelete.listAll()); }
            if (PickingFlg.name().equals(name())) { return toClsList(CDef.PickingFlg.listAll()); }
            if (PickingLocationFlg.name().equals(name())) { return toClsList(CDef.PickingLocationFlg.listAll()); }
            if (PickingStatus.name().equals(name())) { return toClsList(CDef.PickingStatus.listAll()); }
            if (PicCls.name().equals(name())) { return toClsList(CDef.PicCls.listAll()); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return toClsList(CDef.PicMthdRcmdBreakKey.listAll()); }
            if (PicMthdRcmdFlg.name().equals(name())) { return toClsList(CDef.PicMthdRcmdFlg.listAll()); }
            if (PicMthdRcmdListOut.name().equals(name())) { return toClsList(CDef.PicMthdRcmdListOut.listAll()); }
            if (PostType.name().equals(name())) { return toClsList(CDef.PostType.listAll()); }
            if (PrintedFlg.name().equals(name())) { return toClsList(CDef.PrintedFlg.listAll()); }
            if (PrintDataType.name().equals(name())) { return toClsList(CDef.PrintDataType.listAll()); }
            if (PrintErrorFlg.name().equals(name())) { return toClsList(CDef.PrintErrorFlg.listAll()); }
            if (PrintQueueStatus.name().equals(name())) { return toClsList(CDef.PrintQueueStatus.listAll()); }
            if (PrintResultClass.name().equals(name())) { return toClsList(CDef.PrintResultClass.listAll()); }
            if (PrintServiceStatus.name().equals(name())) { return toClsList(CDef.PrintServiceStatus.listAll()); }
            if (PrintStatus.name().equals(name())) { return toClsList(CDef.PrintStatus.listAll()); }
            if (PriorityFlg.name().equals(name())) { return toClsList(CDef.PriorityFlg.listAll()); }
            if (ProductLabelJanBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelJanBarcode.listAll()); }
            if (ProductLabelOutUnit.name().equals(name())) { return toClsList(CDef.ProductLabelOutUnit.listAll()); }
            if (ProductLabelProdBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelProdBarcode.listAll()); }
            if (ProductPartPacking.name().equals(name())) { return toClsList(CDef.ProductPartPacking.listAll()); }
            if (ProductTypeCode.name().equals(name())) { return toClsList(CDef.ProductTypeCode.listAll()); }
            if (Qty0Display.name().equals(name())) { return toClsList(CDef.Qty0Display.listAll()); }
            if (ReasonType.name().equals(name())) { return toClsList(CDef.ReasonType.listAll()); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return toClsList(CDef.ReceiveDeliveryStatus.listAll()); }
            if (ReceiveFlg.name().equals(name())) { return toClsList(CDef.ReceiveFlg.listAll()); }
            if (ReceiveStatus.name().equals(name())) { return toClsList(CDef.ReceiveStatus.listAll()); }
            if (ReplenishAllocCls.name().equals(name())) { return toClsList(CDef.ReplenishAllocCls.listAll()); }
            if (ReplenishProductCdUnset.name().equals(name())) { return toClsList(CDef.ReplenishProductCdUnset.listAll()); }
            if (ReplenishSearchCls.name().equals(name())) { return toClsList(CDef.ReplenishSearchCls.listAll()); }
            if (ReplenishUnitCls.name().equals(name())) { return toClsList(CDef.ReplenishUnitCls.listAll()); }
            if (ReportLayoutItemType.name().equals(name())) { return toClsList(CDef.ReportLayoutItemType.listAll()); }
            if (RestockType.name().equals(name())) { return toClsList(CDef.RestockType.listAll()); }
            if (ResultAfterProductLabel.name().equals(name())) { return toClsList(CDef.ResultAfterProductLabel.listAll()); }
            if (ResultAfterProductTarget.name().equals(name())) { return toClsList(CDef.ResultAfterProductTarget.listAll()); }
            if (ReverseValidFlg.name().equals(name())) { return toClsList(CDef.ReverseValidFlg.listAll()); }
            if (RoleControlClass.name().equals(name())) { return toClsList(CDef.RoleControlClass.listAll()); }
            if (Select.name().equals(name())) { return toClsList(CDef.Select.listAll()); }
            if (SelectPrintServiceStatus.name().equals(name())) { return toClsList(CDef.SelectPrintServiceStatus.listAll()); }
            if (SerialOperationType.name().equals(name())) { return toClsList(CDef.SerialOperationType.listAll()); }
            if (SettlementType.name().equals(name())) { return toClsList(CDef.SettlementType.listAll()); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return toClsList(CDef.SglRowInspAfterOutCls.listAll()); }
            if (SglRowPicFlg.name().equals(name())) { return toClsList(CDef.SglRowPicFlg.listAll()); }
            if (SheetCollate.name().equals(name())) { return toClsList(CDef.SheetCollate.listAll()); }
            if (ShippingFlg.name().equals(name())) { return toClsList(CDef.ShippingFlg.listAll()); }
            if (ShippingStatus.name().equals(name())) { return toClsList(CDef.ShippingStatus.listAll()); }
            if (ShippingStopFlg.name().equals(name())) { return toClsList(CDef.ShippingStopFlg.listAll()); }
            if (ShortStockDisplay.name().equals(name())) { return toClsList(CDef.ShortStockDisplay.listAll()); }
            if (ShpCheckCls.name().equals(name())) { return toClsList(CDef.ShpCheckCls.listAll()); }
            if (ShpCheckDisplay.name().equals(name())) { return toClsList(CDef.ShpCheckDisplay.listAll()); }
            if (SlipType.name().equals(name())) { return toClsList(CDef.SlipType.listAll()); }
            if (SoundPlayFlg.name().equals(name())) { return toClsList(CDef.SoundPlayFlg.listAll()); }
            if (StockAdjustFlg.name().equals(name())) { return toClsList(CDef.StockAdjustFlg.listAll()); }
            if (StockDisplayFld.name().equals(name())) { return toClsList(CDef.StockDisplayFld.listAll()); }
            if (StockExistOnlyFlg.name().equals(name())) { return toClsList(CDef.StockExistOnlyFlg.listAll()); }
            if (StockMoveFlg.name().equals(name())) { return toClsList(CDef.StockMoveFlg.listAll()); }
            if (StockNum0Display.name().equals(name())) { return toClsList(CDef.StockNum0Display.listAll()); }
            if (StockOutAllocCls.name().equals(name())) { return toClsList(CDef.StockOutAllocCls.listAll()); }
            if (StockOutAutoInstFlg.name().equals(name())) { return toClsList(CDef.StockOutAutoInstFlg.listAll()); }
            if (StockOutFlg.name().equals(name())) { return toClsList(CDef.StockOutFlg.listAll()); }
            if (StockOutInstCxlFlg.name().equals(name())) { return toClsList(CDef.StockOutInstCxlFlg.listAll()); }
            if (StockOutInstSplitFlg.name().equals(name())) { return toClsList(CDef.StockOutInstSplitFlg.listAll()); }
            if (StockQtyDisplay.name().equals(name())) { return toClsList(CDef.StockQtyDisplay.listAll()); }
            if (StockTakingInput.name().equals(name())) { return toClsList(CDef.StockTakingInput.listAll()); }
            if (StockTarget.name().equals(name())) { return toClsList(CDef.StockTarget.listAll()); }
            if (StoreDtFlg.name().equals(name())) { return toClsList(CDef.StoreDtFlg.listAll()); }
            if (StoreFlg.name().equals(name())) { return toClsList(CDef.StoreFlg.listAll()); }
            if (StoreNoDivideDisplay.name().equals(name())) { return toClsList(CDef.StoreNoDivideDisplay.listAll()); }
            if (StoreNoFlg.name().equals(name())) { return toClsList(CDef.StoreNoFlg.listAll()); }
            if (StoreNoMergeFlg.name().equals(name())) { return toClsList(CDef.StoreNoMergeFlg.listAll()); }
            if (SystemLogStatus.name().equals(name())) { return toClsList(CDef.SystemLogStatus.listAll()); }
            if (SystemLogType.name().equals(name())) { return toClsList(CDef.SystemLogType.listAll()); }
            if (SystemType.name().equals(name())) { return toClsList(CDef.SystemType.listAll()); }
            if (TagDeliveryOutFlg.name().equals(name())) { return toClsList(CDef.TagDeliveryOutFlg.listAll()); }
            if (TakingShippingDtFlg.name().equals(name())) { return toClsList(CDef.TakingShippingDtFlg.listAll()); }
            if (TakingShippingFlg.name().equals(name())) { return toClsList(CDef.TakingShippingFlg.listAll()); }
            if (TargetWindow.name().equals(name())) { return toClsList(CDef.TargetWindow.listAll()); }
            if (TextAlign.name().equals(name())) { return toClsList(CDef.TextAlign.listAll()); }
            if (TotalPicFlg.name().equals(name())) { return toClsList(CDef.TotalPicFlg.listAll()); }
            if (TrackingNumberingUnit.name().equals(name())) { return toClsList(CDef.TrackingNumberingUnit.listAll()); }
            if (TransitDisplay.name().equals(name())) { return toClsList(CDef.TransitDisplay.listAll()); }
            if (Unmatch.name().equals(name())) { return toClsList(CDef.Unmatch.listAll()); }
            if (Updatable.name().equals(name())) { return toClsList(CDef.Updatable.listAll()); }
            if (UpdCd.name().equals(name())) { return toClsList(CDef.UpdCd.listAll()); }
            if (UpdType.name().equals(name())) { return toClsList(CDef.UpdType.listAll()); }
            if (UploadTableNm.name().equals(name())) { return toClsList(CDef.UploadTableNm.listAll()); }
            if (UserEditable.name().equals(name())) { return toClsList(CDef.UserEditable.listAll()); }
            if (UseHtShipFlg.name().equals(name())) { return toClsList(CDef.UseHtShipFlg.listAll()); }
            if (VendorFlg.name().equals(name())) { return toClsList(CDef.VendorFlg.listAll()); }
            if (Visible.name().equals(name())) { return toClsList(CDef.Visible.listAll()); }
            if (WorkFlg.name().equals(name())) { return toClsList(CDef.WorkFlg.listAll()); }
            if (WorkMessageFlg.name().equals(name())) { return toClsList(CDef.WorkMessageFlg.listAll()); }
            if (YamatoDelivTz.name().equals(name())) { return toClsList(CDef.YamatoDelivTz.listAll()); }
            if (YupackDelivTz.name().equals(name())) { return toClsList(CDef.YupackDelivTz.listAll()); }
            if (ZipFlg.name().equals(name())) { return toClsList(CDef.ZipFlg.listAll()); }
            if (AttendanceLeavingRest.name().equals(name())) { return toClsList(CDef.AttendanceLeavingRest.listAll()); }
            if (BolOutputTargetFlg.name().equals(name())) { return toClsList(CDef.BolOutputTargetFlg.listAll()); }
            if (BolOutFlg.name().equals(name())) { return toClsList(CDef.BolOutFlg.listAll()); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return toClsList(CDef.CallBeforeDeliveryFlg.listAll()); }
            if (CasePickFlg.name().equals(name())) { return toClsList(CDef.CasePickFlg.listAll()); }
            if (CasePicTarget.name().equals(name())) { return toClsList(CDef.CasePicTarget.listAll()); }
            if (CesIntegrationFlg.name().equals(name())) { return toClsList(CDef.CesIntegrationFlg.listAll()); }
            if (CodFlg.name().equals(name())) { return toClsList(CDef.CodFlg.listAll()); }
            if (DecimalExistFlg.name().equals(name())) { return toClsList(CDef.DecimalExistFlg.listAll()); }
            if (DecimalProductPacking.name().equals(name())) { return toClsList(CDef.DecimalProductPacking.listAll()); }
            if (DoNotStackStackFlg.name().equals(name())) { return toClsList(CDef.DoNotStackStackFlg.listAll()); }
            if (EmReplenishShapeFlg.name().equals(name())) { return toClsList(CDef.EmReplenishShapeFlg.listAll()); }
            if (FoogFlg.name().equals(name())) { return toClsList(CDef.FoogFlg.listAll()); }
            if (FreezableProtectionFlg.name().equals(name())) { return toClsList(CDef.FreezableProtectionFlg.listAll()); }
            if (FreightCls.name().equals(name())) { return toClsList(CDef.FreightCls.listAll()); }
            if (GuaranteedPlusFlg.name().equals(name())) { return toClsList(CDef.GuaranteedPlusFlg.listAll()); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryCollectFlg.listAll()); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryPrepaidFlg.listAll()); }
            if (InsidePickupCollectFlg.name().equals(name())) { return toClsList(CDef.InsidePickupCollectFlg.listAll()); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsidePickupPrepaidFlg.listAll()); }
            if (InspectionLabelOutFlg.name().equals(name())) { return toClsList(CDef.InspectionLabelOutFlg.listAll()); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryCollectFlg.listAll()); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryPrepaidFlg.listAll()); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupCollectFlg.listAll()); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupPrepaidFlg.listAll()); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessDeliveryFlg.listAll()); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessPickupFlg.listAll()); }
            if (OverSizedFlg.name().equals(name())) { return toClsList(CDef.OverSizedFlg.listAll()); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return toClsList(CDef.PackingSlipAutoOutputFlg.listAll()); }
            if (PaymentTerm.name().equals(name())) { return toClsList(CDef.PaymentTerm.listAll()); }
            if (PickingType.name().equals(name())) { return toClsList(CDef.PickingType.listAll()); }
            if (PoisonFlg.name().equals(name())) { return toClsList(CDef.PoisonFlg.listAll()); }
            if (RcmdPickingCls.name().equals(name())) { return toClsList(CDef.RcmdPickingCls.listAll()); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return toClsList(CDef.ResidentialDeliveryFlg.listAll()); }
            if (ResidentialPickupFlg.name().equals(name())) { return toClsList(CDef.ResidentialPickupFlg.listAll()); }
            if (SatDeliveryFlg.name().equals(name())) { return toClsList(CDef.SatDeliveryFlg.listAll()); }
            if (SglRowPicTarget.name().equals(name())) { return toClsList(CDef.SglRowPicTarget.listAll()); }
            if (SignatureReleaseFlg.name().equals(name())) { return toClsList(CDef.SignatureReleaseFlg.listAll()); }
            if (SignatureRequiredFlg.name().equals(name())) { return toClsList(CDef.SignatureRequiredFlg.listAll()); }
            if (UploadZipType.name().equals(name())) { return toClsList(CDef.UploadZipType.listAll()); }
            if (WorkLogOutFlg.name().equals(name())) { return toClsList(CDef.WorkLogOutFlg.listAll()); }
            if (WorkStatus.name().equals(name())) { return toClsList(CDef.WorkStatus.listAll()); }
            if (Adjuststatus.name().equals(name())) { return toClsList(CDef.Adjuststatus.listAll()); }
            if (Companygroup.name().equals(name())) { return toClsList(CDef.Companygroup.listAll()); }
            if (LocGroup.name().equals(name())) { return toClsList(CDef.LocGroup.listAll()); }
            if (Worktype.name().equals(name())) { return toClsList(CDef.Worktype.listAll()); }
            if (Capitemflg.name().equals(name())) { return toClsList(CDef.Capitemflg.listAll()); }
            if (Palletests.name().equals(name())) { return toClsList(CDef.Palletests.listAll()); }
            if (Usid.name().equals(name())) { return toClsList(CDef.Usid.listAll()); }
            if (Itemusedflg.name().equals(name())) { return toClsList(CDef.Itemusedflg.listAll()); }
            if (Symbolsts.name().equals(name())) { return toClsList(CDef.Symbolsts.listAll()); }
            if (Solistkbn.name().equals(name())) { return toClsList(CDef.Solistkbn.listAll()); }
            if (Palletaddflg.name().equals(name())) { return toClsList(CDef.Palletaddflg.listAll()); }
            if (Productdiv.name().equals(name())) { return toClsList(CDef.Productdiv.listAll()); }
            if (Soroutediv.name().equals(name())) { return toClsList(CDef.Soroutediv.listAll()); }
            if (Requesttype.name().equals(name())) { return toClsList(CDef.Requesttype.listAll()); }
            if (Examsts.name().equals(name())) { return toClsList(CDef.Examsts.listAll()); }
            if (Ordernoaddcd.name().equals(name())) { return toClsList(CDef.Ordernoaddcd.listAll()); }
            if (Tracetype.name().equals(name())) { return toClsList(CDef.Tracetype.listAll()); }
            if (Warehouseid.name().equals(name())) { return toClsList(CDef.Warehouseid.listAll()); }
            if (Markettype.name().equals(name())) { return toClsList(CDef.Markettype.listAll()); }
            if (Reservationflg.name().equals(name())) { return toClsList(CDef.Reservationflg.listAll()); }
            if (Packingtype.name().equals(name())) { return toClsList(CDef.Packingtype.listAll()); }
            if (Productmarkptn.name().equals(name())) { return toClsList(CDef.Productmarkptn.listAll()); }
            if (Productmarkptnbatj.name().equals(name())) { return toClsList(CDef.Productmarkptnbatj.listAll()); }
            if (Productmarkmonth.name().equals(name())) { return toClsList(CDef.Productmarkmonth.listAll()); }
            if (Limitdatemonth.name().equals(name())) { return toClsList(CDef.Limitdatemonth.listAll()); }
            if (Alclimitdatemonth.name().equals(name())) { return toClsList(CDef.Alclimitdatemonth.listAll()); }
            if (Labellayoutmaster.name().equals(name())) { return toClsList(CDef.Labellayoutmaster.listAll()); }
            if (Trafficpattern.name().equals(name())) { return toClsList(CDef.Trafficpattern.listAll()); }
            if (Cgrid.name().equals(name())) { return toClsList(CDef.Cgrid.listAll()); }
            if (Reportname.name().equals(name())) { return toClsList(CDef.Reportname.listAll()); }
            if (Jyokenflg.name().equals(name())) { return toClsList(CDef.Jyokenflg.listAll()); }
            if (Imshiptocode.name().equals(name())) { return toClsList(CDef.Imshiptocode.listAll()); }
            if (Fileinfo.name().equals(name())) { return toClsList(CDef.Fileinfo.listAll()); }
            if (Shiptocdchg.name().equals(name())) { return toClsList(CDef.Shiptocdchg.listAll()); }
            if (Tdwmscd.name().equals(name())) { return toClsList(CDef.Tdwmscd.listAll()); }
            if (Inoutdatatype.name().equals(name())) { return toClsList(CDef.Inoutdatatype.listAll()); }
            if (Invmoveterm.name().equals(name())) { return toClsList(CDef.Invmoveterm.listAll()); }
            if (Symbolsendhulftmaster.name().equals(name())) { return toClsList(CDef.Symbolsendhulftmaster.listAll()); }
            if (Logflag.name().equals(name())) { return toClsList(CDef.Logflag.listAll()); }
            if (Assortmentsts.name().equals(name())) { return toClsList(CDef.Assortmentsts.listAll()); }
            if (Assortmentflg.name().equals(name())) { return toClsList(CDef.Assortmentflg.listAll()); }
            if (Aststsforsearch.name().equals(name())) { return toClsList(CDef.Aststsforsearch.listAll()); }
            if (Firstexamsendflg.name().equals(name())) { return toClsList(CDef.Firstexamsendflg.listAll()); }
            if (Mossendflg.name().equals(name())) { return toClsList(CDef.Mossendflg.listAll()); }
            if (Casecreatetype.name().equals(name())) { return toClsList(CDef.Casecreatetype.listAll()); }
            if (Mosjtsendflg.name().equals(name())) { return toClsList(CDef.Mosjtsendflg.listAll()); }
            if (Batkeepwarehousecd.name().equals(name())) { return toClsList(CDef.Batkeepwarehousecd.listAll()); }
            if (Batwarehousecd.name().equals(name())) { return toClsList(CDef.Batwarehousecd.listAll()); }
            if (Datamakeflg.name().equals(name())) { return toClsList(CDef.Datamakeflg.listAll()); }
            if (Rcvresultqtytype.name().equals(name())) { return toClsList(CDef.Rcvresultqtytype.listAll()); }
            if (Qualityexamflg.name().equals(name())) { return toClsList(CDef.Qualityexamflg.listAll()); }
            if (Makercasecodefixedvalue.name().equals(name())) { return toClsList(CDef.Makercasecodefixedvalue.listAll()); }
            if (Productmarkjttaxfree.name().equals(name())) { return toClsList(CDef.Productmarkjttaxfree.listAll()); }
            if (PrinterdefS011.name().equals(name())) { return toClsList(CDef.PrinterdefS011.listAll()); }
            if (PrinterdefS012.name().equals(name())) { return toClsList(CDef.PrinterdefS012.listAll()); }
            if (PrinterdefN002.name().equals(name())) { return toClsList(CDef.PrinterdefN002.listAll()); }
            if (PrinterdefZ005.name().equals(name())) { return toClsList(CDef.PrinterdefZ005.listAll()); }
            if (Sortstockkbn.name().equals(name())) { return toClsList(CDef.Sortstockkbn.listAll()); }
            if (Tracetypedt.name().equals(name())) { return toClsList(CDef.Tracetypedt.listAll()); }
            if (Racklabelprflg.name().equals(name())) { return toClsList(CDef.Racklabelprflg.listAll()); }
            if (PrinterdefS0031.name().equals(name())) { return toClsList(CDef.PrinterdefS0031.listAll()); }
            if (PrinterdefS0032.name().equals(name())) { return toClsList(CDef.PrinterdefS0032.listAll()); }
            if (PrinterdefS0033.name().equals(name())) { return toClsList(CDef.PrinterdefS0033.listAll()); }
            if (PrinterdefS0034.name().equals(name())) { return toClsList(CDef.PrinterdefS0034.listAll()); }
            if (Unknowncaselimit.name().equals(name())) { return toClsList(CDef.Unknowncaselimit.listAll()); }
            if (Sortinvkbn.name().equals(name())) { return toClsList(CDef.Sortinvkbn.listAll()); }
            if (Cloudcasenum.name().equals(name())) { return toClsList(CDef.Cloudcasenum.listAll()); }
            if (Pulltype.name().equals(name())) { return toClsList(CDef.Pulltype.listAll()); }
            if (Storageloc.name().equals(name())) { return toClsList(CDef.Storageloc.listAll()); }
            if (Pallettracetype.name().equals(name())) { return toClsList(CDef.Pallettracetype.listAll()); }
            if (Datasendtype.name().equals(name())) { return toClsList(CDef.Datasendtype.listAll()); }
            if (Tracecreatests.name().equals(name())) { return toClsList(CDef.Tracecreatests.listAll()); }
            if (Sortinvtiming.name().equals(name())) { return toClsList(CDef.Sortinvtiming.listAll()); }
            if (Casesupplytype.name().equals(name())) { return toClsList(CDef.Casesupplytype.listAll()); }
            if (Importumu.name().equals(name())) { return toClsList(CDef.Importumu.listAll()); }
            if (Traceshiftflg.name().equals(name())) { return toClsList(CDef.Traceshiftflg.listAll()); }
            if (Shtypecd.name().equals(name())) { return toClsList(CDef.Shtypecd.listAll()); }
            if (Allocpolicy.name().equals(name())) { return toClsList(CDef.Allocpolicy.listAll()); }
            if (Rtncompanyname.name().equals(name())) { return toClsList(CDef.Rtncompanyname.listAll()); }
            if (Opendiff.name().equals(name())) { return toClsList(CDef.Opendiff.listAll()); }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return toClsList(CDef.ItemcdlookupAvailableflg.listAll()); }
            if (Flexpickprflg.name().equals(name())) { return toClsList(CDef.Flexpickprflg.listAll()); }
            if (WorkmasterExp.name().equals(name())) { return toClsList(CDef.WorkmasterExp.listAll()); }
            if (Tasktype.name().equals(name())) { return toClsList(CDef.Tasktype.listAll()); }
            if (Tasktypedetail.name().equals(name())) { return toClsList(CDef.Tasktypedetail.listAll()); }
            if (Yztraceshiftflg.name().equals(name())) { return toClsList(CDef.Yztraceshiftflg.listAll()); }
            if (Workercdsearchtype.name().equals(name())) { return toClsList(CDef.Workercdsearchtype.listAll()); }
            if (PrinterdefZ004.name().equals(name())) { return toClsList(CDef.PrinterdefZ004.listAll()); }
            if (PrinterdefZ008.name().equals(name())) { return toClsList(CDef.PrinterdefZ008.listAll()); }
            if (Pickdistname.name().equals(name())) { return toClsList(CDef.Pickdistname.listAll()); }
            if (Traceswitchflg.name().equals(name())) { return toClsList(CDef.Traceswitchflg.listAll()); }
            if (Lblkbn.name().equals(name())) { return toClsList(CDef.Lblkbn.listAll()); }
            if (Assortkbn.name().equals(name())) { return toClsList(CDef.Assortkbn.listAll()); }
            if (Dmycasecd.name().equals(name())) { return toClsList(CDef.Dmycasecd.listAll()); }
            if (Baditemdelkbn.name().equals(name())) { return toClsList(CDef.Baditemdelkbn.listAll()); }
            if (Selectlimit.name().equals(name())) { return toClsList(CDef.Selectlimit.listAll()); }
            if (PrinterdefW001.name().equals(name())) { return toClsList(CDef.PrinterdefW001.listAll()); }
            if (PrinterdefW002.name().equals(name())) { return toClsList(CDef.PrinterdefW002.listAll()); }
            if (Settlementinvmonth.name().equals(name())) { return toClsList(CDef.Settlementinvmonth.listAll()); }
            if (Flexinstructsts.name().equals(name())) { return toClsList(CDef.Flexinstructsts.listAll()); }
            if (Compulsionflg.name().equals(name())) { return toClsList(CDef.Compulsionflg.listAll()); }
            if (Displaymonth.name().equals(name())) { return toClsList(CDef.Displaymonth.listAll()); }
            if (Sufferusagesearchflg.name().equals(name())) { return toClsList(CDef.Sufferusagesearchflg.listAll()); }
            if (Fltstdinv.name().equals(name())) { return toClsList(CDef.Fltstdinv.listAll()); }
            if (Cs3switchflg.name().equals(name())) { return toClsList(CDef.Cs3switchflg.listAll()); }
            if (Inadequacyarea.name().equals(name())) { return toClsList(CDef.Inadequacyarea.listAll()); }
            if (Transmitflg.name().equals(name())) { return toClsList(CDef.Transmitflg.listAll()); }
            if (Flalterflg.name().equals(name())) { return toClsList(CDef.Flalterflg.listAll()); }
            if (Invsts.name().equals(name())) { return toClsList(CDef.Invsts.listAll()); }
            if (Concurrentbase.name().equals(name())) { return toClsList(CDef.Concurrentbase.listAll()); }
            if (Concurrentname.name().equals(name())) { return toClsList(CDef.Concurrentname.listAll()); }
            if (Caseshipstatus.name().equals(name())) { return toClsList(CDef.Caseshipstatus.listAll()); }
            if (Ngpitemcd.name().equals(name())) { return toClsList(CDef.Ngpitemcd.listAll()); }
            if (Fzloccd.name().equals(name())) { return toClsList(CDef.Fzloccd.listAll()); }
            if (Whsortinvkbn.name().equals(name())) { return toClsList(CDef.Whsortinvkbn.listAll()); }
            if (Syncreportform.name().equals(name())) { return toClsList(CDef.Syncreportform.listAll()); }
            if (Sortwarehousecd.name().equals(name())) { return toClsList(CDef.Sortwarehousecd.listAll()); }
            if (Hozeiwarehousecd.name().equals(name())) { return toClsList(CDef.Hozeiwarehousecd.listAll()); }
            if (PrinterdefH002.name().equals(name())) { return toClsList(CDef.PrinterdefH002.listAll()); }
            if (Reportformname.name().equals(name())) { return toClsList(CDef.Reportformname.listAll()); }
            if (Taskname.name().equals(name())) { return toClsList(CDef.Taskname.listAll()); }
            if (Whinvkbn.name().equals(name())) { return toClsList(CDef.Whinvkbn.listAll()); }
            if (Procflg.name().equals(name())) { return toClsList(CDef.Procflg.listAll()); }
            if (SyhnKbn.name().equals(name())) { return toClsList(CDef.SyhnKbn.listAll()); }
            if (Pallettype.name().equals(name())) { return toClsList(CDef.Pallettype.listAll()); }
            if (InventoryInstKbn.name().equals(name())) { return toClsList(CDef.InventoryInstKbn.listAll()); }
            if (InventoryReport.name().equals(name())) { return toClsList(CDef.InventoryReport.listAll()); }
            if (Completeflg.name().equals(name())) { return toClsList(CDef.Completeflg.listAll()); }
            if (Oneitemonlyflg.name().equals(name())) { return toClsList(CDef.Oneitemonlyflg.listAll()); }
            if (Oneowneronlyflg.name().equals(name())) { return toClsList(CDef.Oneowneronlyflg.listAll()); }
            if (Picktype.name().equals(name())) { return toClsList(CDef.Picktype.listAll()); }
            if (Rcvtype.name().equals(name())) { return toClsList(CDef.Rcvtype.listAll()); }
            if (Slottype.name().equals(name())) { return toClsList(CDef.Slottype.listAll()); }
            if (Capselect.name().equals(name())) { return toClsList(CDef.Capselect.listAll()); }
            if (Kashikokuzeikubn.name().equals(name())) { return toClsList(CDef.Kashikokuzeikubn.listAll()); }
            if (Instructflg.name().equals(name())) { return toClsList(CDef.Instructflg.listAll()); }
            if (Palleteoutputtype.name().equals(name())) { return toClsList(CDef.Palleteoutputtype.listAll()); }
            if (Palletecuttingkbn.name().equals(name())) { return toClsList(CDef.Palletecuttingkbn.listAll()); }
            if (Frontrackcd.name().equals(name())) { return toClsList(CDef.Frontrackcd.listAll()); }
            if (Sufferflg.name().equals(name())) { return toClsList(CDef.Sufferflg.listAll()); }
            if (Unmatchflg.name().equals(name())) { return toClsList(CDef.Unmatchflg.listAll()); }
            if (Alcimrsnflg.name().equals(name())) { return toClsList(CDef.Alcimrsnflg.listAll()); }
            if (Manyfewoccurarea.name().equals(name())) { return toClsList(CDef.Manyfewoccurarea.listAll()); }
            if (Manyfewoccurareadisp.name().equals(name())) { return toClsList(CDef.Manyfewoccurareadisp.listAll()); }
            if (Designchg.name().equals(name())) { return toClsList(CDef.Designchg.listAll()); }
            if (Differenceumu.name().equals(name())) { return toClsList(CDef.Differenceumu.listAll()); }
            if (Stockdistinction.name().equals(name())) { return toClsList(CDef.Stockdistinction.listAll()); }
            if (Workmaster.name().equals(name())) { return toClsList(CDef.Workmaster.listAll()); }
            if (Picklisttype.name().equals(name())) { return toClsList(CDef.Picklisttype.listAll()); }
            if (Sortzaikbn.name().equals(name())) { return toClsList(CDef.Sortzaikbn.listAll()); }
            if (Sorttype.name().equals(name())) { return toClsList(CDef.Sorttype.listAll()); }
            if (Exchgmethod.name().equals(name())) { return toClsList(CDef.Exchgmethod.listAll()); }
            if (Conditionflg.name().equals(name())) { return toClsList(CDef.Conditionflg.listAll()); }
            if (Qtyadjustflg.name().equals(name())) { return toClsList(CDef.Qtyadjustflg.listAll()); }
            if (Inoutcode.name().equals(name())) { return toClsList(CDef.Inoutcode.listAll()); }
            if (Inventorytype.name().equals(name())) { return toClsList(CDef.Inventorytype.listAll()); }
            if (Attensionflg.name().equals(name())) { return toClsList(CDef.Attensionflg.listAll()); }
            if (Formdiffflg.name().equals(name())) { return toClsList(CDef.Formdiffflg.listAll()); }
            if (Timingtype.name().equals(name())) { return toClsList(CDef.Timingtype.listAll()); }
            if (Fcflg.name().equals(name())) { return toClsList(CDef.Fcflg.listAll()); }
            if (SundayFlg.name().equals(name())) { return toClsList(CDef.SundayFlg.listAll()); }
            if (Pluralproductionkbn.name().equals(name())) { return toClsList(CDef.Pluralproductionkbn.listAll()); }
            if (Changeflg.name().equals(name())) { return toClsList(CDef.Changeflg.listAll()); }
            if (Rtnstatus.name().equals(name())) { return toClsList(CDef.Rtnstatus.listAll()); }
            if (Rtninspestatus.name().equals(name())) { return toClsList(CDef.Rtninspestatus.listAll()); }
            if (Inventoryref.name().equals(name())) { return toClsList(CDef.Inventoryref.listAll()); }
            if (Restockflg.name().equals(name())) { return toClsList(CDef.Restockflg.listAll()); }
            if (Validtype.name().equals(name())) { return toClsList(CDef.Validtype.listAll()); }
            if (Rtnchangedivision.name().equals(name())) { return toClsList(CDef.Rtnchangedivision.listAll()); }
            if (Storagearea.name().equals(name())) { return toClsList(CDef.Storagearea.listAll()); }
            if (Maxinvflg.name().equals(name())) { return toClsList(CDef.Maxinvflg.listAll()); }
            if (Horyukbn.name().equals(name())) { return toClsList(CDef.Horyukbn.listAll()); }
            if (Useflg.name().equals(name())) { return toClsList(CDef.Useflg.listAll()); }
            if (Fckokuflg.name().equals(name())) { return toClsList(CDef.Fckokuflg.listAll()); }
            if (Bowltypeflg.name().equals(name())) { return toClsList(CDef.Bowltypeflg.listAll()); }
            if (Inventoryrefdisp.name().equals(name())) { return toClsList(CDef.Inventoryrefdisp.listAll()); }
            if (Flinstrstatus.name().equals(name())) { return toClsList(CDef.Flinstrstatus.listAll()); }
            if (Flexstatus.name().equals(name())) { return toClsList(CDef.Flexstatus.listAll()); }
            if (Distributioncd.name().equals(name())) { return toClsList(CDef.Distributioncd.listAll()); }
            if (Stocklocation.name().equals(name())) { return toClsList(CDef.Stocklocation.listAll()); }
            if (ResultStatus.name().equals(name())) { return toClsList(CDef.ResultStatus.listAll()); }
            if (BoxCategory.name().equals(name())) { return toClsList(CDef.BoxCategory.listAll()); }
            if (Storagewarehousecd.name().equals(name())) { return toClsList(CDef.Storagewarehousecd.listAll()); }
            if (Salestype.name().equals(name())) { return toClsList(CDef.Salestype.listAll()); }
            if (Solistkbn2.name().equals(name())) { return toClsList(CDef.Solistkbn2.listAll()); }
            if (PickingListType.name().equals(name())) { return toClsList(CDef.PickingListType.listAll()); }
            if (CoveredClass.name().equals(name())) { return toClsList(CDef.CoveredClass.listAll()); }
            if (NotCoveredClass.name().equals(name())) { return toClsList(CDef.NotCoveredClass.listAll()); }
            if (PickingWorkStatus.name().equals(name())) { return toClsList(CDef.PickingWorkStatus.listAll()); }
            if (ReprintedFlg.name().equals(name())) { return toClsList(CDef.ReprintedFlg.listAll()); }
            if (Cggdid.name().equals(name())) { return toClsList(CDef.Cggdid.listAll()); }
            if (RcvPlanSts.name().equals(name())) { return toClsList(CDef.RcvPlanSts.listAll()); }
            if (Virtuallocflg.name().equals(name())) { return toClsList(CDef.Virtuallocflg.listAll()); }
            if (SufferUsageFlg.name().equals(name())) { return toClsList(CDef.SufferUsageFlg.listAll()); }
            if (Thedaysortingcompleteflg.name().equals(name())) { return toClsList(CDef.Thedaysortingcompleteflg.listAll()); }
            if (Gooditemkbn.name().equals(name())) { return toClsList(CDef.Gooditemkbn.listAll()); }
            if (Slptyp.name().equals(name())) { return toClsList(CDef.Slptyp.listAll()); }
            if (SostatusForserch2.name().equals(name())) { return toClsList(CDef.SostatusForserch2.listAll()); }
            if (LineOrderKbn.name().equals(name())) { return toClsList(CDef.LineOrderKbn.listAll()); }
            if (Consolidationflg.name().equals(name())) { return toClsList(CDef.Consolidationflg.listAll()); }
            if (DaysOfWeek.name().equals(name())) { return toClsList(CDef.DaysOfWeek.listAll()); }
            if (Lockbn.name().equals(name())) { return toClsList(CDef.Lockbn.listAll()); }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return toClsList(CDef.ReplenishmentRoundedupUnit.listAll()); }
            if (Restockkbn.name().equals(name())) { return toClsList(CDef.Restockkbn.listAll()); }
            if (Zaikodiv.name().equals(name())) { return toClsList(CDef.Zaikodiv.listAll()); }
            if (Openflg.name().equals(name())) { return toClsList(CDef.Openflg.listAll()); }
            if (TodayPrintOnlyFlg.name().equals(name())) { return toClsList(CDef.TodayPrintOnlyFlg.listAll()); }
            if (StartEnd.name().equals(name())) { return toClsList(CDef.StartEnd.listAll()); }
            if (SyhnKbnJt.name().equals(name())) { return toClsList(CDef.SyhnKbnJt.listAll()); }
            if (Transkbn.name().equals(name())) { return toClsList(CDef.Transkbn.listAll()); }
            if (Carknd.name().equals(name())) { return toClsList(CDef.Carknd.listAll()); }
            if (Cartypecmb0tdisp.name().equals(name())) { return toClsList(CDef.Cartypecmb0tdisp.listAll()); }
            if (CenterPicListCls1.name().equals(name())) { return toClsList(CDef.CenterPicListCls1.listAll()); }
            if (CenterPicListCls2.name().equals(name())) { return toClsList(CDef.CenterPicListCls2.listAll()); }
            if (CenterPicListCls3.name().equals(name())) { return toClsList(CDef.CenterPicListCls3.listAll()); }
            if (CenterSagawaDelivTz.name().equals(name())) { return toClsList(CDef.CenterSagawaDelivTz.listAll()); }
            if (CenterTransportTypeItem.name().equals(name())) { return toClsList(CDef.CenterTransportTypeItem.listAll()); }
            if (CenterSlipShapeCd.name().equals(name())) { return toClsList(CDef.CenterSlipShapeCd.listAll()); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return toClsList(CDef.CenterTransportTypeSpeed.listAll()); }
            if (CenterSealType.name().equals(name())) { return toClsList(CDef.CenterSealType.listAll()); }
            if (CenterTagClass.name().equals(name())) { return toClsList(CDef.CenterTagClass.listAll()); }
            if (CenterTagDataType.name().equals(name())) { return toClsList(CDef.CenterTagDataType.listAll()); }
            if (CenterTagType.name().equals(name())) { return toClsList(CDef.CenterTagType.listAll()); }
            if (CenterTagTypeAfter.name().equals(name())) { return toClsList(CDef.CenterTagTypeAfter.listAll()); }
            if (CenterApiBinsyuCode.name().equals(name())) { return toClsList(CDef.CenterApiBinsyuCode.listAll()); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiFlg.listAll()); }
            if (CenterApiDaibikiType.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiType.listAll()); }
            if (CenterApiEidomeFlg.name().equals(name())) { return toClsList(CDef.CenterApiEidomeFlg.listAll()); }
            if (CenterApiWeightCd.name().equals(name())) { return toClsList(CDef.CenterApiWeightCd.listAll()); }
            if (CenterOutputTargetFlg.name().equals(name())) { return toClsList(CDef.CenterOutputTargetFlg.listAll()); }
            if (CenterPrintCondition.name().equals(name())) { return toClsList(CDef.CenterPrintCondition.listAll()); }
            if (CenterDesignflg.name().equals(name())) { return toClsList(CDef.CenterDesignflg.listAll()); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public List<Classification> listByGroup(String groupName) { // exception if not found
            if (ProcessTypeCd.name().equals(name())) { return toClsList(CDef.ProcessTypeCd.listByGroup(groupName)); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return toClsList(CDef.AfterDelivSlipOutTgt.listByGroup(groupName)); }
            if (AfterTagOutFlg.name().equals(name())) { return toClsList(CDef.AfterTagOutFlg.listByGroup(groupName)); }
            if (AllcNgDisplay.name().equals(name())) { return toClsList(CDef.AllcNgDisplay.listByGroup(groupName)); }
            if (AllcNgFlg.name().equals(name())) { return toClsList(CDef.AllcNgFlg.listByGroup(groupName)); }
            if (AllocSortKey.name().equals(name())) { return toClsList(CDef.AllocSortKey.listByGroup(groupName)); }
            if (AllShippingFlg.name().equals(name())) { return toClsList(CDef.AllShippingFlg.listByGroup(groupName)); }
            if (ArrivalStoreFormat.name().equals(name())) { return toClsList(CDef.ArrivalStoreFormat.listByGroup(groupName)); }
            if (AutoEmgSetFlg.name().equals(name())) { return toClsList(CDef.AutoEmgSetFlg.listByGroup(groupName)); }
            if (AutoEmgSetTgt.name().equals(name())) { return toClsList(CDef.AutoEmgSetTgt.listByGroup(groupName)); }
            if (AutoPrintTargetFlg.name().equals(name())) { return toClsList(CDef.AutoPrintTargetFlg.listByGroup(groupName)); }
            if (AutoShipInstFlg.name().equals(name())) { return toClsList(CDef.AutoShipInstFlg.listByGroup(groupName)); }
            if (BarcodeType.name().equals(name())) { return toClsList(CDef.BarcodeType.listByGroup(groupName)); }
            if (BatchProgressFlg.name().equals(name())) { return toClsList(CDef.BatchProgressFlg.listByGroup(groupName)); }
            if (BoxSelectSkip.name().equals(name())) { return toClsList(CDef.BoxSelectSkip.listByGroup(groupName)); }
            if (CancelDataDisplay.name().equals(name())) { return toClsList(CDef.CancelDataDisplay.listByGroup(groupName)); }
            if (CasePicFlg.name().equals(name())) { return toClsList(CDef.CasePicFlg.listByGroup(groupName)); }
            if (CenterClientCls.name().equals(name())) { return toClsList(CDef.CenterClientCls.listByGroup(groupName)); }
            if (CenterTransitFlg.name().equals(name())) { return toClsList(CDef.CenterTransitFlg.listByGroup(groupName)); }
            if (CharacterCd.name().equals(name())) { return toClsList(CDef.CharacterCd.listByGroup(groupName)); }
            if (ChargeQty0Display.name().equals(name())) { return toClsList(CDef.ChargeQty0Display.listByGroup(groupName)); }
            if (CheckDigit.name().equals(name())) { return toClsList(CDef.CheckDigit.listByGroup(groupName)); }
            if (CodeFlg.name().equals(name())) { return toClsList(CDef.CodeFlg.listByGroup(groupName)); }
            if (CodeType.name().equals(name())) { return toClsList(CDef.CodeType.listByGroup(groupName)); }
            if (CodCls.name().equals(name())) { return toClsList(CDef.CodCls.listByGroup(groupName)); }
            if (CodType.name().equals(name())) { return toClsList(CDef.CodType.listByGroup(groupName)); }
            if (ColType.name().equals(name())) { return toClsList(CDef.ColType.listByGroup(groupName)); }
            if (CommentFlg.name().equals(name())) { return toClsList(CDef.CommentFlg.listByGroup(groupName)); }
            if (CompanyFlg.name().equals(name())) { return toClsList(CDef.CompanyFlg.listByGroup(groupName)); }
            if (CoolCls.name().equals(name())) { return toClsList(CDef.CoolCls.listByGroup(groupName)); }
            if (CoolType.name().equals(name())) { return toClsList(CDef.CoolType.listByGroup(groupName)); }
            if (CopyTargetTable.name().equals(name())) { return toClsList(CDef.CopyTargetTable.listByGroup(groupName)); }
            if (CorrectType.name().equals(name())) { return toClsList(CDef.CorrectType.listByGroup(groupName)); }
            if (DataInputCommitType.name().equals(name())) { return toClsList(CDef.DataInputCommitType.listByGroup(groupName)); }
            if (DataInputOperationType.name().equals(name())) { return toClsList(CDef.DataInputOperationType.listByGroup(groupName)); }
            if (DataInputProcessType.name().equals(name())) { return toClsList(CDef.DataInputProcessType.listByGroup(groupName)); }
            if (DataInputRange.name().equals(name())) { return toClsList(CDef.DataInputRange.listByGroup(groupName)); }
            if (DataInputType.name().equals(name())) { return toClsList(CDef.DataInputType.listByGroup(groupName)); }
            if (DataType.name().equals(name())) { return toClsList(CDef.DataType.listByGroup(groupName)); }
            if (Default.name().equals(name())) { return toClsList(CDef.Default.listByGroup(groupName)); }
            if (DefaultFlg.name().equals(name())) { return toClsList(CDef.DefaultFlg.listByGroup(groupName)); }
            if (DeleteDataDisplay.name().equals(name())) { return toClsList(CDef.DeleteDataDisplay.listByGroup(groupName)); }
            if (DeliveryFlg.name().equals(name())) { return toClsList(CDef.DeliveryFlg.listByGroup(groupName)); }
            if (DelivMatchFlg.name().equals(name())) { return toClsList(CDef.DelivMatchFlg.listByGroup(groupName)); }
            if (DelivTz.name().equals(name())) { return toClsList(CDef.DelivTz.listByGroup(groupName)); }
            if (DelFlg.name().equals(name())) { return toClsList(CDef.DelFlg.listByGroup(groupName)); }
            if (DepositFlg.name().equals(name())) { return toClsList(CDef.DepositFlg.listByGroup(groupName)); }
            if (DisplayRequired.name().equals(name())) { return toClsList(CDef.DisplayRequired.listByGroup(groupName)); }
            if (DtCls.name().equals(name())) { return toClsList(CDef.DtCls.listByGroup(groupName)); }
            if (Editable.name().equals(name())) { return toClsList(CDef.Editable.listByGroup(groupName)); }
            if (EmergencyDisplay.name().equals(name())) { return toClsList(CDef.EmergencyDisplay.listByGroup(groupName)); }
            if (EmergencyFlg.name().equals(name())) { return toClsList(CDef.EmergencyFlg.listByGroup(groupName)); }
            if (ErrorFlg.name().equals(name())) { return toClsList(CDef.ErrorFlg.listByGroup(groupName)); }
            if (ErrorProcessMet.name().equals(name())) { return toClsList(CDef.ErrorProcessMet.listByGroup(groupName)); }
            if (FixedPoint.name().equals(name())) { return toClsList(CDef.FixedPoint.listByGroup(groupName)); }
            if (ForceFixedFlg.name().equals(name())) { return toClsList(CDef.ForceFixedFlg.listByGroup(groupName)); }
            if (ForeignFlg.name().equals(name())) { return toClsList(CDef.ForeignFlg.listByGroup(groupName)); }
            if (GiftFlg.name().equals(name())) { return toClsList(CDef.GiftFlg.listByGroup(groupName)); }
            if (GiftStatementType.name().equals(name())) { return toClsList(CDef.GiftStatementType.listByGroup(groupName)); }
            if (HtCharReadFlg.name().equals(name())) { return toClsList(CDef.HtCharReadFlg.listByGroup(groupName)); }
            if (ImportFlg.name().equals(name())) { return toClsList(CDef.ImportFlg.listByGroup(groupName)); }
            if (InfoFlg.name().equals(name())) { return toClsList(CDef.InfoFlg.listByGroup(groupName)); }
            if (InoutType.name().equals(name())) { return toClsList(CDef.InoutType.listByGroup(groupName)); }
            if (InputType.name().equals(name())) { return toClsList(CDef.InputType.listByGroup(groupName)); }
            if (InspectionFlg.name().equals(name())) { return toClsList(CDef.InspectionFlg.listByGroup(groupName)); }
            if (InventoryLocationProduct.name().equals(name())) { return toClsList(CDef.InventoryLocationProduct.listByGroup(groupName)); }
            if (InvoiceCreateFlg.name().equals(name())) { return toClsList(CDef.InvoiceCreateFlg.listByGroup(groupName)); }
            if (ItemType.name().equals(name())) { return toClsList(CDef.ItemType.listByGroup(groupName)); }
            if (LastFlg.name().equals(name())) { return toClsList(CDef.LastFlg.listByGroup(groupName)); }
            if (LimitDtManagFlg.name().equals(name())) { return toClsList(CDef.LimitDtManagFlg.listByGroup(groupName)); }
            if (LimitDtReverseFlg.name().equals(name())) { return toClsList(CDef.LimitDtReverseFlg.listByGroup(groupName)); }
            if (LimitMessageCd.name().equals(name())) { return toClsList(CDef.LimitMessageCd.listByGroup(groupName)); }
            if (LineFeedCd.name().equals(name())) { return toClsList(CDef.LineFeedCd.listByGroup(groupName)); }
            if (ListOutFlg.name().equals(name())) { return toClsList(CDef.ListOutFlg.listByGroup(groupName)); }
            if (ListOutFlgDisp.name().equals(name())) { return toClsList(CDef.ListOutFlgDisp.listByGroup(groupName)); }
            if (ListOutKbn.name().equals(name())) { return toClsList(CDef.ListOutKbn.listByGroup(groupName)); }
            if (LoadingFlg.name().equals(name())) { return toClsList(CDef.LoadingFlg.listByGroup(groupName)); }
            if (LocationType.name().equals(name())) { return toClsList(CDef.LocationType.listByGroup(groupName)); }
            if (Lockout.name().equals(name())) { return toClsList(CDef.Lockout.listByGroup(groupName)); }
            if (LogDtlStatus.name().equals(name())) { return toClsList(CDef.LogDtlStatus.listByGroup(groupName)); }
            if (LogDtlType.name().equals(name())) { return toClsList(CDef.LogDtlType.listByGroup(groupName)); }
            if (LogStatus.name().equals(name())) { return toClsList(CDef.LogStatus.listByGroup(groupName)); }
            if (LotManagFlg.name().equals(name())) { return toClsList(CDef.LotManagFlg.listByGroup(groupName)); }
            if (LotReverseFlg.name().equals(name())) { return toClsList(CDef.LotReverseFlg.listByGroup(groupName)); }
            if (MergeCls.name().equals(name())) { return toClsList(CDef.MergeCls.listByGroup(groupName)); }
            if (MergeFlg.name().equals(name())) { return toClsList(CDef.MergeFlg.listByGroup(groupName)); }
            if (MessageType.name().equals(name())) { return toClsList(CDef.MessageType.listByGroup(groupName)); }
            if (MixedFlg.name().equals(name())) { return toClsList(CDef.MixedFlg.listByGroup(groupName)); }
            if (MoveInstStatus.name().equals(name())) { return toClsList(CDef.MoveInstStatus.listByGroup(groupName)); }
            if (MultiPicCls.name().equals(name())) { return toClsList(CDef.MultiPicCls.listByGroup(groupName)); }
            if (MultiPicFlg.name().equals(name())) { return toClsList(CDef.MultiPicFlg.listByGroup(groupName)); }
            if (Necessary.name().equals(name())) { return toClsList(CDef.Necessary.listByGroup(groupName)); }
            if (NotCompletedFlg.name().equals(name())) { return toClsList(CDef.NotCompletedFlg.listByGroup(groupName)); }
            if (NoAllcDisplayFlg.name().equals(name())) { return toClsList(CDef.NoAllcDisplayFlg.listByGroup(groupName)); }
            if (NoConfirmedFlg.name().equals(name())) { return toClsList(CDef.NoConfirmedFlg.listByGroup(groupName)); }
            if (NoStockCls.name().equals(name())) { return toClsList(CDef.NoStockCls.listByGroup(groupName)); }
            if (NoStockOutFlg.name().equals(name())) { return toClsList(CDef.NoStockOutFlg.listByGroup(groupName)); }
            if (NoUpsideDownCls.name().equals(name())) { return toClsList(CDef.NoUpsideDownCls.listByGroup(groupName)); }
            if (OnetimeFlg.name().equals(name())) { return toClsList(CDef.OnetimeFlg.listByGroup(groupName)); }
            if (OverStoreNumFlg.name().equals(name())) { return toClsList(CDef.OverStoreNumFlg.listByGroup(groupName)); }
            if (PackingCalCls.name().equals(name())) { return toClsList(CDef.PackingCalCls.listByGroup(groupName)); }
            if (PackingProcessCls.name().equals(name())) { return toClsList(CDef.PackingProcessCls.listByGroup(groupName)); }
            if (PackingShowFlg.name().equals(name())) { return toClsList(CDef.PackingShowFlg.listByGroup(groupName)); }
            if (PackingStatus.name().equals(name())) { return toClsList(CDef.PackingStatus.listByGroup(groupName)); }
            if (PasswordReset.name().equals(name())) { return toClsList(CDef.PasswordReset.listByGroup(groupName)); }
            if (PastStoreDtFlg.name().equals(name())) { return toClsList(CDef.PastStoreDtFlg.listByGroup(groupName)); }
            if (PhysicalDelete.name().equals(name())) { return toClsList(CDef.PhysicalDelete.listByGroup(groupName)); }
            if (PickingFlg.name().equals(name())) { return toClsList(CDef.PickingFlg.listByGroup(groupName)); }
            if (PickingLocationFlg.name().equals(name())) { return toClsList(CDef.PickingLocationFlg.listByGroup(groupName)); }
            if (PickingStatus.name().equals(name())) { return toClsList(CDef.PickingStatus.listByGroup(groupName)); }
            if (PicCls.name().equals(name())) { return toClsList(CDef.PicCls.listByGroup(groupName)); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return toClsList(CDef.PicMthdRcmdBreakKey.listByGroup(groupName)); }
            if (PicMthdRcmdFlg.name().equals(name())) { return toClsList(CDef.PicMthdRcmdFlg.listByGroup(groupName)); }
            if (PicMthdRcmdListOut.name().equals(name())) { return toClsList(CDef.PicMthdRcmdListOut.listByGroup(groupName)); }
            if (PostType.name().equals(name())) { return toClsList(CDef.PostType.listByGroup(groupName)); }
            if (PrintedFlg.name().equals(name())) { return toClsList(CDef.PrintedFlg.listByGroup(groupName)); }
            if (PrintDataType.name().equals(name())) { return toClsList(CDef.PrintDataType.listByGroup(groupName)); }
            if (PrintErrorFlg.name().equals(name())) { return toClsList(CDef.PrintErrorFlg.listByGroup(groupName)); }
            if (PrintQueueStatus.name().equals(name())) { return toClsList(CDef.PrintQueueStatus.listByGroup(groupName)); }
            if (PrintResultClass.name().equals(name())) { return toClsList(CDef.PrintResultClass.listByGroup(groupName)); }
            if (PrintServiceStatus.name().equals(name())) { return toClsList(CDef.PrintServiceStatus.listByGroup(groupName)); }
            if (PrintStatus.name().equals(name())) { return toClsList(CDef.PrintStatus.listByGroup(groupName)); }
            if (PriorityFlg.name().equals(name())) { return toClsList(CDef.PriorityFlg.listByGroup(groupName)); }
            if (ProductLabelJanBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelJanBarcode.listByGroup(groupName)); }
            if (ProductLabelOutUnit.name().equals(name())) { return toClsList(CDef.ProductLabelOutUnit.listByGroup(groupName)); }
            if (ProductLabelProdBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelProdBarcode.listByGroup(groupName)); }
            if (ProductPartPacking.name().equals(name())) { return toClsList(CDef.ProductPartPacking.listByGroup(groupName)); }
            if (ProductTypeCode.name().equals(name())) { return toClsList(CDef.ProductTypeCode.listByGroup(groupName)); }
            if (Qty0Display.name().equals(name())) { return toClsList(CDef.Qty0Display.listByGroup(groupName)); }
            if (ReasonType.name().equals(name())) { return toClsList(CDef.ReasonType.listByGroup(groupName)); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return toClsList(CDef.ReceiveDeliveryStatus.listByGroup(groupName)); }
            if (ReceiveFlg.name().equals(name())) { return toClsList(CDef.ReceiveFlg.listByGroup(groupName)); }
            if (ReceiveStatus.name().equals(name())) { return toClsList(CDef.ReceiveStatus.listByGroup(groupName)); }
            if (ReplenishAllocCls.name().equals(name())) { return toClsList(CDef.ReplenishAllocCls.listByGroup(groupName)); }
            if (ReplenishProductCdUnset.name().equals(name())) { return toClsList(CDef.ReplenishProductCdUnset.listByGroup(groupName)); }
            if (ReplenishSearchCls.name().equals(name())) { return toClsList(CDef.ReplenishSearchCls.listByGroup(groupName)); }
            if (ReplenishUnitCls.name().equals(name())) { return toClsList(CDef.ReplenishUnitCls.listByGroup(groupName)); }
            if (ReportLayoutItemType.name().equals(name())) { return toClsList(CDef.ReportLayoutItemType.listByGroup(groupName)); }
            if (RestockType.name().equals(name())) { return toClsList(CDef.RestockType.listByGroup(groupName)); }
            if (ResultAfterProductLabel.name().equals(name())) { return toClsList(CDef.ResultAfterProductLabel.listByGroup(groupName)); }
            if (ResultAfterProductTarget.name().equals(name())) { return toClsList(CDef.ResultAfterProductTarget.listByGroup(groupName)); }
            if (ReverseValidFlg.name().equals(name())) { return toClsList(CDef.ReverseValidFlg.listByGroup(groupName)); }
            if (RoleControlClass.name().equals(name())) { return toClsList(CDef.RoleControlClass.listByGroup(groupName)); }
            if (Select.name().equals(name())) { return toClsList(CDef.Select.listByGroup(groupName)); }
            if (SelectPrintServiceStatus.name().equals(name())) { return toClsList(CDef.SelectPrintServiceStatus.listByGroup(groupName)); }
            if (SerialOperationType.name().equals(name())) { return toClsList(CDef.SerialOperationType.listByGroup(groupName)); }
            if (SettlementType.name().equals(name())) { return toClsList(CDef.SettlementType.listByGroup(groupName)); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return toClsList(CDef.SglRowInspAfterOutCls.listByGroup(groupName)); }
            if (SglRowPicFlg.name().equals(name())) { return toClsList(CDef.SglRowPicFlg.listByGroup(groupName)); }
            if (SheetCollate.name().equals(name())) { return toClsList(CDef.SheetCollate.listByGroup(groupName)); }
            if (ShippingFlg.name().equals(name())) { return toClsList(CDef.ShippingFlg.listByGroup(groupName)); }
            if (ShippingStatus.name().equals(name())) { return toClsList(CDef.ShippingStatus.listByGroup(groupName)); }
            if (ShippingStopFlg.name().equals(name())) { return toClsList(CDef.ShippingStopFlg.listByGroup(groupName)); }
            if (ShortStockDisplay.name().equals(name())) { return toClsList(CDef.ShortStockDisplay.listByGroup(groupName)); }
            if (ShpCheckCls.name().equals(name())) { return toClsList(CDef.ShpCheckCls.listByGroup(groupName)); }
            if (ShpCheckDisplay.name().equals(name())) { return toClsList(CDef.ShpCheckDisplay.listByGroup(groupName)); }
            if (SlipType.name().equals(name())) { return toClsList(CDef.SlipType.listByGroup(groupName)); }
            if (SoundPlayFlg.name().equals(name())) { return toClsList(CDef.SoundPlayFlg.listByGroup(groupName)); }
            if (StockAdjustFlg.name().equals(name())) { return toClsList(CDef.StockAdjustFlg.listByGroup(groupName)); }
            if (StockDisplayFld.name().equals(name())) { return toClsList(CDef.StockDisplayFld.listByGroup(groupName)); }
            if (StockExistOnlyFlg.name().equals(name())) { return toClsList(CDef.StockExistOnlyFlg.listByGroup(groupName)); }
            if (StockMoveFlg.name().equals(name())) { return toClsList(CDef.StockMoveFlg.listByGroup(groupName)); }
            if (StockNum0Display.name().equals(name())) { return toClsList(CDef.StockNum0Display.listByGroup(groupName)); }
            if (StockOutAllocCls.name().equals(name())) { return toClsList(CDef.StockOutAllocCls.listByGroup(groupName)); }
            if (StockOutAutoInstFlg.name().equals(name())) { return toClsList(CDef.StockOutAutoInstFlg.listByGroup(groupName)); }
            if (StockOutFlg.name().equals(name())) { return toClsList(CDef.StockOutFlg.listByGroup(groupName)); }
            if (StockOutInstCxlFlg.name().equals(name())) { return toClsList(CDef.StockOutInstCxlFlg.listByGroup(groupName)); }
            if (StockOutInstSplitFlg.name().equals(name())) { return toClsList(CDef.StockOutInstSplitFlg.listByGroup(groupName)); }
            if (StockQtyDisplay.name().equals(name())) { return toClsList(CDef.StockQtyDisplay.listByGroup(groupName)); }
            if (StockTakingInput.name().equals(name())) { return toClsList(CDef.StockTakingInput.listByGroup(groupName)); }
            if (StockTarget.name().equals(name())) { return toClsList(CDef.StockTarget.listByGroup(groupName)); }
            if (StoreDtFlg.name().equals(name())) { return toClsList(CDef.StoreDtFlg.listByGroup(groupName)); }
            if (StoreFlg.name().equals(name())) { return toClsList(CDef.StoreFlg.listByGroup(groupName)); }
            if (StoreNoDivideDisplay.name().equals(name())) { return toClsList(CDef.StoreNoDivideDisplay.listByGroup(groupName)); }
            if (StoreNoFlg.name().equals(name())) { return toClsList(CDef.StoreNoFlg.listByGroup(groupName)); }
            if (StoreNoMergeFlg.name().equals(name())) { return toClsList(CDef.StoreNoMergeFlg.listByGroup(groupName)); }
            if (SystemLogStatus.name().equals(name())) { return toClsList(CDef.SystemLogStatus.listByGroup(groupName)); }
            if (SystemLogType.name().equals(name())) { return toClsList(CDef.SystemLogType.listByGroup(groupName)); }
            if (SystemType.name().equals(name())) { return toClsList(CDef.SystemType.listByGroup(groupName)); }
            if (TagDeliveryOutFlg.name().equals(name())) { return toClsList(CDef.TagDeliveryOutFlg.listByGroup(groupName)); }
            if (TakingShippingDtFlg.name().equals(name())) { return toClsList(CDef.TakingShippingDtFlg.listByGroup(groupName)); }
            if (TakingShippingFlg.name().equals(name())) { return toClsList(CDef.TakingShippingFlg.listByGroup(groupName)); }
            if (TargetWindow.name().equals(name())) { return toClsList(CDef.TargetWindow.listByGroup(groupName)); }
            if (TextAlign.name().equals(name())) { return toClsList(CDef.TextAlign.listByGroup(groupName)); }
            if (TotalPicFlg.name().equals(name())) { return toClsList(CDef.TotalPicFlg.listByGroup(groupName)); }
            if (TrackingNumberingUnit.name().equals(name())) { return toClsList(CDef.TrackingNumberingUnit.listByGroup(groupName)); }
            if (TransitDisplay.name().equals(name())) { return toClsList(CDef.TransitDisplay.listByGroup(groupName)); }
            if (Unmatch.name().equals(name())) { return toClsList(CDef.Unmatch.listByGroup(groupName)); }
            if (Updatable.name().equals(name())) { return toClsList(CDef.Updatable.listByGroup(groupName)); }
            if (UpdCd.name().equals(name())) { return toClsList(CDef.UpdCd.listByGroup(groupName)); }
            if (UpdType.name().equals(name())) { return toClsList(CDef.UpdType.listByGroup(groupName)); }
            if (UploadTableNm.name().equals(name())) { return toClsList(CDef.UploadTableNm.listByGroup(groupName)); }
            if (UserEditable.name().equals(name())) { return toClsList(CDef.UserEditable.listByGroup(groupName)); }
            if (UseHtShipFlg.name().equals(name())) { return toClsList(CDef.UseHtShipFlg.listByGroup(groupName)); }
            if (VendorFlg.name().equals(name())) { return toClsList(CDef.VendorFlg.listByGroup(groupName)); }
            if (Visible.name().equals(name())) { return toClsList(CDef.Visible.listByGroup(groupName)); }
            if (WorkFlg.name().equals(name())) { return toClsList(CDef.WorkFlg.listByGroup(groupName)); }
            if (WorkMessageFlg.name().equals(name())) { return toClsList(CDef.WorkMessageFlg.listByGroup(groupName)); }
            if (YamatoDelivTz.name().equals(name())) { return toClsList(CDef.YamatoDelivTz.listByGroup(groupName)); }
            if (YupackDelivTz.name().equals(name())) { return toClsList(CDef.YupackDelivTz.listByGroup(groupName)); }
            if (ZipFlg.name().equals(name())) { return toClsList(CDef.ZipFlg.listByGroup(groupName)); }
            if (AttendanceLeavingRest.name().equals(name())) { return toClsList(CDef.AttendanceLeavingRest.listByGroup(groupName)); }
            if (BolOutputTargetFlg.name().equals(name())) { return toClsList(CDef.BolOutputTargetFlg.listByGroup(groupName)); }
            if (BolOutFlg.name().equals(name())) { return toClsList(CDef.BolOutFlg.listByGroup(groupName)); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return toClsList(CDef.CallBeforeDeliveryFlg.listByGroup(groupName)); }
            if (CasePickFlg.name().equals(name())) { return toClsList(CDef.CasePickFlg.listByGroup(groupName)); }
            if (CasePicTarget.name().equals(name())) { return toClsList(CDef.CasePicTarget.listByGroup(groupName)); }
            if (CesIntegrationFlg.name().equals(name())) { return toClsList(CDef.CesIntegrationFlg.listByGroup(groupName)); }
            if (CodFlg.name().equals(name())) { return toClsList(CDef.CodFlg.listByGroup(groupName)); }
            if (DecimalExistFlg.name().equals(name())) { return toClsList(CDef.DecimalExistFlg.listByGroup(groupName)); }
            if (DecimalProductPacking.name().equals(name())) { return toClsList(CDef.DecimalProductPacking.listByGroup(groupName)); }
            if (DoNotStackStackFlg.name().equals(name())) { return toClsList(CDef.DoNotStackStackFlg.listByGroup(groupName)); }
            if (EmReplenishShapeFlg.name().equals(name())) { return toClsList(CDef.EmReplenishShapeFlg.listByGroup(groupName)); }
            if (FoogFlg.name().equals(name())) { return toClsList(CDef.FoogFlg.listByGroup(groupName)); }
            if (FreezableProtectionFlg.name().equals(name())) { return toClsList(CDef.FreezableProtectionFlg.listByGroup(groupName)); }
            if (FreightCls.name().equals(name())) { return toClsList(CDef.FreightCls.listByGroup(groupName)); }
            if (GuaranteedPlusFlg.name().equals(name())) { return toClsList(CDef.GuaranteedPlusFlg.listByGroup(groupName)); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryCollectFlg.listByGroup(groupName)); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryPrepaidFlg.listByGroup(groupName)); }
            if (InsidePickupCollectFlg.name().equals(name())) { return toClsList(CDef.InsidePickupCollectFlg.listByGroup(groupName)); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsidePickupPrepaidFlg.listByGroup(groupName)); }
            if (InspectionLabelOutFlg.name().equals(name())) { return toClsList(CDef.InspectionLabelOutFlg.listByGroup(groupName)); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryCollectFlg.listByGroup(groupName)); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryPrepaidFlg.listByGroup(groupName)); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupCollectFlg.listByGroup(groupName)); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupPrepaidFlg.listByGroup(groupName)); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessDeliveryFlg.listByGroup(groupName)); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessPickupFlg.listByGroup(groupName)); }
            if (OverSizedFlg.name().equals(name())) { return toClsList(CDef.OverSizedFlg.listByGroup(groupName)); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return toClsList(CDef.PackingSlipAutoOutputFlg.listByGroup(groupName)); }
            if (PaymentTerm.name().equals(name())) { return toClsList(CDef.PaymentTerm.listByGroup(groupName)); }
            if (PickingType.name().equals(name())) { return toClsList(CDef.PickingType.listByGroup(groupName)); }
            if (PoisonFlg.name().equals(name())) { return toClsList(CDef.PoisonFlg.listByGroup(groupName)); }
            if (RcmdPickingCls.name().equals(name())) { return toClsList(CDef.RcmdPickingCls.listByGroup(groupName)); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return toClsList(CDef.ResidentialDeliveryFlg.listByGroup(groupName)); }
            if (ResidentialPickupFlg.name().equals(name())) { return toClsList(CDef.ResidentialPickupFlg.listByGroup(groupName)); }
            if (SatDeliveryFlg.name().equals(name())) { return toClsList(CDef.SatDeliveryFlg.listByGroup(groupName)); }
            if (SglRowPicTarget.name().equals(name())) { return toClsList(CDef.SglRowPicTarget.listByGroup(groupName)); }
            if (SignatureReleaseFlg.name().equals(name())) { return toClsList(CDef.SignatureReleaseFlg.listByGroup(groupName)); }
            if (SignatureRequiredFlg.name().equals(name())) { return toClsList(CDef.SignatureRequiredFlg.listByGroup(groupName)); }
            if (UploadZipType.name().equals(name())) { return toClsList(CDef.UploadZipType.listByGroup(groupName)); }
            if (WorkLogOutFlg.name().equals(name())) { return toClsList(CDef.WorkLogOutFlg.listByGroup(groupName)); }
            if (WorkStatus.name().equals(name())) { return toClsList(CDef.WorkStatus.listByGroup(groupName)); }
            if (Adjuststatus.name().equals(name())) { return toClsList(CDef.Adjuststatus.listByGroup(groupName)); }
            if (Companygroup.name().equals(name())) { return toClsList(CDef.Companygroup.listByGroup(groupName)); }
            if (LocGroup.name().equals(name())) { return toClsList(CDef.LocGroup.listByGroup(groupName)); }
            if (Worktype.name().equals(name())) { return toClsList(CDef.Worktype.listByGroup(groupName)); }
            if (Capitemflg.name().equals(name())) { return toClsList(CDef.Capitemflg.listByGroup(groupName)); }
            if (Palletests.name().equals(name())) { return toClsList(CDef.Palletests.listByGroup(groupName)); }
            if (Usid.name().equals(name())) { return toClsList(CDef.Usid.listByGroup(groupName)); }
            if (Itemusedflg.name().equals(name())) { return toClsList(CDef.Itemusedflg.listByGroup(groupName)); }
            if (Symbolsts.name().equals(name())) { return toClsList(CDef.Symbolsts.listByGroup(groupName)); }
            if (Solistkbn.name().equals(name())) { return toClsList(CDef.Solistkbn.listByGroup(groupName)); }
            if (Palletaddflg.name().equals(name())) { return toClsList(CDef.Palletaddflg.listByGroup(groupName)); }
            if (Productdiv.name().equals(name())) { return toClsList(CDef.Productdiv.listByGroup(groupName)); }
            if (Soroutediv.name().equals(name())) { return toClsList(CDef.Soroutediv.listByGroup(groupName)); }
            if (Requesttype.name().equals(name())) { return toClsList(CDef.Requesttype.listByGroup(groupName)); }
            if (Examsts.name().equals(name())) { return toClsList(CDef.Examsts.listByGroup(groupName)); }
            if (Ordernoaddcd.name().equals(name())) { return toClsList(CDef.Ordernoaddcd.listByGroup(groupName)); }
            if (Tracetype.name().equals(name())) { return toClsList(CDef.Tracetype.listByGroup(groupName)); }
            if (Warehouseid.name().equals(name())) { return toClsList(CDef.Warehouseid.listByGroup(groupName)); }
            if (Markettype.name().equals(name())) { return toClsList(CDef.Markettype.listByGroup(groupName)); }
            if (Reservationflg.name().equals(name())) { return toClsList(CDef.Reservationflg.listByGroup(groupName)); }
            if (Packingtype.name().equals(name())) { return toClsList(CDef.Packingtype.listByGroup(groupName)); }
            if (Productmarkptn.name().equals(name())) { return toClsList(CDef.Productmarkptn.listByGroup(groupName)); }
            if (Productmarkptnbatj.name().equals(name())) { return toClsList(CDef.Productmarkptnbatj.listByGroup(groupName)); }
            if (Productmarkmonth.name().equals(name())) { return toClsList(CDef.Productmarkmonth.listByGroup(groupName)); }
            if (Limitdatemonth.name().equals(name())) { return toClsList(CDef.Limitdatemonth.listByGroup(groupName)); }
            if (Alclimitdatemonth.name().equals(name())) { return toClsList(CDef.Alclimitdatemonth.listByGroup(groupName)); }
            if (Labellayoutmaster.name().equals(name())) { return toClsList(CDef.Labellayoutmaster.listByGroup(groupName)); }
            if (Trafficpattern.name().equals(name())) { return toClsList(CDef.Trafficpattern.listByGroup(groupName)); }
            if (Cgrid.name().equals(name())) { return toClsList(CDef.Cgrid.listByGroup(groupName)); }
            if (Reportname.name().equals(name())) { return toClsList(CDef.Reportname.listByGroup(groupName)); }
            if (Jyokenflg.name().equals(name())) { return toClsList(CDef.Jyokenflg.listByGroup(groupName)); }
            if (Imshiptocode.name().equals(name())) { return toClsList(CDef.Imshiptocode.listByGroup(groupName)); }
            if (Fileinfo.name().equals(name())) { return toClsList(CDef.Fileinfo.listByGroup(groupName)); }
            if (Shiptocdchg.name().equals(name())) { return toClsList(CDef.Shiptocdchg.listByGroup(groupName)); }
            if (Tdwmscd.name().equals(name())) { return toClsList(CDef.Tdwmscd.listByGroup(groupName)); }
            if (Inoutdatatype.name().equals(name())) { return toClsList(CDef.Inoutdatatype.listByGroup(groupName)); }
            if (Invmoveterm.name().equals(name())) { return toClsList(CDef.Invmoveterm.listByGroup(groupName)); }
            if (Symbolsendhulftmaster.name().equals(name())) { return toClsList(CDef.Symbolsendhulftmaster.listByGroup(groupName)); }
            if (Logflag.name().equals(name())) { return toClsList(CDef.Logflag.listByGroup(groupName)); }
            if (Assortmentsts.name().equals(name())) { return toClsList(CDef.Assortmentsts.listByGroup(groupName)); }
            if (Assortmentflg.name().equals(name())) { return toClsList(CDef.Assortmentflg.listByGroup(groupName)); }
            if (Aststsforsearch.name().equals(name())) { return toClsList(CDef.Aststsforsearch.listByGroup(groupName)); }
            if (Firstexamsendflg.name().equals(name())) { return toClsList(CDef.Firstexamsendflg.listByGroup(groupName)); }
            if (Mossendflg.name().equals(name())) { return toClsList(CDef.Mossendflg.listByGroup(groupName)); }
            if (Casecreatetype.name().equals(name())) { return toClsList(CDef.Casecreatetype.listByGroup(groupName)); }
            if (Mosjtsendflg.name().equals(name())) { return toClsList(CDef.Mosjtsendflg.listByGroup(groupName)); }
            if (Batkeepwarehousecd.name().equals(name())) { return toClsList(CDef.Batkeepwarehousecd.listByGroup(groupName)); }
            if (Batwarehousecd.name().equals(name())) { return toClsList(CDef.Batwarehousecd.listByGroup(groupName)); }
            if (Datamakeflg.name().equals(name())) { return toClsList(CDef.Datamakeflg.listByGroup(groupName)); }
            if (Rcvresultqtytype.name().equals(name())) { return toClsList(CDef.Rcvresultqtytype.listByGroup(groupName)); }
            if (Qualityexamflg.name().equals(name())) { return toClsList(CDef.Qualityexamflg.listByGroup(groupName)); }
            if (Makercasecodefixedvalue.name().equals(name())) { return toClsList(CDef.Makercasecodefixedvalue.listByGroup(groupName)); }
            if (Productmarkjttaxfree.name().equals(name())) { return toClsList(CDef.Productmarkjttaxfree.listByGroup(groupName)); }
            if (PrinterdefS011.name().equals(name())) { return toClsList(CDef.PrinterdefS011.listByGroup(groupName)); }
            if (PrinterdefS012.name().equals(name())) { return toClsList(CDef.PrinterdefS012.listByGroup(groupName)); }
            if (PrinterdefN002.name().equals(name())) { return toClsList(CDef.PrinterdefN002.listByGroup(groupName)); }
            if (PrinterdefZ005.name().equals(name())) { return toClsList(CDef.PrinterdefZ005.listByGroup(groupName)); }
            if (Sortstockkbn.name().equals(name())) { return toClsList(CDef.Sortstockkbn.listByGroup(groupName)); }
            if (Tracetypedt.name().equals(name())) { return toClsList(CDef.Tracetypedt.listByGroup(groupName)); }
            if (Racklabelprflg.name().equals(name())) { return toClsList(CDef.Racklabelprflg.listByGroup(groupName)); }
            if (PrinterdefS0031.name().equals(name())) { return toClsList(CDef.PrinterdefS0031.listByGroup(groupName)); }
            if (PrinterdefS0032.name().equals(name())) { return toClsList(CDef.PrinterdefS0032.listByGroup(groupName)); }
            if (PrinterdefS0033.name().equals(name())) { return toClsList(CDef.PrinterdefS0033.listByGroup(groupName)); }
            if (PrinterdefS0034.name().equals(name())) { return toClsList(CDef.PrinterdefS0034.listByGroup(groupName)); }
            if (Unknowncaselimit.name().equals(name())) { return toClsList(CDef.Unknowncaselimit.listByGroup(groupName)); }
            if (Sortinvkbn.name().equals(name())) { return toClsList(CDef.Sortinvkbn.listByGroup(groupName)); }
            if (Cloudcasenum.name().equals(name())) { return toClsList(CDef.Cloudcasenum.listByGroup(groupName)); }
            if (Pulltype.name().equals(name())) { return toClsList(CDef.Pulltype.listByGroup(groupName)); }
            if (Storageloc.name().equals(name())) { return toClsList(CDef.Storageloc.listByGroup(groupName)); }
            if (Pallettracetype.name().equals(name())) { return toClsList(CDef.Pallettracetype.listByGroup(groupName)); }
            if (Datasendtype.name().equals(name())) { return toClsList(CDef.Datasendtype.listByGroup(groupName)); }
            if (Tracecreatests.name().equals(name())) { return toClsList(CDef.Tracecreatests.listByGroup(groupName)); }
            if (Sortinvtiming.name().equals(name())) { return toClsList(CDef.Sortinvtiming.listByGroup(groupName)); }
            if (Casesupplytype.name().equals(name())) { return toClsList(CDef.Casesupplytype.listByGroup(groupName)); }
            if (Importumu.name().equals(name())) { return toClsList(CDef.Importumu.listByGroup(groupName)); }
            if (Traceshiftflg.name().equals(name())) { return toClsList(CDef.Traceshiftflg.listByGroup(groupName)); }
            if (Shtypecd.name().equals(name())) { return toClsList(CDef.Shtypecd.listByGroup(groupName)); }
            if (Allocpolicy.name().equals(name())) { return toClsList(CDef.Allocpolicy.listByGroup(groupName)); }
            if (Rtncompanyname.name().equals(name())) { return toClsList(CDef.Rtncompanyname.listByGroup(groupName)); }
            if (Opendiff.name().equals(name())) { return toClsList(CDef.Opendiff.listByGroup(groupName)); }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return toClsList(CDef.ItemcdlookupAvailableflg.listByGroup(groupName)); }
            if (Flexpickprflg.name().equals(name())) { return toClsList(CDef.Flexpickprflg.listByGroup(groupName)); }
            if (WorkmasterExp.name().equals(name())) { return toClsList(CDef.WorkmasterExp.listByGroup(groupName)); }
            if (Tasktype.name().equals(name())) { return toClsList(CDef.Tasktype.listByGroup(groupName)); }
            if (Tasktypedetail.name().equals(name())) { return toClsList(CDef.Tasktypedetail.listByGroup(groupName)); }
            if (Yztraceshiftflg.name().equals(name())) { return toClsList(CDef.Yztraceshiftflg.listByGroup(groupName)); }
            if (Workercdsearchtype.name().equals(name())) { return toClsList(CDef.Workercdsearchtype.listByGroup(groupName)); }
            if (PrinterdefZ004.name().equals(name())) { return toClsList(CDef.PrinterdefZ004.listByGroup(groupName)); }
            if (PrinterdefZ008.name().equals(name())) { return toClsList(CDef.PrinterdefZ008.listByGroup(groupName)); }
            if (Pickdistname.name().equals(name())) { return toClsList(CDef.Pickdistname.listByGroup(groupName)); }
            if (Traceswitchflg.name().equals(name())) { return toClsList(CDef.Traceswitchflg.listByGroup(groupName)); }
            if (Lblkbn.name().equals(name())) { return toClsList(CDef.Lblkbn.listByGroup(groupName)); }
            if (Assortkbn.name().equals(name())) { return toClsList(CDef.Assortkbn.listByGroup(groupName)); }
            if (Dmycasecd.name().equals(name())) { return toClsList(CDef.Dmycasecd.listByGroup(groupName)); }
            if (Baditemdelkbn.name().equals(name())) { return toClsList(CDef.Baditemdelkbn.listByGroup(groupName)); }
            if (Selectlimit.name().equals(name())) { return toClsList(CDef.Selectlimit.listByGroup(groupName)); }
            if (PrinterdefW001.name().equals(name())) { return toClsList(CDef.PrinterdefW001.listByGroup(groupName)); }
            if (PrinterdefW002.name().equals(name())) { return toClsList(CDef.PrinterdefW002.listByGroup(groupName)); }
            if (Settlementinvmonth.name().equals(name())) { return toClsList(CDef.Settlementinvmonth.listByGroup(groupName)); }
            if (Flexinstructsts.name().equals(name())) { return toClsList(CDef.Flexinstructsts.listByGroup(groupName)); }
            if (Compulsionflg.name().equals(name())) { return toClsList(CDef.Compulsionflg.listByGroup(groupName)); }
            if (Displaymonth.name().equals(name())) { return toClsList(CDef.Displaymonth.listByGroup(groupName)); }
            if (Sufferusagesearchflg.name().equals(name())) { return toClsList(CDef.Sufferusagesearchflg.listByGroup(groupName)); }
            if (Fltstdinv.name().equals(name())) { return toClsList(CDef.Fltstdinv.listByGroup(groupName)); }
            if (Cs3switchflg.name().equals(name())) { return toClsList(CDef.Cs3switchflg.listByGroup(groupName)); }
            if (Inadequacyarea.name().equals(name())) { return toClsList(CDef.Inadequacyarea.listByGroup(groupName)); }
            if (Transmitflg.name().equals(name())) { return toClsList(CDef.Transmitflg.listByGroup(groupName)); }
            if (Flalterflg.name().equals(name())) { return toClsList(CDef.Flalterflg.listByGroup(groupName)); }
            if (Invsts.name().equals(name())) { return toClsList(CDef.Invsts.listByGroup(groupName)); }
            if (Concurrentbase.name().equals(name())) { return toClsList(CDef.Concurrentbase.listByGroup(groupName)); }
            if (Concurrentname.name().equals(name())) { return toClsList(CDef.Concurrentname.listByGroup(groupName)); }
            if (Caseshipstatus.name().equals(name())) { return toClsList(CDef.Caseshipstatus.listByGroup(groupName)); }
            if (Ngpitemcd.name().equals(name())) { return toClsList(CDef.Ngpitemcd.listByGroup(groupName)); }
            if (Fzloccd.name().equals(name())) { return toClsList(CDef.Fzloccd.listByGroup(groupName)); }
            if (Whsortinvkbn.name().equals(name())) { return toClsList(CDef.Whsortinvkbn.listByGroup(groupName)); }
            if (Syncreportform.name().equals(name())) { return toClsList(CDef.Syncreportform.listByGroup(groupName)); }
            if (Sortwarehousecd.name().equals(name())) { return toClsList(CDef.Sortwarehousecd.listByGroup(groupName)); }
            if (Hozeiwarehousecd.name().equals(name())) { return toClsList(CDef.Hozeiwarehousecd.listByGroup(groupName)); }
            if (PrinterdefH002.name().equals(name())) { return toClsList(CDef.PrinterdefH002.listByGroup(groupName)); }
            if (Reportformname.name().equals(name())) { return toClsList(CDef.Reportformname.listByGroup(groupName)); }
            if (Taskname.name().equals(name())) { return toClsList(CDef.Taskname.listByGroup(groupName)); }
            if (Whinvkbn.name().equals(name())) { return toClsList(CDef.Whinvkbn.listByGroup(groupName)); }
            if (Procflg.name().equals(name())) { return toClsList(CDef.Procflg.listByGroup(groupName)); }
            if (SyhnKbn.name().equals(name())) { return toClsList(CDef.SyhnKbn.listByGroup(groupName)); }
            if (Pallettype.name().equals(name())) { return toClsList(CDef.Pallettype.listByGroup(groupName)); }
            if (InventoryInstKbn.name().equals(name())) { return toClsList(CDef.InventoryInstKbn.listByGroup(groupName)); }
            if (InventoryReport.name().equals(name())) { return toClsList(CDef.InventoryReport.listByGroup(groupName)); }
            if (Completeflg.name().equals(name())) { return toClsList(CDef.Completeflg.listByGroup(groupName)); }
            if (Oneitemonlyflg.name().equals(name())) { return toClsList(CDef.Oneitemonlyflg.listByGroup(groupName)); }
            if (Oneowneronlyflg.name().equals(name())) { return toClsList(CDef.Oneowneronlyflg.listByGroup(groupName)); }
            if (Picktype.name().equals(name())) { return toClsList(CDef.Picktype.listByGroup(groupName)); }
            if (Rcvtype.name().equals(name())) { return toClsList(CDef.Rcvtype.listByGroup(groupName)); }
            if (Slottype.name().equals(name())) { return toClsList(CDef.Slottype.listByGroup(groupName)); }
            if (Capselect.name().equals(name())) { return toClsList(CDef.Capselect.listByGroup(groupName)); }
            if (Kashikokuzeikubn.name().equals(name())) { return toClsList(CDef.Kashikokuzeikubn.listByGroup(groupName)); }
            if (Instructflg.name().equals(name())) { return toClsList(CDef.Instructflg.listByGroup(groupName)); }
            if (Palleteoutputtype.name().equals(name())) { return toClsList(CDef.Palleteoutputtype.listByGroup(groupName)); }
            if (Palletecuttingkbn.name().equals(name())) { return toClsList(CDef.Palletecuttingkbn.listByGroup(groupName)); }
            if (Frontrackcd.name().equals(name())) { return toClsList(CDef.Frontrackcd.listByGroup(groupName)); }
            if (Sufferflg.name().equals(name())) { return toClsList(CDef.Sufferflg.listByGroup(groupName)); }
            if (Unmatchflg.name().equals(name())) { return toClsList(CDef.Unmatchflg.listByGroup(groupName)); }
            if (Alcimrsnflg.name().equals(name())) { return toClsList(CDef.Alcimrsnflg.listByGroup(groupName)); }
            if (Manyfewoccurarea.name().equals(name())) { return toClsList(CDef.Manyfewoccurarea.listByGroup(groupName)); }
            if (Manyfewoccurareadisp.name().equals(name())) { return toClsList(CDef.Manyfewoccurareadisp.listByGroup(groupName)); }
            if (Designchg.name().equals(name())) { return toClsList(CDef.Designchg.listByGroup(groupName)); }
            if (Differenceumu.name().equals(name())) { return toClsList(CDef.Differenceumu.listByGroup(groupName)); }
            if (Stockdistinction.name().equals(name())) { return toClsList(CDef.Stockdistinction.listByGroup(groupName)); }
            if (Workmaster.name().equals(name())) { return toClsList(CDef.Workmaster.listByGroup(groupName)); }
            if (Picklisttype.name().equals(name())) { return toClsList(CDef.Picklisttype.listByGroup(groupName)); }
            if (Sortzaikbn.name().equals(name())) { return toClsList(CDef.Sortzaikbn.listByGroup(groupName)); }
            if (Sorttype.name().equals(name())) { return toClsList(CDef.Sorttype.listByGroup(groupName)); }
            if (Exchgmethod.name().equals(name())) { return toClsList(CDef.Exchgmethod.listByGroup(groupName)); }
            if (Conditionflg.name().equals(name())) { return toClsList(CDef.Conditionflg.listByGroup(groupName)); }
            if (Qtyadjustflg.name().equals(name())) { return toClsList(CDef.Qtyadjustflg.listByGroup(groupName)); }
            if (Inoutcode.name().equals(name())) { return toClsList(CDef.Inoutcode.listByGroup(groupName)); }
            if (Inventorytype.name().equals(name())) { return toClsList(CDef.Inventorytype.listByGroup(groupName)); }
            if (Attensionflg.name().equals(name())) { return toClsList(CDef.Attensionflg.listByGroup(groupName)); }
            if (Formdiffflg.name().equals(name())) { return toClsList(CDef.Formdiffflg.listByGroup(groupName)); }
            if (Timingtype.name().equals(name())) { return toClsList(CDef.Timingtype.listByGroup(groupName)); }
            if (Fcflg.name().equals(name())) { return toClsList(CDef.Fcflg.listByGroup(groupName)); }
            if (SundayFlg.name().equals(name())) { return toClsList(CDef.SundayFlg.listByGroup(groupName)); }
            if (Pluralproductionkbn.name().equals(name())) { return toClsList(CDef.Pluralproductionkbn.listByGroup(groupName)); }
            if (Changeflg.name().equals(name())) { return toClsList(CDef.Changeflg.listByGroup(groupName)); }
            if (Rtnstatus.name().equals(name())) { return toClsList(CDef.Rtnstatus.listByGroup(groupName)); }
            if (Rtninspestatus.name().equals(name())) { return toClsList(CDef.Rtninspestatus.listByGroup(groupName)); }
            if (Inventoryref.name().equals(name())) { return toClsList(CDef.Inventoryref.listByGroup(groupName)); }
            if (Restockflg.name().equals(name())) { return toClsList(CDef.Restockflg.listByGroup(groupName)); }
            if (Validtype.name().equals(name())) { return toClsList(CDef.Validtype.listByGroup(groupName)); }
            if (Rtnchangedivision.name().equals(name())) { return toClsList(CDef.Rtnchangedivision.listByGroup(groupName)); }
            if (Storagearea.name().equals(name())) { return toClsList(CDef.Storagearea.listByGroup(groupName)); }
            if (Maxinvflg.name().equals(name())) { return toClsList(CDef.Maxinvflg.listByGroup(groupName)); }
            if (Horyukbn.name().equals(name())) { return toClsList(CDef.Horyukbn.listByGroup(groupName)); }
            if (Useflg.name().equals(name())) { return toClsList(CDef.Useflg.listByGroup(groupName)); }
            if (Fckokuflg.name().equals(name())) { return toClsList(CDef.Fckokuflg.listByGroup(groupName)); }
            if (Bowltypeflg.name().equals(name())) { return toClsList(CDef.Bowltypeflg.listByGroup(groupName)); }
            if (Inventoryrefdisp.name().equals(name())) { return toClsList(CDef.Inventoryrefdisp.listByGroup(groupName)); }
            if (Flinstrstatus.name().equals(name())) { return toClsList(CDef.Flinstrstatus.listByGroup(groupName)); }
            if (Flexstatus.name().equals(name())) { return toClsList(CDef.Flexstatus.listByGroup(groupName)); }
            if (Distributioncd.name().equals(name())) { return toClsList(CDef.Distributioncd.listByGroup(groupName)); }
            if (Stocklocation.name().equals(name())) { return toClsList(CDef.Stocklocation.listByGroup(groupName)); }
            if (ResultStatus.name().equals(name())) { return toClsList(CDef.ResultStatus.listByGroup(groupName)); }
            if (BoxCategory.name().equals(name())) { return toClsList(CDef.BoxCategory.listByGroup(groupName)); }
            if (Storagewarehousecd.name().equals(name())) { return toClsList(CDef.Storagewarehousecd.listByGroup(groupName)); }
            if (Salestype.name().equals(name())) { return toClsList(CDef.Salestype.listByGroup(groupName)); }
            if (Solistkbn2.name().equals(name())) { return toClsList(CDef.Solistkbn2.listByGroup(groupName)); }
            if (PickingListType.name().equals(name())) { return toClsList(CDef.PickingListType.listByGroup(groupName)); }
            if (CoveredClass.name().equals(name())) { return toClsList(CDef.CoveredClass.listByGroup(groupName)); }
            if (NotCoveredClass.name().equals(name())) { return toClsList(CDef.NotCoveredClass.listByGroup(groupName)); }
            if (PickingWorkStatus.name().equals(name())) { return toClsList(CDef.PickingWorkStatus.listByGroup(groupName)); }
            if (ReprintedFlg.name().equals(name())) { return toClsList(CDef.ReprintedFlg.listByGroup(groupName)); }
            if (Cggdid.name().equals(name())) { return toClsList(CDef.Cggdid.listByGroup(groupName)); }
            if (RcvPlanSts.name().equals(name())) { return toClsList(CDef.RcvPlanSts.listByGroup(groupName)); }
            if (Virtuallocflg.name().equals(name())) { return toClsList(CDef.Virtuallocflg.listByGroup(groupName)); }
            if (SufferUsageFlg.name().equals(name())) { return toClsList(CDef.SufferUsageFlg.listByGroup(groupName)); }
            if (Thedaysortingcompleteflg.name().equals(name())) { return toClsList(CDef.Thedaysortingcompleteflg.listByGroup(groupName)); }
            if (Gooditemkbn.name().equals(name())) { return toClsList(CDef.Gooditemkbn.listByGroup(groupName)); }
            if (Slptyp.name().equals(name())) { return toClsList(CDef.Slptyp.listByGroup(groupName)); }
            if (SostatusForserch2.name().equals(name())) { return toClsList(CDef.SostatusForserch2.listByGroup(groupName)); }
            if (LineOrderKbn.name().equals(name())) { return toClsList(CDef.LineOrderKbn.listByGroup(groupName)); }
            if (Consolidationflg.name().equals(name())) { return toClsList(CDef.Consolidationflg.listByGroup(groupName)); }
            if (DaysOfWeek.name().equals(name())) { return toClsList(CDef.DaysOfWeek.listByGroup(groupName)); }
            if (Lockbn.name().equals(name())) { return toClsList(CDef.Lockbn.listByGroup(groupName)); }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return toClsList(CDef.ReplenishmentRoundedupUnit.listByGroup(groupName)); }
            if (Restockkbn.name().equals(name())) { return toClsList(CDef.Restockkbn.listByGroup(groupName)); }
            if (Zaikodiv.name().equals(name())) { return toClsList(CDef.Zaikodiv.listByGroup(groupName)); }
            if (Openflg.name().equals(name())) { return toClsList(CDef.Openflg.listByGroup(groupName)); }
            if (TodayPrintOnlyFlg.name().equals(name())) { return toClsList(CDef.TodayPrintOnlyFlg.listByGroup(groupName)); }
            if (StartEnd.name().equals(name())) { return toClsList(CDef.StartEnd.listByGroup(groupName)); }
            if (SyhnKbnJt.name().equals(name())) { return toClsList(CDef.SyhnKbnJt.listByGroup(groupName)); }
            if (Transkbn.name().equals(name())) { return toClsList(CDef.Transkbn.listByGroup(groupName)); }
            if (Carknd.name().equals(name())) { return toClsList(CDef.Carknd.listByGroup(groupName)); }
            if (Cartypecmb0tdisp.name().equals(name())) { return toClsList(CDef.Cartypecmb0tdisp.listByGroup(groupName)); }
            if (CenterPicListCls1.name().equals(name())) { return toClsList(CDef.CenterPicListCls1.listByGroup(groupName)); }
            if (CenterPicListCls2.name().equals(name())) { return toClsList(CDef.CenterPicListCls2.listByGroup(groupName)); }
            if (CenterPicListCls3.name().equals(name())) { return toClsList(CDef.CenterPicListCls3.listByGroup(groupName)); }
            if (CenterSagawaDelivTz.name().equals(name())) { return toClsList(CDef.CenterSagawaDelivTz.listByGroup(groupName)); }
            if (CenterTransportTypeItem.name().equals(name())) { return toClsList(CDef.CenterTransportTypeItem.listByGroup(groupName)); }
            if (CenterSlipShapeCd.name().equals(name())) { return toClsList(CDef.CenterSlipShapeCd.listByGroup(groupName)); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return toClsList(CDef.CenterTransportTypeSpeed.listByGroup(groupName)); }
            if (CenterSealType.name().equals(name())) { return toClsList(CDef.CenterSealType.listByGroup(groupName)); }
            if (CenterTagClass.name().equals(name())) { return toClsList(CDef.CenterTagClass.listByGroup(groupName)); }
            if (CenterTagDataType.name().equals(name())) { return toClsList(CDef.CenterTagDataType.listByGroup(groupName)); }
            if (CenterTagType.name().equals(name())) { return toClsList(CDef.CenterTagType.listByGroup(groupName)); }
            if (CenterTagTypeAfter.name().equals(name())) { return toClsList(CDef.CenterTagTypeAfter.listByGroup(groupName)); }
            if (CenterApiBinsyuCode.name().equals(name())) { return toClsList(CDef.CenterApiBinsyuCode.listByGroup(groupName)); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiFlg.listByGroup(groupName)); }
            if (CenterApiDaibikiType.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiType.listByGroup(groupName)); }
            if (CenterApiEidomeFlg.name().equals(name())) { return toClsList(CDef.CenterApiEidomeFlg.listByGroup(groupName)); }
            if (CenterApiWeightCd.name().equals(name())) { return toClsList(CDef.CenterApiWeightCd.listByGroup(groupName)); }
            if (CenterOutputTargetFlg.name().equals(name())) { return toClsList(CDef.CenterOutputTargetFlg.listByGroup(groupName)); }
            if (CenterPrintCondition.name().equals(name())) { return toClsList(CDef.CenterPrintCondition.listByGroup(groupName)); }
            if (CenterDesignflg.name().equals(name())) { return toClsList(CDef.CenterDesignflg.listByGroup(groupName)); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public List<Classification> listOf(Collection<String> codeList) {
            if (ProcessTypeCd.name().equals(name())) { return toClsList(CDef.ProcessTypeCd.listOf(codeList)); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return toClsList(CDef.AfterDelivSlipOutTgt.listOf(codeList)); }
            if (AfterTagOutFlg.name().equals(name())) { return toClsList(CDef.AfterTagOutFlg.listOf(codeList)); }
            if (AllcNgDisplay.name().equals(name())) { return toClsList(CDef.AllcNgDisplay.listOf(codeList)); }
            if (AllcNgFlg.name().equals(name())) { return toClsList(CDef.AllcNgFlg.listOf(codeList)); }
            if (AllocSortKey.name().equals(name())) { return toClsList(CDef.AllocSortKey.listOf(codeList)); }
            if (AllShippingFlg.name().equals(name())) { return toClsList(CDef.AllShippingFlg.listOf(codeList)); }
            if (ArrivalStoreFormat.name().equals(name())) { return toClsList(CDef.ArrivalStoreFormat.listOf(codeList)); }
            if (AutoEmgSetFlg.name().equals(name())) { return toClsList(CDef.AutoEmgSetFlg.listOf(codeList)); }
            if (AutoEmgSetTgt.name().equals(name())) { return toClsList(CDef.AutoEmgSetTgt.listOf(codeList)); }
            if (AutoPrintTargetFlg.name().equals(name())) { return toClsList(CDef.AutoPrintTargetFlg.listOf(codeList)); }
            if (AutoShipInstFlg.name().equals(name())) { return toClsList(CDef.AutoShipInstFlg.listOf(codeList)); }
            if (BarcodeType.name().equals(name())) { return toClsList(CDef.BarcodeType.listOf(codeList)); }
            if (BatchProgressFlg.name().equals(name())) { return toClsList(CDef.BatchProgressFlg.listOf(codeList)); }
            if (BoxSelectSkip.name().equals(name())) { return toClsList(CDef.BoxSelectSkip.listOf(codeList)); }
            if (CancelDataDisplay.name().equals(name())) { return toClsList(CDef.CancelDataDisplay.listOf(codeList)); }
            if (CasePicFlg.name().equals(name())) { return toClsList(CDef.CasePicFlg.listOf(codeList)); }
            if (CenterClientCls.name().equals(name())) { return toClsList(CDef.CenterClientCls.listOf(codeList)); }
            if (CenterTransitFlg.name().equals(name())) { return toClsList(CDef.CenterTransitFlg.listOf(codeList)); }
            if (CharacterCd.name().equals(name())) { return toClsList(CDef.CharacterCd.listOf(codeList)); }
            if (ChargeQty0Display.name().equals(name())) { return toClsList(CDef.ChargeQty0Display.listOf(codeList)); }
            if (CheckDigit.name().equals(name())) { return toClsList(CDef.CheckDigit.listOf(codeList)); }
            if (CodeFlg.name().equals(name())) { return toClsList(CDef.CodeFlg.listOf(codeList)); }
            if (CodeType.name().equals(name())) { return toClsList(CDef.CodeType.listOf(codeList)); }
            if (CodCls.name().equals(name())) { return toClsList(CDef.CodCls.listOf(codeList)); }
            if (CodType.name().equals(name())) { return toClsList(CDef.CodType.listOf(codeList)); }
            if (ColType.name().equals(name())) { return toClsList(CDef.ColType.listOf(codeList)); }
            if (CommentFlg.name().equals(name())) { return toClsList(CDef.CommentFlg.listOf(codeList)); }
            if (CompanyFlg.name().equals(name())) { return toClsList(CDef.CompanyFlg.listOf(codeList)); }
            if (CoolCls.name().equals(name())) { return toClsList(CDef.CoolCls.listOf(codeList)); }
            if (CoolType.name().equals(name())) { return toClsList(CDef.CoolType.listOf(codeList)); }
            if (CopyTargetTable.name().equals(name())) { return toClsList(CDef.CopyTargetTable.listOf(codeList)); }
            if (CorrectType.name().equals(name())) { return toClsList(CDef.CorrectType.listOf(codeList)); }
            if (DataInputCommitType.name().equals(name())) { return toClsList(CDef.DataInputCommitType.listOf(codeList)); }
            if (DataInputOperationType.name().equals(name())) { return toClsList(CDef.DataInputOperationType.listOf(codeList)); }
            if (DataInputProcessType.name().equals(name())) { return toClsList(CDef.DataInputProcessType.listOf(codeList)); }
            if (DataInputRange.name().equals(name())) { return toClsList(CDef.DataInputRange.listOf(codeList)); }
            if (DataInputType.name().equals(name())) { return toClsList(CDef.DataInputType.listOf(codeList)); }
            if (DataType.name().equals(name())) { return toClsList(CDef.DataType.listOf(codeList)); }
            if (Default.name().equals(name())) { return toClsList(CDef.Default.listOf(codeList)); }
            if (DefaultFlg.name().equals(name())) { return toClsList(CDef.DefaultFlg.listOf(codeList)); }
            if (DeleteDataDisplay.name().equals(name())) { return toClsList(CDef.DeleteDataDisplay.listOf(codeList)); }
            if (DeliveryFlg.name().equals(name())) { return toClsList(CDef.DeliveryFlg.listOf(codeList)); }
            if (DelivMatchFlg.name().equals(name())) { return toClsList(CDef.DelivMatchFlg.listOf(codeList)); }
            if (DelivTz.name().equals(name())) { return toClsList(CDef.DelivTz.listOf(codeList)); }
            if (DelFlg.name().equals(name())) { return toClsList(CDef.DelFlg.listOf(codeList)); }
            if (DepositFlg.name().equals(name())) { return toClsList(CDef.DepositFlg.listOf(codeList)); }
            if (DisplayRequired.name().equals(name())) { return toClsList(CDef.DisplayRequired.listOf(codeList)); }
            if (DtCls.name().equals(name())) { return toClsList(CDef.DtCls.listOf(codeList)); }
            if (Editable.name().equals(name())) { return toClsList(CDef.Editable.listOf(codeList)); }
            if (EmergencyDisplay.name().equals(name())) { return toClsList(CDef.EmergencyDisplay.listOf(codeList)); }
            if (EmergencyFlg.name().equals(name())) { return toClsList(CDef.EmergencyFlg.listOf(codeList)); }
            if (ErrorFlg.name().equals(name())) { return toClsList(CDef.ErrorFlg.listOf(codeList)); }
            if (ErrorProcessMet.name().equals(name())) { return toClsList(CDef.ErrorProcessMet.listOf(codeList)); }
            if (FixedPoint.name().equals(name())) { return toClsList(CDef.FixedPoint.listOf(codeList)); }
            if (ForceFixedFlg.name().equals(name())) { return toClsList(CDef.ForceFixedFlg.listOf(codeList)); }
            if (ForeignFlg.name().equals(name())) { return toClsList(CDef.ForeignFlg.listOf(codeList)); }
            if (GiftFlg.name().equals(name())) { return toClsList(CDef.GiftFlg.listOf(codeList)); }
            if (GiftStatementType.name().equals(name())) { return toClsList(CDef.GiftStatementType.listOf(codeList)); }
            if (HtCharReadFlg.name().equals(name())) { return toClsList(CDef.HtCharReadFlg.listOf(codeList)); }
            if (ImportFlg.name().equals(name())) { return toClsList(CDef.ImportFlg.listOf(codeList)); }
            if (InfoFlg.name().equals(name())) { return toClsList(CDef.InfoFlg.listOf(codeList)); }
            if (InoutType.name().equals(name())) { return toClsList(CDef.InoutType.listOf(codeList)); }
            if (InputType.name().equals(name())) { return toClsList(CDef.InputType.listOf(codeList)); }
            if (InspectionFlg.name().equals(name())) { return toClsList(CDef.InspectionFlg.listOf(codeList)); }
            if (InventoryLocationProduct.name().equals(name())) { return toClsList(CDef.InventoryLocationProduct.listOf(codeList)); }
            if (InvoiceCreateFlg.name().equals(name())) { return toClsList(CDef.InvoiceCreateFlg.listOf(codeList)); }
            if (ItemType.name().equals(name())) { return toClsList(CDef.ItemType.listOf(codeList)); }
            if (LastFlg.name().equals(name())) { return toClsList(CDef.LastFlg.listOf(codeList)); }
            if (LimitDtManagFlg.name().equals(name())) { return toClsList(CDef.LimitDtManagFlg.listOf(codeList)); }
            if (LimitDtReverseFlg.name().equals(name())) { return toClsList(CDef.LimitDtReverseFlg.listOf(codeList)); }
            if (LimitMessageCd.name().equals(name())) { return toClsList(CDef.LimitMessageCd.listOf(codeList)); }
            if (LineFeedCd.name().equals(name())) { return toClsList(CDef.LineFeedCd.listOf(codeList)); }
            if (ListOutFlg.name().equals(name())) { return toClsList(CDef.ListOutFlg.listOf(codeList)); }
            if (ListOutFlgDisp.name().equals(name())) { return toClsList(CDef.ListOutFlgDisp.listOf(codeList)); }
            if (ListOutKbn.name().equals(name())) { return toClsList(CDef.ListOutKbn.listOf(codeList)); }
            if (LoadingFlg.name().equals(name())) { return toClsList(CDef.LoadingFlg.listOf(codeList)); }
            if (LocationType.name().equals(name())) { return toClsList(CDef.LocationType.listOf(codeList)); }
            if (Lockout.name().equals(name())) { return toClsList(CDef.Lockout.listOf(codeList)); }
            if (LogDtlStatus.name().equals(name())) { return toClsList(CDef.LogDtlStatus.listOf(codeList)); }
            if (LogDtlType.name().equals(name())) { return toClsList(CDef.LogDtlType.listOf(codeList)); }
            if (LogStatus.name().equals(name())) { return toClsList(CDef.LogStatus.listOf(codeList)); }
            if (LotManagFlg.name().equals(name())) { return toClsList(CDef.LotManagFlg.listOf(codeList)); }
            if (LotReverseFlg.name().equals(name())) { return toClsList(CDef.LotReverseFlg.listOf(codeList)); }
            if (MergeCls.name().equals(name())) { return toClsList(CDef.MergeCls.listOf(codeList)); }
            if (MergeFlg.name().equals(name())) { return toClsList(CDef.MergeFlg.listOf(codeList)); }
            if (MessageType.name().equals(name())) { return toClsList(CDef.MessageType.listOf(codeList)); }
            if (MixedFlg.name().equals(name())) { return toClsList(CDef.MixedFlg.listOf(codeList)); }
            if (MoveInstStatus.name().equals(name())) { return toClsList(CDef.MoveInstStatus.listOf(codeList)); }
            if (MultiPicCls.name().equals(name())) { return toClsList(CDef.MultiPicCls.listOf(codeList)); }
            if (MultiPicFlg.name().equals(name())) { return toClsList(CDef.MultiPicFlg.listOf(codeList)); }
            if (Necessary.name().equals(name())) { return toClsList(CDef.Necessary.listOf(codeList)); }
            if (NotCompletedFlg.name().equals(name())) { return toClsList(CDef.NotCompletedFlg.listOf(codeList)); }
            if (NoAllcDisplayFlg.name().equals(name())) { return toClsList(CDef.NoAllcDisplayFlg.listOf(codeList)); }
            if (NoConfirmedFlg.name().equals(name())) { return toClsList(CDef.NoConfirmedFlg.listOf(codeList)); }
            if (NoStockCls.name().equals(name())) { return toClsList(CDef.NoStockCls.listOf(codeList)); }
            if (NoStockOutFlg.name().equals(name())) { return toClsList(CDef.NoStockOutFlg.listOf(codeList)); }
            if (NoUpsideDownCls.name().equals(name())) { return toClsList(CDef.NoUpsideDownCls.listOf(codeList)); }
            if (OnetimeFlg.name().equals(name())) { return toClsList(CDef.OnetimeFlg.listOf(codeList)); }
            if (OverStoreNumFlg.name().equals(name())) { return toClsList(CDef.OverStoreNumFlg.listOf(codeList)); }
            if (PackingCalCls.name().equals(name())) { return toClsList(CDef.PackingCalCls.listOf(codeList)); }
            if (PackingProcessCls.name().equals(name())) { return toClsList(CDef.PackingProcessCls.listOf(codeList)); }
            if (PackingShowFlg.name().equals(name())) { return toClsList(CDef.PackingShowFlg.listOf(codeList)); }
            if (PackingStatus.name().equals(name())) { return toClsList(CDef.PackingStatus.listOf(codeList)); }
            if (PasswordReset.name().equals(name())) { return toClsList(CDef.PasswordReset.listOf(codeList)); }
            if (PastStoreDtFlg.name().equals(name())) { return toClsList(CDef.PastStoreDtFlg.listOf(codeList)); }
            if (PhysicalDelete.name().equals(name())) { return toClsList(CDef.PhysicalDelete.listOf(codeList)); }
            if (PickingFlg.name().equals(name())) { return toClsList(CDef.PickingFlg.listOf(codeList)); }
            if (PickingLocationFlg.name().equals(name())) { return toClsList(CDef.PickingLocationFlg.listOf(codeList)); }
            if (PickingStatus.name().equals(name())) { return toClsList(CDef.PickingStatus.listOf(codeList)); }
            if (PicCls.name().equals(name())) { return toClsList(CDef.PicCls.listOf(codeList)); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return toClsList(CDef.PicMthdRcmdBreakKey.listOf(codeList)); }
            if (PicMthdRcmdFlg.name().equals(name())) { return toClsList(CDef.PicMthdRcmdFlg.listOf(codeList)); }
            if (PicMthdRcmdListOut.name().equals(name())) { return toClsList(CDef.PicMthdRcmdListOut.listOf(codeList)); }
            if (PostType.name().equals(name())) { return toClsList(CDef.PostType.listOf(codeList)); }
            if (PrintedFlg.name().equals(name())) { return toClsList(CDef.PrintedFlg.listOf(codeList)); }
            if (PrintDataType.name().equals(name())) { return toClsList(CDef.PrintDataType.listOf(codeList)); }
            if (PrintErrorFlg.name().equals(name())) { return toClsList(CDef.PrintErrorFlg.listOf(codeList)); }
            if (PrintQueueStatus.name().equals(name())) { return toClsList(CDef.PrintQueueStatus.listOf(codeList)); }
            if (PrintResultClass.name().equals(name())) { return toClsList(CDef.PrintResultClass.listOf(codeList)); }
            if (PrintServiceStatus.name().equals(name())) { return toClsList(CDef.PrintServiceStatus.listOf(codeList)); }
            if (PrintStatus.name().equals(name())) { return toClsList(CDef.PrintStatus.listOf(codeList)); }
            if (PriorityFlg.name().equals(name())) { return toClsList(CDef.PriorityFlg.listOf(codeList)); }
            if (ProductLabelJanBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelJanBarcode.listOf(codeList)); }
            if (ProductLabelOutUnit.name().equals(name())) { return toClsList(CDef.ProductLabelOutUnit.listOf(codeList)); }
            if (ProductLabelProdBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelProdBarcode.listOf(codeList)); }
            if (ProductPartPacking.name().equals(name())) { return toClsList(CDef.ProductPartPacking.listOf(codeList)); }
            if (ProductTypeCode.name().equals(name())) { return toClsList(CDef.ProductTypeCode.listOf(codeList)); }
            if (Qty0Display.name().equals(name())) { return toClsList(CDef.Qty0Display.listOf(codeList)); }
            if (ReasonType.name().equals(name())) { return toClsList(CDef.ReasonType.listOf(codeList)); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return toClsList(CDef.ReceiveDeliveryStatus.listOf(codeList)); }
            if (ReceiveFlg.name().equals(name())) { return toClsList(CDef.ReceiveFlg.listOf(codeList)); }
            if (ReceiveStatus.name().equals(name())) { return toClsList(CDef.ReceiveStatus.listOf(codeList)); }
            if (ReplenishAllocCls.name().equals(name())) { return toClsList(CDef.ReplenishAllocCls.listOf(codeList)); }
            if (ReplenishProductCdUnset.name().equals(name())) { return toClsList(CDef.ReplenishProductCdUnset.listOf(codeList)); }
            if (ReplenishSearchCls.name().equals(name())) { return toClsList(CDef.ReplenishSearchCls.listOf(codeList)); }
            if (ReplenishUnitCls.name().equals(name())) { return toClsList(CDef.ReplenishUnitCls.listOf(codeList)); }
            if (ReportLayoutItemType.name().equals(name())) { return toClsList(CDef.ReportLayoutItemType.listOf(codeList)); }
            if (RestockType.name().equals(name())) { return toClsList(CDef.RestockType.listOf(codeList)); }
            if (ResultAfterProductLabel.name().equals(name())) { return toClsList(CDef.ResultAfterProductLabel.listOf(codeList)); }
            if (ResultAfterProductTarget.name().equals(name())) { return toClsList(CDef.ResultAfterProductTarget.listOf(codeList)); }
            if (ReverseValidFlg.name().equals(name())) { return toClsList(CDef.ReverseValidFlg.listOf(codeList)); }
            if (RoleControlClass.name().equals(name())) { return toClsList(CDef.RoleControlClass.listOf(codeList)); }
            if (Select.name().equals(name())) { return toClsList(CDef.Select.listOf(codeList)); }
            if (SelectPrintServiceStatus.name().equals(name())) { return toClsList(CDef.SelectPrintServiceStatus.listOf(codeList)); }
            if (SerialOperationType.name().equals(name())) { return toClsList(CDef.SerialOperationType.listOf(codeList)); }
            if (SettlementType.name().equals(name())) { return toClsList(CDef.SettlementType.listOf(codeList)); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return toClsList(CDef.SglRowInspAfterOutCls.listOf(codeList)); }
            if (SglRowPicFlg.name().equals(name())) { return toClsList(CDef.SglRowPicFlg.listOf(codeList)); }
            if (SheetCollate.name().equals(name())) { return toClsList(CDef.SheetCollate.listOf(codeList)); }
            if (ShippingFlg.name().equals(name())) { return toClsList(CDef.ShippingFlg.listOf(codeList)); }
            if (ShippingStatus.name().equals(name())) { return toClsList(CDef.ShippingStatus.listOf(codeList)); }
            if (ShippingStopFlg.name().equals(name())) { return toClsList(CDef.ShippingStopFlg.listOf(codeList)); }
            if (ShortStockDisplay.name().equals(name())) { return toClsList(CDef.ShortStockDisplay.listOf(codeList)); }
            if (ShpCheckCls.name().equals(name())) { return toClsList(CDef.ShpCheckCls.listOf(codeList)); }
            if (ShpCheckDisplay.name().equals(name())) { return toClsList(CDef.ShpCheckDisplay.listOf(codeList)); }
            if (SlipType.name().equals(name())) { return toClsList(CDef.SlipType.listOf(codeList)); }
            if (SoundPlayFlg.name().equals(name())) { return toClsList(CDef.SoundPlayFlg.listOf(codeList)); }
            if (StockAdjustFlg.name().equals(name())) { return toClsList(CDef.StockAdjustFlg.listOf(codeList)); }
            if (StockDisplayFld.name().equals(name())) { return toClsList(CDef.StockDisplayFld.listOf(codeList)); }
            if (StockExistOnlyFlg.name().equals(name())) { return toClsList(CDef.StockExistOnlyFlg.listOf(codeList)); }
            if (StockMoveFlg.name().equals(name())) { return toClsList(CDef.StockMoveFlg.listOf(codeList)); }
            if (StockNum0Display.name().equals(name())) { return toClsList(CDef.StockNum0Display.listOf(codeList)); }
            if (StockOutAllocCls.name().equals(name())) { return toClsList(CDef.StockOutAllocCls.listOf(codeList)); }
            if (StockOutAutoInstFlg.name().equals(name())) { return toClsList(CDef.StockOutAutoInstFlg.listOf(codeList)); }
            if (StockOutFlg.name().equals(name())) { return toClsList(CDef.StockOutFlg.listOf(codeList)); }
            if (StockOutInstCxlFlg.name().equals(name())) { return toClsList(CDef.StockOutInstCxlFlg.listOf(codeList)); }
            if (StockOutInstSplitFlg.name().equals(name())) { return toClsList(CDef.StockOutInstSplitFlg.listOf(codeList)); }
            if (StockQtyDisplay.name().equals(name())) { return toClsList(CDef.StockQtyDisplay.listOf(codeList)); }
            if (StockTakingInput.name().equals(name())) { return toClsList(CDef.StockTakingInput.listOf(codeList)); }
            if (StockTarget.name().equals(name())) { return toClsList(CDef.StockTarget.listOf(codeList)); }
            if (StoreDtFlg.name().equals(name())) { return toClsList(CDef.StoreDtFlg.listOf(codeList)); }
            if (StoreFlg.name().equals(name())) { return toClsList(CDef.StoreFlg.listOf(codeList)); }
            if (StoreNoDivideDisplay.name().equals(name())) { return toClsList(CDef.StoreNoDivideDisplay.listOf(codeList)); }
            if (StoreNoFlg.name().equals(name())) { return toClsList(CDef.StoreNoFlg.listOf(codeList)); }
            if (StoreNoMergeFlg.name().equals(name())) { return toClsList(CDef.StoreNoMergeFlg.listOf(codeList)); }
            if (SystemLogStatus.name().equals(name())) { return toClsList(CDef.SystemLogStatus.listOf(codeList)); }
            if (SystemLogType.name().equals(name())) { return toClsList(CDef.SystemLogType.listOf(codeList)); }
            if (SystemType.name().equals(name())) { return toClsList(CDef.SystemType.listOf(codeList)); }
            if (TagDeliveryOutFlg.name().equals(name())) { return toClsList(CDef.TagDeliveryOutFlg.listOf(codeList)); }
            if (TakingShippingDtFlg.name().equals(name())) { return toClsList(CDef.TakingShippingDtFlg.listOf(codeList)); }
            if (TakingShippingFlg.name().equals(name())) { return toClsList(CDef.TakingShippingFlg.listOf(codeList)); }
            if (TargetWindow.name().equals(name())) { return toClsList(CDef.TargetWindow.listOf(codeList)); }
            if (TextAlign.name().equals(name())) { return toClsList(CDef.TextAlign.listOf(codeList)); }
            if (TotalPicFlg.name().equals(name())) { return toClsList(CDef.TotalPicFlg.listOf(codeList)); }
            if (TrackingNumberingUnit.name().equals(name())) { return toClsList(CDef.TrackingNumberingUnit.listOf(codeList)); }
            if (TransitDisplay.name().equals(name())) { return toClsList(CDef.TransitDisplay.listOf(codeList)); }
            if (Unmatch.name().equals(name())) { return toClsList(CDef.Unmatch.listOf(codeList)); }
            if (Updatable.name().equals(name())) { return toClsList(CDef.Updatable.listOf(codeList)); }
            if (UpdCd.name().equals(name())) { return toClsList(CDef.UpdCd.listOf(codeList)); }
            if (UpdType.name().equals(name())) { return toClsList(CDef.UpdType.listOf(codeList)); }
            if (UploadTableNm.name().equals(name())) { return toClsList(CDef.UploadTableNm.listOf(codeList)); }
            if (UserEditable.name().equals(name())) { return toClsList(CDef.UserEditable.listOf(codeList)); }
            if (UseHtShipFlg.name().equals(name())) { return toClsList(CDef.UseHtShipFlg.listOf(codeList)); }
            if (VendorFlg.name().equals(name())) { return toClsList(CDef.VendorFlg.listOf(codeList)); }
            if (Visible.name().equals(name())) { return toClsList(CDef.Visible.listOf(codeList)); }
            if (WorkFlg.name().equals(name())) { return toClsList(CDef.WorkFlg.listOf(codeList)); }
            if (WorkMessageFlg.name().equals(name())) { return toClsList(CDef.WorkMessageFlg.listOf(codeList)); }
            if (YamatoDelivTz.name().equals(name())) { return toClsList(CDef.YamatoDelivTz.listOf(codeList)); }
            if (YupackDelivTz.name().equals(name())) { return toClsList(CDef.YupackDelivTz.listOf(codeList)); }
            if (ZipFlg.name().equals(name())) { return toClsList(CDef.ZipFlg.listOf(codeList)); }
            if (AttendanceLeavingRest.name().equals(name())) { return toClsList(CDef.AttendanceLeavingRest.listOf(codeList)); }
            if (BolOutputTargetFlg.name().equals(name())) { return toClsList(CDef.BolOutputTargetFlg.listOf(codeList)); }
            if (BolOutFlg.name().equals(name())) { return toClsList(CDef.BolOutFlg.listOf(codeList)); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return toClsList(CDef.CallBeforeDeliveryFlg.listOf(codeList)); }
            if (CasePickFlg.name().equals(name())) { return toClsList(CDef.CasePickFlg.listOf(codeList)); }
            if (CasePicTarget.name().equals(name())) { return toClsList(CDef.CasePicTarget.listOf(codeList)); }
            if (CesIntegrationFlg.name().equals(name())) { return toClsList(CDef.CesIntegrationFlg.listOf(codeList)); }
            if (CodFlg.name().equals(name())) { return toClsList(CDef.CodFlg.listOf(codeList)); }
            if (DecimalExistFlg.name().equals(name())) { return toClsList(CDef.DecimalExistFlg.listOf(codeList)); }
            if (DecimalProductPacking.name().equals(name())) { return toClsList(CDef.DecimalProductPacking.listOf(codeList)); }
            if (DoNotStackStackFlg.name().equals(name())) { return toClsList(CDef.DoNotStackStackFlg.listOf(codeList)); }
            if (EmReplenishShapeFlg.name().equals(name())) { return toClsList(CDef.EmReplenishShapeFlg.listOf(codeList)); }
            if (FoogFlg.name().equals(name())) { return toClsList(CDef.FoogFlg.listOf(codeList)); }
            if (FreezableProtectionFlg.name().equals(name())) { return toClsList(CDef.FreezableProtectionFlg.listOf(codeList)); }
            if (FreightCls.name().equals(name())) { return toClsList(CDef.FreightCls.listOf(codeList)); }
            if (GuaranteedPlusFlg.name().equals(name())) { return toClsList(CDef.GuaranteedPlusFlg.listOf(codeList)); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryCollectFlg.listOf(codeList)); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryPrepaidFlg.listOf(codeList)); }
            if (InsidePickupCollectFlg.name().equals(name())) { return toClsList(CDef.InsidePickupCollectFlg.listOf(codeList)); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsidePickupPrepaidFlg.listOf(codeList)); }
            if (InspectionLabelOutFlg.name().equals(name())) { return toClsList(CDef.InspectionLabelOutFlg.listOf(codeList)); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryCollectFlg.listOf(codeList)); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryPrepaidFlg.listOf(codeList)); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupCollectFlg.listOf(codeList)); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupPrepaidFlg.listOf(codeList)); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessDeliveryFlg.listOf(codeList)); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessPickupFlg.listOf(codeList)); }
            if (OverSizedFlg.name().equals(name())) { return toClsList(CDef.OverSizedFlg.listOf(codeList)); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return toClsList(CDef.PackingSlipAutoOutputFlg.listOf(codeList)); }
            if (PaymentTerm.name().equals(name())) { return toClsList(CDef.PaymentTerm.listOf(codeList)); }
            if (PickingType.name().equals(name())) { return toClsList(CDef.PickingType.listOf(codeList)); }
            if (PoisonFlg.name().equals(name())) { return toClsList(CDef.PoisonFlg.listOf(codeList)); }
            if (RcmdPickingCls.name().equals(name())) { return toClsList(CDef.RcmdPickingCls.listOf(codeList)); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return toClsList(CDef.ResidentialDeliveryFlg.listOf(codeList)); }
            if (ResidentialPickupFlg.name().equals(name())) { return toClsList(CDef.ResidentialPickupFlg.listOf(codeList)); }
            if (SatDeliveryFlg.name().equals(name())) { return toClsList(CDef.SatDeliveryFlg.listOf(codeList)); }
            if (SglRowPicTarget.name().equals(name())) { return toClsList(CDef.SglRowPicTarget.listOf(codeList)); }
            if (SignatureReleaseFlg.name().equals(name())) { return toClsList(CDef.SignatureReleaseFlg.listOf(codeList)); }
            if (SignatureRequiredFlg.name().equals(name())) { return toClsList(CDef.SignatureRequiredFlg.listOf(codeList)); }
            if (UploadZipType.name().equals(name())) { return toClsList(CDef.UploadZipType.listOf(codeList)); }
            if (WorkLogOutFlg.name().equals(name())) { return toClsList(CDef.WorkLogOutFlg.listOf(codeList)); }
            if (WorkStatus.name().equals(name())) { return toClsList(CDef.WorkStatus.listOf(codeList)); }
            if (Adjuststatus.name().equals(name())) { return toClsList(CDef.Adjuststatus.listOf(codeList)); }
            if (Companygroup.name().equals(name())) { return toClsList(CDef.Companygroup.listOf(codeList)); }
            if (LocGroup.name().equals(name())) { return toClsList(CDef.LocGroup.listOf(codeList)); }
            if (Worktype.name().equals(name())) { return toClsList(CDef.Worktype.listOf(codeList)); }
            if (Capitemflg.name().equals(name())) { return toClsList(CDef.Capitemflg.listOf(codeList)); }
            if (Palletests.name().equals(name())) { return toClsList(CDef.Palletests.listOf(codeList)); }
            if (Usid.name().equals(name())) { return toClsList(CDef.Usid.listOf(codeList)); }
            if (Itemusedflg.name().equals(name())) { return toClsList(CDef.Itemusedflg.listOf(codeList)); }
            if (Symbolsts.name().equals(name())) { return toClsList(CDef.Symbolsts.listOf(codeList)); }
            if (Solistkbn.name().equals(name())) { return toClsList(CDef.Solistkbn.listOf(codeList)); }
            if (Palletaddflg.name().equals(name())) { return toClsList(CDef.Palletaddflg.listOf(codeList)); }
            if (Productdiv.name().equals(name())) { return toClsList(CDef.Productdiv.listOf(codeList)); }
            if (Soroutediv.name().equals(name())) { return toClsList(CDef.Soroutediv.listOf(codeList)); }
            if (Requesttype.name().equals(name())) { return toClsList(CDef.Requesttype.listOf(codeList)); }
            if (Examsts.name().equals(name())) { return toClsList(CDef.Examsts.listOf(codeList)); }
            if (Ordernoaddcd.name().equals(name())) { return toClsList(CDef.Ordernoaddcd.listOf(codeList)); }
            if (Tracetype.name().equals(name())) { return toClsList(CDef.Tracetype.listOf(codeList)); }
            if (Warehouseid.name().equals(name())) { return toClsList(CDef.Warehouseid.listOf(codeList)); }
            if (Markettype.name().equals(name())) { return toClsList(CDef.Markettype.listOf(codeList)); }
            if (Reservationflg.name().equals(name())) { return toClsList(CDef.Reservationflg.listOf(codeList)); }
            if (Packingtype.name().equals(name())) { return toClsList(CDef.Packingtype.listOf(codeList)); }
            if (Productmarkptn.name().equals(name())) { return toClsList(CDef.Productmarkptn.listOf(codeList)); }
            if (Productmarkptnbatj.name().equals(name())) { return toClsList(CDef.Productmarkptnbatj.listOf(codeList)); }
            if (Productmarkmonth.name().equals(name())) { return toClsList(CDef.Productmarkmonth.listOf(codeList)); }
            if (Limitdatemonth.name().equals(name())) { return toClsList(CDef.Limitdatemonth.listOf(codeList)); }
            if (Alclimitdatemonth.name().equals(name())) { return toClsList(CDef.Alclimitdatemonth.listOf(codeList)); }
            if (Labellayoutmaster.name().equals(name())) { return toClsList(CDef.Labellayoutmaster.listOf(codeList)); }
            if (Trafficpattern.name().equals(name())) { return toClsList(CDef.Trafficpattern.listOf(codeList)); }
            if (Cgrid.name().equals(name())) { return toClsList(CDef.Cgrid.listOf(codeList)); }
            if (Reportname.name().equals(name())) { return toClsList(CDef.Reportname.listOf(codeList)); }
            if (Jyokenflg.name().equals(name())) { return toClsList(CDef.Jyokenflg.listOf(codeList)); }
            if (Imshiptocode.name().equals(name())) { return toClsList(CDef.Imshiptocode.listOf(codeList)); }
            if (Fileinfo.name().equals(name())) { return toClsList(CDef.Fileinfo.listOf(codeList)); }
            if (Shiptocdchg.name().equals(name())) { return toClsList(CDef.Shiptocdchg.listOf(codeList)); }
            if (Tdwmscd.name().equals(name())) { return toClsList(CDef.Tdwmscd.listOf(codeList)); }
            if (Inoutdatatype.name().equals(name())) { return toClsList(CDef.Inoutdatatype.listOf(codeList)); }
            if (Invmoveterm.name().equals(name())) { return toClsList(CDef.Invmoveterm.listOf(codeList)); }
            if (Symbolsendhulftmaster.name().equals(name())) { return toClsList(CDef.Symbolsendhulftmaster.listOf(codeList)); }
            if (Logflag.name().equals(name())) { return toClsList(CDef.Logflag.listOf(codeList)); }
            if (Assortmentsts.name().equals(name())) { return toClsList(CDef.Assortmentsts.listOf(codeList)); }
            if (Assortmentflg.name().equals(name())) { return toClsList(CDef.Assortmentflg.listOf(codeList)); }
            if (Aststsforsearch.name().equals(name())) { return toClsList(CDef.Aststsforsearch.listOf(codeList)); }
            if (Firstexamsendflg.name().equals(name())) { return toClsList(CDef.Firstexamsendflg.listOf(codeList)); }
            if (Mossendflg.name().equals(name())) { return toClsList(CDef.Mossendflg.listOf(codeList)); }
            if (Casecreatetype.name().equals(name())) { return toClsList(CDef.Casecreatetype.listOf(codeList)); }
            if (Mosjtsendflg.name().equals(name())) { return toClsList(CDef.Mosjtsendflg.listOf(codeList)); }
            if (Batkeepwarehousecd.name().equals(name())) { return toClsList(CDef.Batkeepwarehousecd.listOf(codeList)); }
            if (Batwarehousecd.name().equals(name())) { return toClsList(CDef.Batwarehousecd.listOf(codeList)); }
            if (Datamakeflg.name().equals(name())) { return toClsList(CDef.Datamakeflg.listOf(codeList)); }
            if (Rcvresultqtytype.name().equals(name())) { return toClsList(CDef.Rcvresultqtytype.listOf(codeList)); }
            if (Qualityexamflg.name().equals(name())) { return toClsList(CDef.Qualityexamflg.listOf(codeList)); }
            if (Makercasecodefixedvalue.name().equals(name())) { return toClsList(CDef.Makercasecodefixedvalue.listOf(codeList)); }
            if (Productmarkjttaxfree.name().equals(name())) { return toClsList(CDef.Productmarkjttaxfree.listOf(codeList)); }
            if (PrinterdefS011.name().equals(name())) { return toClsList(CDef.PrinterdefS011.listOf(codeList)); }
            if (PrinterdefS012.name().equals(name())) { return toClsList(CDef.PrinterdefS012.listOf(codeList)); }
            if (PrinterdefN002.name().equals(name())) { return toClsList(CDef.PrinterdefN002.listOf(codeList)); }
            if (PrinterdefZ005.name().equals(name())) { return toClsList(CDef.PrinterdefZ005.listOf(codeList)); }
            if (Sortstockkbn.name().equals(name())) { return toClsList(CDef.Sortstockkbn.listOf(codeList)); }
            if (Tracetypedt.name().equals(name())) { return toClsList(CDef.Tracetypedt.listOf(codeList)); }
            if (Racklabelprflg.name().equals(name())) { return toClsList(CDef.Racklabelprflg.listOf(codeList)); }
            if (PrinterdefS0031.name().equals(name())) { return toClsList(CDef.PrinterdefS0031.listOf(codeList)); }
            if (PrinterdefS0032.name().equals(name())) { return toClsList(CDef.PrinterdefS0032.listOf(codeList)); }
            if (PrinterdefS0033.name().equals(name())) { return toClsList(CDef.PrinterdefS0033.listOf(codeList)); }
            if (PrinterdefS0034.name().equals(name())) { return toClsList(CDef.PrinterdefS0034.listOf(codeList)); }
            if (Unknowncaselimit.name().equals(name())) { return toClsList(CDef.Unknowncaselimit.listOf(codeList)); }
            if (Sortinvkbn.name().equals(name())) { return toClsList(CDef.Sortinvkbn.listOf(codeList)); }
            if (Cloudcasenum.name().equals(name())) { return toClsList(CDef.Cloudcasenum.listOf(codeList)); }
            if (Pulltype.name().equals(name())) { return toClsList(CDef.Pulltype.listOf(codeList)); }
            if (Storageloc.name().equals(name())) { return toClsList(CDef.Storageloc.listOf(codeList)); }
            if (Pallettracetype.name().equals(name())) { return toClsList(CDef.Pallettracetype.listOf(codeList)); }
            if (Datasendtype.name().equals(name())) { return toClsList(CDef.Datasendtype.listOf(codeList)); }
            if (Tracecreatests.name().equals(name())) { return toClsList(CDef.Tracecreatests.listOf(codeList)); }
            if (Sortinvtiming.name().equals(name())) { return toClsList(CDef.Sortinvtiming.listOf(codeList)); }
            if (Casesupplytype.name().equals(name())) { return toClsList(CDef.Casesupplytype.listOf(codeList)); }
            if (Importumu.name().equals(name())) { return toClsList(CDef.Importumu.listOf(codeList)); }
            if (Traceshiftflg.name().equals(name())) { return toClsList(CDef.Traceshiftflg.listOf(codeList)); }
            if (Shtypecd.name().equals(name())) { return toClsList(CDef.Shtypecd.listOf(codeList)); }
            if (Allocpolicy.name().equals(name())) { return toClsList(CDef.Allocpolicy.listOf(codeList)); }
            if (Rtncompanyname.name().equals(name())) { return toClsList(CDef.Rtncompanyname.listOf(codeList)); }
            if (Opendiff.name().equals(name())) { return toClsList(CDef.Opendiff.listOf(codeList)); }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return toClsList(CDef.ItemcdlookupAvailableflg.listOf(codeList)); }
            if (Flexpickprflg.name().equals(name())) { return toClsList(CDef.Flexpickprflg.listOf(codeList)); }
            if (WorkmasterExp.name().equals(name())) { return toClsList(CDef.WorkmasterExp.listOf(codeList)); }
            if (Tasktype.name().equals(name())) { return toClsList(CDef.Tasktype.listOf(codeList)); }
            if (Tasktypedetail.name().equals(name())) { return toClsList(CDef.Tasktypedetail.listOf(codeList)); }
            if (Yztraceshiftflg.name().equals(name())) { return toClsList(CDef.Yztraceshiftflg.listOf(codeList)); }
            if (Workercdsearchtype.name().equals(name())) { return toClsList(CDef.Workercdsearchtype.listOf(codeList)); }
            if (PrinterdefZ004.name().equals(name())) { return toClsList(CDef.PrinterdefZ004.listOf(codeList)); }
            if (PrinterdefZ008.name().equals(name())) { return toClsList(CDef.PrinterdefZ008.listOf(codeList)); }
            if (Pickdistname.name().equals(name())) { return toClsList(CDef.Pickdistname.listOf(codeList)); }
            if (Traceswitchflg.name().equals(name())) { return toClsList(CDef.Traceswitchflg.listOf(codeList)); }
            if (Lblkbn.name().equals(name())) { return toClsList(CDef.Lblkbn.listOf(codeList)); }
            if (Assortkbn.name().equals(name())) { return toClsList(CDef.Assortkbn.listOf(codeList)); }
            if (Dmycasecd.name().equals(name())) { return toClsList(CDef.Dmycasecd.listOf(codeList)); }
            if (Baditemdelkbn.name().equals(name())) { return toClsList(CDef.Baditemdelkbn.listOf(codeList)); }
            if (Selectlimit.name().equals(name())) { return toClsList(CDef.Selectlimit.listOf(codeList)); }
            if (PrinterdefW001.name().equals(name())) { return toClsList(CDef.PrinterdefW001.listOf(codeList)); }
            if (PrinterdefW002.name().equals(name())) { return toClsList(CDef.PrinterdefW002.listOf(codeList)); }
            if (Settlementinvmonth.name().equals(name())) { return toClsList(CDef.Settlementinvmonth.listOf(codeList)); }
            if (Flexinstructsts.name().equals(name())) { return toClsList(CDef.Flexinstructsts.listOf(codeList)); }
            if (Compulsionflg.name().equals(name())) { return toClsList(CDef.Compulsionflg.listOf(codeList)); }
            if (Displaymonth.name().equals(name())) { return toClsList(CDef.Displaymonth.listOf(codeList)); }
            if (Sufferusagesearchflg.name().equals(name())) { return toClsList(CDef.Sufferusagesearchflg.listOf(codeList)); }
            if (Fltstdinv.name().equals(name())) { return toClsList(CDef.Fltstdinv.listOf(codeList)); }
            if (Cs3switchflg.name().equals(name())) { return toClsList(CDef.Cs3switchflg.listOf(codeList)); }
            if (Inadequacyarea.name().equals(name())) { return toClsList(CDef.Inadequacyarea.listOf(codeList)); }
            if (Transmitflg.name().equals(name())) { return toClsList(CDef.Transmitflg.listOf(codeList)); }
            if (Flalterflg.name().equals(name())) { return toClsList(CDef.Flalterflg.listOf(codeList)); }
            if (Invsts.name().equals(name())) { return toClsList(CDef.Invsts.listOf(codeList)); }
            if (Concurrentbase.name().equals(name())) { return toClsList(CDef.Concurrentbase.listOf(codeList)); }
            if (Concurrentname.name().equals(name())) { return toClsList(CDef.Concurrentname.listOf(codeList)); }
            if (Caseshipstatus.name().equals(name())) { return toClsList(CDef.Caseshipstatus.listOf(codeList)); }
            if (Ngpitemcd.name().equals(name())) { return toClsList(CDef.Ngpitemcd.listOf(codeList)); }
            if (Fzloccd.name().equals(name())) { return toClsList(CDef.Fzloccd.listOf(codeList)); }
            if (Whsortinvkbn.name().equals(name())) { return toClsList(CDef.Whsortinvkbn.listOf(codeList)); }
            if (Syncreportform.name().equals(name())) { return toClsList(CDef.Syncreportform.listOf(codeList)); }
            if (Sortwarehousecd.name().equals(name())) { return toClsList(CDef.Sortwarehousecd.listOf(codeList)); }
            if (Hozeiwarehousecd.name().equals(name())) { return toClsList(CDef.Hozeiwarehousecd.listOf(codeList)); }
            if (PrinterdefH002.name().equals(name())) { return toClsList(CDef.PrinterdefH002.listOf(codeList)); }
            if (Reportformname.name().equals(name())) { return toClsList(CDef.Reportformname.listOf(codeList)); }
            if (Taskname.name().equals(name())) { return toClsList(CDef.Taskname.listOf(codeList)); }
            if (Whinvkbn.name().equals(name())) { return toClsList(CDef.Whinvkbn.listOf(codeList)); }
            if (Procflg.name().equals(name())) { return toClsList(CDef.Procflg.listOf(codeList)); }
            if (SyhnKbn.name().equals(name())) { return toClsList(CDef.SyhnKbn.listOf(codeList)); }
            if (Pallettype.name().equals(name())) { return toClsList(CDef.Pallettype.listOf(codeList)); }
            if (InventoryInstKbn.name().equals(name())) { return toClsList(CDef.InventoryInstKbn.listOf(codeList)); }
            if (InventoryReport.name().equals(name())) { return toClsList(CDef.InventoryReport.listOf(codeList)); }
            if (Completeflg.name().equals(name())) { return toClsList(CDef.Completeflg.listOf(codeList)); }
            if (Oneitemonlyflg.name().equals(name())) { return toClsList(CDef.Oneitemonlyflg.listOf(codeList)); }
            if (Oneowneronlyflg.name().equals(name())) { return toClsList(CDef.Oneowneronlyflg.listOf(codeList)); }
            if (Picktype.name().equals(name())) { return toClsList(CDef.Picktype.listOf(codeList)); }
            if (Rcvtype.name().equals(name())) { return toClsList(CDef.Rcvtype.listOf(codeList)); }
            if (Slottype.name().equals(name())) { return toClsList(CDef.Slottype.listOf(codeList)); }
            if (Capselect.name().equals(name())) { return toClsList(CDef.Capselect.listOf(codeList)); }
            if (Kashikokuzeikubn.name().equals(name())) { return toClsList(CDef.Kashikokuzeikubn.listOf(codeList)); }
            if (Instructflg.name().equals(name())) { return toClsList(CDef.Instructflg.listOf(codeList)); }
            if (Palleteoutputtype.name().equals(name())) { return toClsList(CDef.Palleteoutputtype.listOf(codeList)); }
            if (Palletecuttingkbn.name().equals(name())) { return toClsList(CDef.Palletecuttingkbn.listOf(codeList)); }
            if (Frontrackcd.name().equals(name())) { return toClsList(CDef.Frontrackcd.listOf(codeList)); }
            if (Sufferflg.name().equals(name())) { return toClsList(CDef.Sufferflg.listOf(codeList)); }
            if (Unmatchflg.name().equals(name())) { return toClsList(CDef.Unmatchflg.listOf(codeList)); }
            if (Alcimrsnflg.name().equals(name())) { return toClsList(CDef.Alcimrsnflg.listOf(codeList)); }
            if (Manyfewoccurarea.name().equals(name())) { return toClsList(CDef.Manyfewoccurarea.listOf(codeList)); }
            if (Manyfewoccurareadisp.name().equals(name())) { return toClsList(CDef.Manyfewoccurareadisp.listOf(codeList)); }
            if (Designchg.name().equals(name())) { return toClsList(CDef.Designchg.listOf(codeList)); }
            if (Differenceumu.name().equals(name())) { return toClsList(CDef.Differenceumu.listOf(codeList)); }
            if (Stockdistinction.name().equals(name())) { return toClsList(CDef.Stockdistinction.listOf(codeList)); }
            if (Workmaster.name().equals(name())) { return toClsList(CDef.Workmaster.listOf(codeList)); }
            if (Picklisttype.name().equals(name())) { return toClsList(CDef.Picklisttype.listOf(codeList)); }
            if (Sortzaikbn.name().equals(name())) { return toClsList(CDef.Sortzaikbn.listOf(codeList)); }
            if (Sorttype.name().equals(name())) { return toClsList(CDef.Sorttype.listOf(codeList)); }
            if (Exchgmethod.name().equals(name())) { return toClsList(CDef.Exchgmethod.listOf(codeList)); }
            if (Conditionflg.name().equals(name())) { return toClsList(CDef.Conditionflg.listOf(codeList)); }
            if (Qtyadjustflg.name().equals(name())) { return toClsList(CDef.Qtyadjustflg.listOf(codeList)); }
            if (Inoutcode.name().equals(name())) { return toClsList(CDef.Inoutcode.listOf(codeList)); }
            if (Inventorytype.name().equals(name())) { return toClsList(CDef.Inventorytype.listOf(codeList)); }
            if (Attensionflg.name().equals(name())) { return toClsList(CDef.Attensionflg.listOf(codeList)); }
            if (Formdiffflg.name().equals(name())) { return toClsList(CDef.Formdiffflg.listOf(codeList)); }
            if (Timingtype.name().equals(name())) { return toClsList(CDef.Timingtype.listOf(codeList)); }
            if (Fcflg.name().equals(name())) { return toClsList(CDef.Fcflg.listOf(codeList)); }
            if (SundayFlg.name().equals(name())) { return toClsList(CDef.SundayFlg.listOf(codeList)); }
            if (Pluralproductionkbn.name().equals(name())) { return toClsList(CDef.Pluralproductionkbn.listOf(codeList)); }
            if (Changeflg.name().equals(name())) { return toClsList(CDef.Changeflg.listOf(codeList)); }
            if (Rtnstatus.name().equals(name())) { return toClsList(CDef.Rtnstatus.listOf(codeList)); }
            if (Rtninspestatus.name().equals(name())) { return toClsList(CDef.Rtninspestatus.listOf(codeList)); }
            if (Inventoryref.name().equals(name())) { return toClsList(CDef.Inventoryref.listOf(codeList)); }
            if (Restockflg.name().equals(name())) { return toClsList(CDef.Restockflg.listOf(codeList)); }
            if (Validtype.name().equals(name())) { return toClsList(CDef.Validtype.listOf(codeList)); }
            if (Rtnchangedivision.name().equals(name())) { return toClsList(CDef.Rtnchangedivision.listOf(codeList)); }
            if (Storagearea.name().equals(name())) { return toClsList(CDef.Storagearea.listOf(codeList)); }
            if (Maxinvflg.name().equals(name())) { return toClsList(CDef.Maxinvflg.listOf(codeList)); }
            if (Horyukbn.name().equals(name())) { return toClsList(CDef.Horyukbn.listOf(codeList)); }
            if (Useflg.name().equals(name())) { return toClsList(CDef.Useflg.listOf(codeList)); }
            if (Fckokuflg.name().equals(name())) { return toClsList(CDef.Fckokuflg.listOf(codeList)); }
            if (Bowltypeflg.name().equals(name())) { return toClsList(CDef.Bowltypeflg.listOf(codeList)); }
            if (Inventoryrefdisp.name().equals(name())) { return toClsList(CDef.Inventoryrefdisp.listOf(codeList)); }
            if (Flinstrstatus.name().equals(name())) { return toClsList(CDef.Flinstrstatus.listOf(codeList)); }
            if (Flexstatus.name().equals(name())) { return toClsList(CDef.Flexstatus.listOf(codeList)); }
            if (Distributioncd.name().equals(name())) { return toClsList(CDef.Distributioncd.listOf(codeList)); }
            if (Stocklocation.name().equals(name())) { return toClsList(CDef.Stocklocation.listOf(codeList)); }
            if (ResultStatus.name().equals(name())) { return toClsList(CDef.ResultStatus.listOf(codeList)); }
            if (BoxCategory.name().equals(name())) { return toClsList(CDef.BoxCategory.listOf(codeList)); }
            if (Storagewarehousecd.name().equals(name())) { return toClsList(CDef.Storagewarehousecd.listOf(codeList)); }
            if (Salestype.name().equals(name())) { return toClsList(CDef.Salestype.listOf(codeList)); }
            if (Solistkbn2.name().equals(name())) { return toClsList(CDef.Solistkbn2.listOf(codeList)); }
            if (PickingListType.name().equals(name())) { return toClsList(CDef.PickingListType.listOf(codeList)); }
            if (CoveredClass.name().equals(name())) { return toClsList(CDef.CoveredClass.listOf(codeList)); }
            if (NotCoveredClass.name().equals(name())) { return toClsList(CDef.NotCoveredClass.listOf(codeList)); }
            if (PickingWorkStatus.name().equals(name())) { return toClsList(CDef.PickingWorkStatus.listOf(codeList)); }
            if (ReprintedFlg.name().equals(name())) { return toClsList(CDef.ReprintedFlg.listOf(codeList)); }
            if (Cggdid.name().equals(name())) { return toClsList(CDef.Cggdid.listOf(codeList)); }
            if (RcvPlanSts.name().equals(name())) { return toClsList(CDef.RcvPlanSts.listOf(codeList)); }
            if (Virtuallocflg.name().equals(name())) { return toClsList(CDef.Virtuallocflg.listOf(codeList)); }
            if (SufferUsageFlg.name().equals(name())) { return toClsList(CDef.SufferUsageFlg.listOf(codeList)); }
            if (Thedaysortingcompleteflg.name().equals(name())) { return toClsList(CDef.Thedaysortingcompleteflg.listOf(codeList)); }
            if (Gooditemkbn.name().equals(name())) { return toClsList(CDef.Gooditemkbn.listOf(codeList)); }
            if (Slptyp.name().equals(name())) { return toClsList(CDef.Slptyp.listOf(codeList)); }
            if (SostatusForserch2.name().equals(name())) { return toClsList(CDef.SostatusForserch2.listOf(codeList)); }
            if (LineOrderKbn.name().equals(name())) { return toClsList(CDef.LineOrderKbn.listOf(codeList)); }
            if (Consolidationflg.name().equals(name())) { return toClsList(CDef.Consolidationflg.listOf(codeList)); }
            if (DaysOfWeek.name().equals(name())) { return toClsList(CDef.DaysOfWeek.listOf(codeList)); }
            if (Lockbn.name().equals(name())) { return toClsList(CDef.Lockbn.listOf(codeList)); }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return toClsList(CDef.ReplenishmentRoundedupUnit.listOf(codeList)); }
            if (Restockkbn.name().equals(name())) { return toClsList(CDef.Restockkbn.listOf(codeList)); }
            if (Zaikodiv.name().equals(name())) { return toClsList(CDef.Zaikodiv.listOf(codeList)); }
            if (Openflg.name().equals(name())) { return toClsList(CDef.Openflg.listOf(codeList)); }
            if (TodayPrintOnlyFlg.name().equals(name())) { return toClsList(CDef.TodayPrintOnlyFlg.listOf(codeList)); }
            if (StartEnd.name().equals(name())) { return toClsList(CDef.StartEnd.listOf(codeList)); }
            if (SyhnKbnJt.name().equals(name())) { return toClsList(CDef.SyhnKbnJt.listOf(codeList)); }
            if (Transkbn.name().equals(name())) { return toClsList(CDef.Transkbn.listOf(codeList)); }
            if (Carknd.name().equals(name())) { return toClsList(CDef.Carknd.listOf(codeList)); }
            if (Cartypecmb0tdisp.name().equals(name())) { return toClsList(CDef.Cartypecmb0tdisp.listOf(codeList)); }
            if (CenterPicListCls1.name().equals(name())) { return toClsList(CDef.CenterPicListCls1.listOf(codeList)); }
            if (CenterPicListCls2.name().equals(name())) { return toClsList(CDef.CenterPicListCls2.listOf(codeList)); }
            if (CenterPicListCls3.name().equals(name())) { return toClsList(CDef.CenterPicListCls3.listOf(codeList)); }
            if (CenterSagawaDelivTz.name().equals(name())) { return toClsList(CDef.CenterSagawaDelivTz.listOf(codeList)); }
            if (CenterTransportTypeItem.name().equals(name())) { return toClsList(CDef.CenterTransportTypeItem.listOf(codeList)); }
            if (CenterSlipShapeCd.name().equals(name())) { return toClsList(CDef.CenterSlipShapeCd.listOf(codeList)); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return toClsList(CDef.CenterTransportTypeSpeed.listOf(codeList)); }
            if (CenterSealType.name().equals(name())) { return toClsList(CDef.CenterSealType.listOf(codeList)); }
            if (CenterTagClass.name().equals(name())) { return toClsList(CDef.CenterTagClass.listOf(codeList)); }
            if (CenterTagDataType.name().equals(name())) { return toClsList(CDef.CenterTagDataType.listOf(codeList)); }
            if (CenterTagType.name().equals(name())) { return toClsList(CDef.CenterTagType.listOf(codeList)); }
            if (CenterTagTypeAfter.name().equals(name())) { return toClsList(CDef.CenterTagTypeAfter.listOf(codeList)); }
            if (CenterApiBinsyuCode.name().equals(name())) { return toClsList(CDef.CenterApiBinsyuCode.listOf(codeList)); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiFlg.listOf(codeList)); }
            if (CenterApiDaibikiType.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiType.listOf(codeList)); }
            if (CenterApiEidomeFlg.name().equals(name())) { return toClsList(CDef.CenterApiEidomeFlg.listOf(codeList)); }
            if (CenterApiWeightCd.name().equals(name())) { return toClsList(CDef.CenterApiWeightCd.listOf(codeList)); }
            if (CenterOutputTargetFlg.name().equals(name())) { return toClsList(CDef.CenterOutputTargetFlg.listOf(codeList)); }
            if (CenterPrintCondition.name().equals(name())) { return toClsList(CDef.CenterPrintCondition.listOf(codeList)); }
            if (CenterDesignflg.name().equals(name())) { return toClsList(CDef.CenterDesignflg.listOf(codeList)); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public List<Classification> groupOf(String groupName) { // old style
            if (ProcessTypeCd.name().equals(name())) { return toClsList(CDef.ProcessTypeCd.groupOf(groupName)); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return toClsList(CDef.AfterDelivSlipOutTgt.groupOf(groupName)); }
            if (AfterTagOutFlg.name().equals(name())) { return toClsList(CDef.AfterTagOutFlg.groupOf(groupName)); }
            if (AllcNgDisplay.name().equals(name())) { return toClsList(CDef.AllcNgDisplay.groupOf(groupName)); }
            if (AllcNgFlg.name().equals(name())) { return toClsList(CDef.AllcNgFlg.groupOf(groupName)); }
            if (AllocSortKey.name().equals(name())) { return toClsList(CDef.AllocSortKey.groupOf(groupName)); }
            if (AllShippingFlg.name().equals(name())) { return toClsList(CDef.AllShippingFlg.groupOf(groupName)); }
            if (ArrivalStoreFormat.name().equals(name())) { return toClsList(CDef.ArrivalStoreFormat.groupOf(groupName)); }
            if (AutoEmgSetFlg.name().equals(name())) { return toClsList(CDef.AutoEmgSetFlg.groupOf(groupName)); }
            if (AutoEmgSetTgt.name().equals(name())) { return toClsList(CDef.AutoEmgSetTgt.groupOf(groupName)); }
            if (AutoPrintTargetFlg.name().equals(name())) { return toClsList(CDef.AutoPrintTargetFlg.groupOf(groupName)); }
            if (AutoShipInstFlg.name().equals(name())) { return toClsList(CDef.AutoShipInstFlg.groupOf(groupName)); }
            if (BarcodeType.name().equals(name())) { return toClsList(CDef.BarcodeType.groupOf(groupName)); }
            if (BatchProgressFlg.name().equals(name())) { return toClsList(CDef.BatchProgressFlg.groupOf(groupName)); }
            if (BoxSelectSkip.name().equals(name())) { return toClsList(CDef.BoxSelectSkip.groupOf(groupName)); }
            if (CancelDataDisplay.name().equals(name())) { return toClsList(CDef.CancelDataDisplay.groupOf(groupName)); }
            if (CasePicFlg.name().equals(name())) { return toClsList(CDef.CasePicFlg.groupOf(groupName)); }
            if (CenterClientCls.name().equals(name())) { return toClsList(CDef.CenterClientCls.groupOf(groupName)); }
            if (CenterTransitFlg.name().equals(name())) { return toClsList(CDef.CenterTransitFlg.groupOf(groupName)); }
            if (CharacterCd.name().equals(name())) { return toClsList(CDef.CharacterCd.groupOf(groupName)); }
            if (ChargeQty0Display.name().equals(name())) { return toClsList(CDef.ChargeQty0Display.groupOf(groupName)); }
            if (CheckDigit.name().equals(name())) { return toClsList(CDef.CheckDigit.groupOf(groupName)); }
            if (CodeFlg.name().equals(name())) { return toClsList(CDef.CodeFlg.groupOf(groupName)); }
            if (CodeType.name().equals(name())) { return toClsList(CDef.CodeType.groupOf(groupName)); }
            if (CodCls.name().equals(name())) { return toClsList(CDef.CodCls.groupOf(groupName)); }
            if (CodType.name().equals(name())) { return toClsList(CDef.CodType.groupOf(groupName)); }
            if (ColType.name().equals(name())) { return toClsList(CDef.ColType.groupOf(groupName)); }
            if (CommentFlg.name().equals(name())) { return toClsList(CDef.CommentFlg.groupOf(groupName)); }
            if (CompanyFlg.name().equals(name())) { return toClsList(CDef.CompanyFlg.groupOf(groupName)); }
            if (CoolCls.name().equals(name())) { return toClsList(CDef.CoolCls.groupOf(groupName)); }
            if (CoolType.name().equals(name())) { return toClsList(CDef.CoolType.groupOf(groupName)); }
            if (CopyTargetTable.name().equals(name())) { return toClsList(CDef.CopyTargetTable.groupOf(groupName)); }
            if (CorrectType.name().equals(name())) { return toClsList(CDef.CorrectType.groupOf(groupName)); }
            if (DataInputCommitType.name().equals(name())) { return toClsList(CDef.DataInputCommitType.groupOf(groupName)); }
            if (DataInputOperationType.name().equals(name())) { return toClsList(CDef.DataInputOperationType.groupOf(groupName)); }
            if (DataInputProcessType.name().equals(name())) { return toClsList(CDef.DataInputProcessType.groupOf(groupName)); }
            if (DataInputRange.name().equals(name())) { return toClsList(CDef.DataInputRange.groupOf(groupName)); }
            if (DataInputType.name().equals(name())) { return toClsList(CDef.DataInputType.groupOf(groupName)); }
            if (DataType.name().equals(name())) { return toClsList(CDef.DataType.groupOf(groupName)); }
            if (Default.name().equals(name())) { return toClsList(CDef.Default.groupOf(groupName)); }
            if (DefaultFlg.name().equals(name())) { return toClsList(CDef.DefaultFlg.groupOf(groupName)); }
            if (DeleteDataDisplay.name().equals(name())) { return toClsList(CDef.DeleteDataDisplay.groupOf(groupName)); }
            if (DeliveryFlg.name().equals(name())) { return toClsList(CDef.DeliveryFlg.groupOf(groupName)); }
            if (DelivMatchFlg.name().equals(name())) { return toClsList(CDef.DelivMatchFlg.groupOf(groupName)); }
            if (DelivTz.name().equals(name())) { return toClsList(CDef.DelivTz.groupOf(groupName)); }
            if (DelFlg.name().equals(name())) { return toClsList(CDef.DelFlg.groupOf(groupName)); }
            if (DepositFlg.name().equals(name())) { return toClsList(CDef.DepositFlg.groupOf(groupName)); }
            if (DisplayRequired.name().equals(name())) { return toClsList(CDef.DisplayRequired.groupOf(groupName)); }
            if (DtCls.name().equals(name())) { return toClsList(CDef.DtCls.groupOf(groupName)); }
            if (Editable.name().equals(name())) { return toClsList(CDef.Editable.groupOf(groupName)); }
            if (EmergencyDisplay.name().equals(name())) { return toClsList(CDef.EmergencyDisplay.groupOf(groupName)); }
            if (EmergencyFlg.name().equals(name())) { return toClsList(CDef.EmergencyFlg.groupOf(groupName)); }
            if (ErrorFlg.name().equals(name())) { return toClsList(CDef.ErrorFlg.groupOf(groupName)); }
            if (ErrorProcessMet.name().equals(name())) { return toClsList(CDef.ErrorProcessMet.groupOf(groupName)); }
            if (FixedPoint.name().equals(name())) { return toClsList(CDef.FixedPoint.groupOf(groupName)); }
            if (ForceFixedFlg.name().equals(name())) { return toClsList(CDef.ForceFixedFlg.groupOf(groupName)); }
            if (ForeignFlg.name().equals(name())) { return toClsList(CDef.ForeignFlg.groupOf(groupName)); }
            if (GiftFlg.name().equals(name())) { return toClsList(CDef.GiftFlg.groupOf(groupName)); }
            if (GiftStatementType.name().equals(name())) { return toClsList(CDef.GiftStatementType.groupOf(groupName)); }
            if (HtCharReadFlg.name().equals(name())) { return toClsList(CDef.HtCharReadFlg.groupOf(groupName)); }
            if (ImportFlg.name().equals(name())) { return toClsList(CDef.ImportFlg.groupOf(groupName)); }
            if (InfoFlg.name().equals(name())) { return toClsList(CDef.InfoFlg.groupOf(groupName)); }
            if (InoutType.name().equals(name())) { return toClsList(CDef.InoutType.groupOf(groupName)); }
            if (InputType.name().equals(name())) { return toClsList(CDef.InputType.groupOf(groupName)); }
            if (InspectionFlg.name().equals(name())) { return toClsList(CDef.InspectionFlg.groupOf(groupName)); }
            if (InventoryLocationProduct.name().equals(name())) { return toClsList(CDef.InventoryLocationProduct.groupOf(groupName)); }
            if (InvoiceCreateFlg.name().equals(name())) { return toClsList(CDef.InvoiceCreateFlg.groupOf(groupName)); }
            if (ItemType.name().equals(name())) { return toClsList(CDef.ItemType.groupOf(groupName)); }
            if (LastFlg.name().equals(name())) { return toClsList(CDef.LastFlg.groupOf(groupName)); }
            if (LimitDtManagFlg.name().equals(name())) { return toClsList(CDef.LimitDtManagFlg.groupOf(groupName)); }
            if (LimitDtReverseFlg.name().equals(name())) { return toClsList(CDef.LimitDtReverseFlg.groupOf(groupName)); }
            if (LimitMessageCd.name().equals(name())) { return toClsList(CDef.LimitMessageCd.groupOf(groupName)); }
            if (LineFeedCd.name().equals(name())) { return toClsList(CDef.LineFeedCd.groupOf(groupName)); }
            if (ListOutFlg.name().equals(name())) { return toClsList(CDef.ListOutFlg.groupOf(groupName)); }
            if (ListOutFlgDisp.name().equals(name())) { return toClsList(CDef.ListOutFlgDisp.groupOf(groupName)); }
            if (ListOutKbn.name().equals(name())) { return toClsList(CDef.ListOutKbn.groupOf(groupName)); }
            if (LoadingFlg.name().equals(name())) { return toClsList(CDef.LoadingFlg.groupOf(groupName)); }
            if (LocationType.name().equals(name())) { return toClsList(CDef.LocationType.groupOf(groupName)); }
            if (Lockout.name().equals(name())) { return toClsList(CDef.Lockout.groupOf(groupName)); }
            if (LogDtlStatus.name().equals(name())) { return toClsList(CDef.LogDtlStatus.groupOf(groupName)); }
            if (LogDtlType.name().equals(name())) { return toClsList(CDef.LogDtlType.groupOf(groupName)); }
            if (LogStatus.name().equals(name())) { return toClsList(CDef.LogStatus.groupOf(groupName)); }
            if (LotManagFlg.name().equals(name())) { return toClsList(CDef.LotManagFlg.groupOf(groupName)); }
            if (LotReverseFlg.name().equals(name())) { return toClsList(CDef.LotReverseFlg.groupOf(groupName)); }
            if (MergeCls.name().equals(name())) { return toClsList(CDef.MergeCls.groupOf(groupName)); }
            if (MergeFlg.name().equals(name())) { return toClsList(CDef.MergeFlg.groupOf(groupName)); }
            if (MessageType.name().equals(name())) { return toClsList(CDef.MessageType.groupOf(groupName)); }
            if (MixedFlg.name().equals(name())) { return toClsList(CDef.MixedFlg.groupOf(groupName)); }
            if (MoveInstStatus.name().equals(name())) { return toClsList(CDef.MoveInstStatus.groupOf(groupName)); }
            if (MultiPicCls.name().equals(name())) { return toClsList(CDef.MultiPicCls.groupOf(groupName)); }
            if (MultiPicFlg.name().equals(name())) { return toClsList(CDef.MultiPicFlg.groupOf(groupName)); }
            if (Necessary.name().equals(name())) { return toClsList(CDef.Necessary.groupOf(groupName)); }
            if (NotCompletedFlg.name().equals(name())) { return toClsList(CDef.NotCompletedFlg.groupOf(groupName)); }
            if (NoAllcDisplayFlg.name().equals(name())) { return toClsList(CDef.NoAllcDisplayFlg.groupOf(groupName)); }
            if (NoConfirmedFlg.name().equals(name())) { return toClsList(CDef.NoConfirmedFlg.groupOf(groupName)); }
            if (NoStockCls.name().equals(name())) { return toClsList(CDef.NoStockCls.groupOf(groupName)); }
            if (NoStockOutFlg.name().equals(name())) { return toClsList(CDef.NoStockOutFlg.groupOf(groupName)); }
            if (NoUpsideDownCls.name().equals(name())) { return toClsList(CDef.NoUpsideDownCls.groupOf(groupName)); }
            if (OnetimeFlg.name().equals(name())) { return toClsList(CDef.OnetimeFlg.groupOf(groupName)); }
            if (OverStoreNumFlg.name().equals(name())) { return toClsList(CDef.OverStoreNumFlg.groupOf(groupName)); }
            if (PackingCalCls.name().equals(name())) { return toClsList(CDef.PackingCalCls.groupOf(groupName)); }
            if (PackingProcessCls.name().equals(name())) { return toClsList(CDef.PackingProcessCls.groupOf(groupName)); }
            if (PackingShowFlg.name().equals(name())) { return toClsList(CDef.PackingShowFlg.groupOf(groupName)); }
            if (PackingStatus.name().equals(name())) { return toClsList(CDef.PackingStatus.groupOf(groupName)); }
            if (PasswordReset.name().equals(name())) { return toClsList(CDef.PasswordReset.groupOf(groupName)); }
            if (PastStoreDtFlg.name().equals(name())) { return toClsList(CDef.PastStoreDtFlg.groupOf(groupName)); }
            if (PhysicalDelete.name().equals(name())) { return toClsList(CDef.PhysicalDelete.groupOf(groupName)); }
            if (PickingFlg.name().equals(name())) { return toClsList(CDef.PickingFlg.groupOf(groupName)); }
            if (PickingLocationFlg.name().equals(name())) { return toClsList(CDef.PickingLocationFlg.groupOf(groupName)); }
            if (PickingStatus.name().equals(name())) { return toClsList(CDef.PickingStatus.groupOf(groupName)); }
            if (PicCls.name().equals(name())) { return toClsList(CDef.PicCls.groupOf(groupName)); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return toClsList(CDef.PicMthdRcmdBreakKey.groupOf(groupName)); }
            if (PicMthdRcmdFlg.name().equals(name())) { return toClsList(CDef.PicMthdRcmdFlg.groupOf(groupName)); }
            if (PicMthdRcmdListOut.name().equals(name())) { return toClsList(CDef.PicMthdRcmdListOut.groupOf(groupName)); }
            if (PostType.name().equals(name())) { return toClsList(CDef.PostType.groupOf(groupName)); }
            if (PrintedFlg.name().equals(name())) { return toClsList(CDef.PrintedFlg.groupOf(groupName)); }
            if (PrintDataType.name().equals(name())) { return toClsList(CDef.PrintDataType.groupOf(groupName)); }
            if (PrintErrorFlg.name().equals(name())) { return toClsList(CDef.PrintErrorFlg.groupOf(groupName)); }
            if (PrintQueueStatus.name().equals(name())) { return toClsList(CDef.PrintQueueStatus.groupOf(groupName)); }
            if (PrintResultClass.name().equals(name())) { return toClsList(CDef.PrintResultClass.groupOf(groupName)); }
            if (PrintServiceStatus.name().equals(name())) { return toClsList(CDef.PrintServiceStatus.groupOf(groupName)); }
            if (PrintStatus.name().equals(name())) { return toClsList(CDef.PrintStatus.groupOf(groupName)); }
            if (PriorityFlg.name().equals(name())) { return toClsList(CDef.PriorityFlg.groupOf(groupName)); }
            if (ProductLabelJanBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelJanBarcode.groupOf(groupName)); }
            if (ProductLabelOutUnit.name().equals(name())) { return toClsList(CDef.ProductLabelOutUnit.groupOf(groupName)); }
            if (ProductLabelProdBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelProdBarcode.groupOf(groupName)); }
            if (ProductPartPacking.name().equals(name())) { return toClsList(CDef.ProductPartPacking.groupOf(groupName)); }
            if (ProductTypeCode.name().equals(name())) { return toClsList(CDef.ProductTypeCode.groupOf(groupName)); }
            if (Qty0Display.name().equals(name())) { return toClsList(CDef.Qty0Display.groupOf(groupName)); }
            if (ReasonType.name().equals(name())) { return toClsList(CDef.ReasonType.groupOf(groupName)); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return toClsList(CDef.ReceiveDeliveryStatus.groupOf(groupName)); }
            if (ReceiveFlg.name().equals(name())) { return toClsList(CDef.ReceiveFlg.groupOf(groupName)); }
            if (ReceiveStatus.name().equals(name())) { return toClsList(CDef.ReceiveStatus.groupOf(groupName)); }
            if (ReplenishAllocCls.name().equals(name())) { return toClsList(CDef.ReplenishAllocCls.groupOf(groupName)); }
            if (ReplenishProductCdUnset.name().equals(name())) { return toClsList(CDef.ReplenishProductCdUnset.groupOf(groupName)); }
            if (ReplenishSearchCls.name().equals(name())) { return toClsList(CDef.ReplenishSearchCls.groupOf(groupName)); }
            if (ReplenishUnitCls.name().equals(name())) { return toClsList(CDef.ReplenishUnitCls.groupOf(groupName)); }
            if (ReportLayoutItemType.name().equals(name())) { return toClsList(CDef.ReportLayoutItemType.groupOf(groupName)); }
            if (RestockType.name().equals(name())) { return toClsList(CDef.RestockType.groupOf(groupName)); }
            if (ResultAfterProductLabel.name().equals(name())) { return toClsList(CDef.ResultAfterProductLabel.groupOf(groupName)); }
            if (ResultAfterProductTarget.name().equals(name())) { return toClsList(CDef.ResultAfterProductTarget.groupOf(groupName)); }
            if (ReverseValidFlg.name().equals(name())) { return toClsList(CDef.ReverseValidFlg.groupOf(groupName)); }
            if (RoleControlClass.name().equals(name())) { return toClsList(CDef.RoleControlClass.groupOf(groupName)); }
            if (Select.name().equals(name())) { return toClsList(CDef.Select.groupOf(groupName)); }
            if (SelectPrintServiceStatus.name().equals(name())) { return toClsList(CDef.SelectPrintServiceStatus.groupOf(groupName)); }
            if (SerialOperationType.name().equals(name())) { return toClsList(CDef.SerialOperationType.groupOf(groupName)); }
            if (SettlementType.name().equals(name())) { return toClsList(CDef.SettlementType.groupOf(groupName)); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return toClsList(CDef.SglRowInspAfterOutCls.groupOf(groupName)); }
            if (SglRowPicFlg.name().equals(name())) { return toClsList(CDef.SglRowPicFlg.groupOf(groupName)); }
            if (SheetCollate.name().equals(name())) { return toClsList(CDef.SheetCollate.groupOf(groupName)); }
            if (ShippingFlg.name().equals(name())) { return toClsList(CDef.ShippingFlg.groupOf(groupName)); }
            if (ShippingStatus.name().equals(name())) { return toClsList(CDef.ShippingStatus.groupOf(groupName)); }
            if (ShippingStopFlg.name().equals(name())) { return toClsList(CDef.ShippingStopFlg.groupOf(groupName)); }
            if (ShortStockDisplay.name().equals(name())) { return toClsList(CDef.ShortStockDisplay.groupOf(groupName)); }
            if (ShpCheckCls.name().equals(name())) { return toClsList(CDef.ShpCheckCls.groupOf(groupName)); }
            if (ShpCheckDisplay.name().equals(name())) { return toClsList(CDef.ShpCheckDisplay.groupOf(groupName)); }
            if (SlipType.name().equals(name())) { return toClsList(CDef.SlipType.groupOf(groupName)); }
            if (SoundPlayFlg.name().equals(name())) { return toClsList(CDef.SoundPlayFlg.groupOf(groupName)); }
            if (StockAdjustFlg.name().equals(name())) { return toClsList(CDef.StockAdjustFlg.groupOf(groupName)); }
            if (StockDisplayFld.name().equals(name())) { return toClsList(CDef.StockDisplayFld.groupOf(groupName)); }
            if (StockExistOnlyFlg.name().equals(name())) { return toClsList(CDef.StockExistOnlyFlg.groupOf(groupName)); }
            if (StockMoveFlg.name().equals(name())) { return toClsList(CDef.StockMoveFlg.groupOf(groupName)); }
            if (StockNum0Display.name().equals(name())) { return toClsList(CDef.StockNum0Display.groupOf(groupName)); }
            if (StockOutAllocCls.name().equals(name())) { return toClsList(CDef.StockOutAllocCls.groupOf(groupName)); }
            if (StockOutAutoInstFlg.name().equals(name())) { return toClsList(CDef.StockOutAutoInstFlg.groupOf(groupName)); }
            if (StockOutFlg.name().equals(name())) { return toClsList(CDef.StockOutFlg.groupOf(groupName)); }
            if (StockOutInstCxlFlg.name().equals(name())) { return toClsList(CDef.StockOutInstCxlFlg.groupOf(groupName)); }
            if (StockOutInstSplitFlg.name().equals(name())) { return toClsList(CDef.StockOutInstSplitFlg.groupOf(groupName)); }
            if (StockQtyDisplay.name().equals(name())) { return toClsList(CDef.StockQtyDisplay.groupOf(groupName)); }
            if (StockTakingInput.name().equals(name())) { return toClsList(CDef.StockTakingInput.groupOf(groupName)); }
            if (StockTarget.name().equals(name())) { return toClsList(CDef.StockTarget.groupOf(groupName)); }
            if (StoreDtFlg.name().equals(name())) { return toClsList(CDef.StoreDtFlg.groupOf(groupName)); }
            if (StoreFlg.name().equals(name())) { return toClsList(CDef.StoreFlg.groupOf(groupName)); }
            if (StoreNoDivideDisplay.name().equals(name())) { return toClsList(CDef.StoreNoDivideDisplay.groupOf(groupName)); }
            if (StoreNoFlg.name().equals(name())) { return toClsList(CDef.StoreNoFlg.groupOf(groupName)); }
            if (StoreNoMergeFlg.name().equals(name())) { return toClsList(CDef.StoreNoMergeFlg.groupOf(groupName)); }
            if (SystemLogStatus.name().equals(name())) { return toClsList(CDef.SystemLogStatus.groupOf(groupName)); }
            if (SystemLogType.name().equals(name())) { return toClsList(CDef.SystemLogType.groupOf(groupName)); }
            if (SystemType.name().equals(name())) { return toClsList(CDef.SystemType.groupOf(groupName)); }
            if (TagDeliveryOutFlg.name().equals(name())) { return toClsList(CDef.TagDeliveryOutFlg.groupOf(groupName)); }
            if (TakingShippingDtFlg.name().equals(name())) { return toClsList(CDef.TakingShippingDtFlg.groupOf(groupName)); }
            if (TakingShippingFlg.name().equals(name())) { return toClsList(CDef.TakingShippingFlg.groupOf(groupName)); }
            if (TargetWindow.name().equals(name())) { return toClsList(CDef.TargetWindow.groupOf(groupName)); }
            if (TextAlign.name().equals(name())) { return toClsList(CDef.TextAlign.groupOf(groupName)); }
            if (TotalPicFlg.name().equals(name())) { return toClsList(CDef.TotalPicFlg.groupOf(groupName)); }
            if (TrackingNumberingUnit.name().equals(name())) { return toClsList(CDef.TrackingNumberingUnit.groupOf(groupName)); }
            if (TransitDisplay.name().equals(name())) { return toClsList(CDef.TransitDisplay.groupOf(groupName)); }
            if (Unmatch.name().equals(name())) { return toClsList(CDef.Unmatch.groupOf(groupName)); }
            if (Updatable.name().equals(name())) { return toClsList(CDef.Updatable.groupOf(groupName)); }
            if (UpdCd.name().equals(name())) { return toClsList(CDef.UpdCd.groupOf(groupName)); }
            if (UpdType.name().equals(name())) { return toClsList(CDef.UpdType.groupOf(groupName)); }
            if (UploadTableNm.name().equals(name())) { return toClsList(CDef.UploadTableNm.groupOf(groupName)); }
            if (UserEditable.name().equals(name())) { return toClsList(CDef.UserEditable.groupOf(groupName)); }
            if (UseHtShipFlg.name().equals(name())) { return toClsList(CDef.UseHtShipFlg.groupOf(groupName)); }
            if (VendorFlg.name().equals(name())) { return toClsList(CDef.VendorFlg.groupOf(groupName)); }
            if (Visible.name().equals(name())) { return toClsList(CDef.Visible.groupOf(groupName)); }
            if (WorkFlg.name().equals(name())) { return toClsList(CDef.WorkFlg.groupOf(groupName)); }
            if (WorkMessageFlg.name().equals(name())) { return toClsList(CDef.WorkMessageFlg.groupOf(groupName)); }
            if (YamatoDelivTz.name().equals(name())) { return toClsList(CDef.YamatoDelivTz.groupOf(groupName)); }
            if (YupackDelivTz.name().equals(name())) { return toClsList(CDef.YupackDelivTz.groupOf(groupName)); }
            if (ZipFlg.name().equals(name())) { return toClsList(CDef.ZipFlg.groupOf(groupName)); }
            if (AttendanceLeavingRest.name().equals(name())) { return toClsList(CDef.AttendanceLeavingRest.groupOf(groupName)); }
            if (BolOutputTargetFlg.name().equals(name())) { return toClsList(CDef.BolOutputTargetFlg.groupOf(groupName)); }
            if (BolOutFlg.name().equals(name())) { return toClsList(CDef.BolOutFlg.groupOf(groupName)); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return toClsList(CDef.CallBeforeDeliveryFlg.groupOf(groupName)); }
            if (CasePickFlg.name().equals(name())) { return toClsList(CDef.CasePickFlg.groupOf(groupName)); }
            if (CasePicTarget.name().equals(name())) { return toClsList(CDef.CasePicTarget.groupOf(groupName)); }
            if (CesIntegrationFlg.name().equals(name())) { return toClsList(CDef.CesIntegrationFlg.groupOf(groupName)); }
            if (CodFlg.name().equals(name())) { return toClsList(CDef.CodFlg.groupOf(groupName)); }
            if (DecimalExistFlg.name().equals(name())) { return toClsList(CDef.DecimalExistFlg.groupOf(groupName)); }
            if (DecimalProductPacking.name().equals(name())) { return toClsList(CDef.DecimalProductPacking.groupOf(groupName)); }
            if (DoNotStackStackFlg.name().equals(name())) { return toClsList(CDef.DoNotStackStackFlg.groupOf(groupName)); }
            if (EmReplenishShapeFlg.name().equals(name())) { return toClsList(CDef.EmReplenishShapeFlg.groupOf(groupName)); }
            if (FoogFlg.name().equals(name())) { return toClsList(CDef.FoogFlg.groupOf(groupName)); }
            if (FreezableProtectionFlg.name().equals(name())) { return toClsList(CDef.FreezableProtectionFlg.groupOf(groupName)); }
            if (FreightCls.name().equals(name())) { return toClsList(CDef.FreightCls.groupOf(groupName)); }
            if (GuaranteedPlusFlg.name().equals(name())) { return toClsList(CDef.GuaranteedPlusFlg.groupOf(groupName)); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryCollectFlg.groupOf(groupName)); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryPrepaidFlg.groupOf(groupName)); }
            if (InsidePickupCollectFlg.name().equals(name())) { return toClsList(CDef.InsidePickupCollectFlg.groupOf(groupName)); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsidePickupPrepaidFlg.groupOf(groupName)); }
            if (InspectionLabelOutFlg.name().equals(name())) { return toClsList(CDef.InspectionLabelOutFlg.groupOf(groupName)); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryCollectFlg.groupOf(groupName)); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryPrepaidFlg.groupOf(groupName)); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupCollectFlg.groupOf(groupName)); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupPrepaidFlg.groupOf(groupName)); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessDeliveryFlg.groupOf(groupName)); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessPickupFlg.groupOf(groupName)); }
            if (OverSizedFlg.name().equals(name())) { return toClsList(CDef.OverSizedFlg.groupOf(groupName)); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return toClsList(CDef.PackingSlipAutoOutputFlg.groupOf(groupName)); }
            if (PaymentTerm.name().equals(name())) { return toClsList(CDef.PaymentTerm.groupOf(groupName)); }
            if (PickingType.name().equals(name())) { return toClsList(CDef.PickingType.groupOf(groupName)); }
            if (PoisonFlg.name().equals(name())) { return toClsList(CDef.PoisonFlg.groupOf(groupName)); }
            if (RcmdPickingCls.name().equals(name())) { return toClsList(CDef.RcmdPickingCls.groupOf(groupName)); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return toClsList(CDef.ResidentialDeliveryFlg.groupOf(groupName)); }
            if (ResidentialPickupFlg.name().equals(name())) { return toClsList(CDef.ResidentialPickupFlg.groupOf(groupName)); }
            if (SatDeliveryFlg.name().equals(name())) { return toClsList(CDef.SatDeliveryFlg.groupOf(groupName)); }
            if (SglRowPicTarget.name().equals(name())) { return toClsList(CDef.SglRowPicTarget.groupOf(groupName)); }
            if (SignatureReleaseFlg.name().equals(name())) { return toClsList(CDef.SignatureReleaseFlg.groupOf(groupName)); }
            if (SignatureRequiredFlg.name().equals(name())) { return toClsList(CDef.SignatureRequiredFlg.groupOf(groupName)); }
            if (UploadZipType.name().equals(name())) { return toClsList(CDef.UploadZipType.groupOf(groupName)); }
            if (WorkLogOutFlg.name().equals(name())) { return toClsList(CDef.WorkLogOutFlg.groupOf(groupName)); }
            if (WorkStatus.name().equals(name())) { return toClsList(CDef.WorkStatus.groupOf(groupName)); }
            if (Adjuststatus.name().equals(name())) { return toClsList(CDef.Adjuststatus.groupOf(groupName)); }
            if (Companygroup.name().equals(name())) { return toClsList(CDef.Companygroup.groupOf(groupName)); }
            if (LocGroup.name().equals(name())) { return toClsList(CDef.LocGroup.groupOf(groupName)); }
            if (Worktype.name().equals(name())) { return toClsList(CDef.Worktype.groupOf(groupName)); }
            if (Capitemflg.name().equals(name())) { return toClsList(CDef.Capitemflg.groupOf(groupName)); }
            if (Palletests.name().equals(name())) { return toClsList(CDef.Palletests.groupOf(groupName)); }
            if (Usid.name().equals(name())) { return toClsList(CDef.Usid.groupOf(groupName)); }
            if (Itemusedflg.name().equals(name())) { return toClsList(CDef.Itemusedflg.groupOf(groupName)); }
            if (Symbolsts.name().equals(name())) { return toClsList(CDef.Symbolsts.groupOf(groupName)); }
            if (Solistkbn.name().equals(name())) { return toClsList(CDef.Solistkbn.groupOf(groupName)); }
            if (Palletaddflg.name().equals(name())) { return toClsList(CDef.Palletaddflg.groupOf(groupName)); }
            if (Productdiv.name().equals(name())) { return toClsList(CDef.Productdiv.groupOf(groupName)); }
            if (Soroutediv.name().equals(name())) { return toClsList(CDef.Soroutediv.groupOf(groupName)); }
            if (Requesttype.name().equals(name())) { return toClsList(CDef.Requesttype.groupOf(groupName)); }
            if (Examsts.name().equals(name())) { return toClsList(CDef.Examsts.groupOf(groupName)); }
            if (Ordernoaddcd.name().equals(name())) { return toClsList(CDef.Ordernoaddcd.groupOf(groupName)); }
            if (Tracetype.name().equals(name())) { return toClsList(CDef.Tracetype.groupOf(groupName)); }
            if (Warehouseid.name().equals(name())) { return toClsList(CDef.Warehouseid.groupOf(groupName)); }
            if (Markettype.name().equals(name())) { return toClsList(CDef.Markettype.groupOf(groupName)); }
            if (Reservationflg.name().equals(name())) { return toClsList(CDef.Reservationflg.groupOf(groupName)); }
            if (Packingtype.name().equals(name())) { return toClsList(CDef.Packingtype.groupOf(groupName)); }
            if (Productmarkptn.name().equals(name())) { return toClsList(CDef.Productmarkptn.groupOf(groupName)); }
            if (Productmarkptnbatj.name().equals(name())) { return toClsList(CDef.Productmarkptnbatj.groupOf(groupName)); }
            if (Productmarkmonth.name().equals(name())) { return toClsList(CDef.Productmarkmonth.groupOf(groupName)); }
            if (Limitdatemonth.name().equals(name())) { return toClsList(CDef.Limitdatemonth.groupOf(groupName)); }
            if (Alclimitdatemonth.name().equals(name())) { return toClsList(CDef.Alclimitdatemonth.groupOf(groupName)); }
            if (Labellayoutmaster.name().equals(name())) { return toClsList(CDef.Labellayoutmaster.groupOf(groupName)); }
            if (Trafficpattern.name().equals(name())) { return toClsList(CDef.Trafficpattern.groupOf(groupName)); }
            if (Cgrid.name().equals(name())) { return toClsList(CDef.Cgrid.groupOf(groupName)); }
            if (Reportname.name().equals(name())) { return toClsList(CDef.Reportname.groupOf(groupName)); }
            if (Jyokenflg.name().equals(name())) { return toClsList(CDef.Jyokenflg.groupOf(groupName)); }
            if (Imshiptocode.name().equals(name())) { return toClsList(CDef.Imshiptocode.groupOf(groupName)); }
            if (Fileinfo.name().equals(name())) { return toClsList(CDef.Fileinfo.groupOf(groupName)); }
            if (Shiptocdchg.name().equals(name())) { return toClsList(CDef.Shiptocdchg.groupOf(groupName)); }
            if (Tdwmscd.name().equals(name())) { return toClsList(CDef.Tdwmscd.groupOf(groupName)); }
            if (Inoutdatatype.name().equals(name())) { return toClsList(CDef.Inoutdatatype.groupOf(groupName)); }
            if (Invmoveterm.name().equals(name())) { return toClsList(CDef.Invmoveterm.groupOf(groupName)); }
            if (Symbolsendhulftmaster.name().equals(name())) { return toClsList(CDef.Symbolsendhulftmaster.groupOf(groupName)); }
            if (Logflag.name().equals(name())) { return toClsList(CDef.Logflag.groupOf(groupName)); }
            if (Assortmentsts.name().equals(name())) { return toClsList(CDef.Assortmentsts.groupOf(groupName)); }
            if (Assortmentflg.name().equals(name())) { return toClsList(CDef.Assortmentflg.groupOf(groupName)); }
            if (Aststsforsearch.name().equals(name())) { return toClsList(CDef.Aststsforsearch.groupOf(groupName)); }
            if (Firstexamsendflg.name().equals(name())) { return toClsList(CDef.Firstexamsendflg.groupOf(groupName)); }
            if (Mossendflg.name().equals(name())) { return toClsList(CDef.Mossendflg.groupOf(groupName)); }
            if (Casecreatetype.name().equals(name())) { return toClsList(CDef.Casecreatetype.groupOf(groupName)); }
            if (Mosjtsendflg.name().equals(name())) { return toClsList(CDef.Mosjtsendflg.groupOf(groupName)); }
            if (Batkeepwarehousecd.name().equals(name())) { return toClsList(CDef.Batkeepwarehousecd.groupOf(groupName)); }
            if (Batwarehousecd.name().equals(name())) { return toClsList(CDef.Batwarehousecd.groupOf(groupName)); }
            if (Datamakeflg.name().equals(name())) { return toClsList(CDef.Datamakeflg.groupOf(groupName)); }
            if (Rcvresultqtytype.name().equals(name())) { return toClsList(CDef.Rcvresultqtytype.groupOf(groupName)); }
            if (Qualityexamflg.name().equals(name())) { return toClsList(CDef.Qualityexamflg.groupOf(groupName)); }
            if (Makercasecodefixedvalue.name().equals(name())) { return toClsList(CDef.Makercasecodefixedvalue.groupOf(groupName)); }
            if (Productmarkjttaxfree.name().equals(name())) { return toClsList(CDef.Productmarkjttaxfree.groupOf(groupName)); }
            if (PrinterdefS011.name().equals(name())) { return toClsList(CDef.PrinterdefS011.groupOf(groupName)); }
            if (PrinterdefS012.name().equals(name())) { return toClsList(CDef.PrinterdefS012.groupOf(groupName)); }
            if (PrinterdefN002.name().equals(name())) { return toClsList(CDef.PrinterdefN002.groupOf(groupName)); }
            if (PrinterdefZ005.name().equals(name())) { return toClsList(CDef.PrinterdefZ005.groupOf(groupName)); }
            if (Sortstockkbn.name().equals(name())) { return toClsList(CDef.Sortstockkbn.groupOf(groupName)); }
            if (Tracetypedt.name().equals(name())) { return toClsList(CDef.Tracetypedt.groupOf(groupName)); }
            if (Racklabelprflg.name().equals(name())) { return toClsList(CDef.Racklabelprflg.groupOf(groupName)); }
            if (PrinterdefS0031.name().equals(name())) { return toClsList(CDef.PrinterdefS0031.groupOf(groupName)); }
            if (PrinterdefS0032.name().equals(name())) { return toClsList(CDef.PrinterdefS0032.groupOf(groupName)); }
            if (PrinterdefS0033.name().equals(name())) { return toClsList(CDef.PrinterdefS0033.groupOf(groupName)); }
            if (PrinterdefS0034.name().equals(name())) { return toClsList(CDef.PrinterdefS0034.groupOf(groupName)); }
            if (Unknowncaselimit.name().equals(name())) { return toClsList(CDef.Unknowncaselimit.groupOf(groupName)); }
            if (Sortinvkbn.name().equals(name())) { return toClsList(CDef.Sortinvkbn.groupOf(groupName)); }
            if (Cloudcasenum.name().equals(name())) { return toClsList(CDef.Cloudcasenum.groupOf(groupName)); }
            if (Pulltype.name().equals(name())) { return toClsList(CDef.Pulltype.groupOf(groupName)); }
            if (Storageloc.name().equals(name())) { return toClsList(CDef.Storageloc.groupOf(groupName)); }
            if (Pallettracetype.name().equals(name())) { return toClsList(CDef.Pallettracetype.groupOf(groupName)); }
            if (Datasendtype.name().equals(name())) { return toClsList(CDef.Datasendtype.groupOf(groupName)); }
            if (Tracecreatests.name().equals(name())) { return toClsList(CDef.Tracecreatests.groupOf(groupName)); }
            if (Sortinvtiming.name().equals(name())) { return toClsList(CDef.Sortinvtiming.groupOf(groupName)); }
            if (Casesupplytype.name().equals(name())) { return toClsList(CDef.Casesupplytype.groupOf(groupName)); }
            if (Importumu.name().equals(name())) { return toClsList(CDef.Importumu.groupOf(groupName)); }
            if (Traceshiftflg.name().equals(name())) { return toClsList(CDef.Traceshiftflg.groupOf(groupName)); }
            if (Shtypecd.name().equals(name())) { return toClsList(CDef.Shtypecd.groupOf(groupName)); }
            if (Allocpolicy.name().equals(name())) { return toClsList(CDef.Allocpolicy.groupOf(groupName)); }
            if (Rtncompanyname.name().equals(name())) { return toClsList(CDef.Rtncompanyname.groupOf(groupName)); }
            if (Opendiff.name().equals(name())) { return toClsList(CDef.Opendiff.groupOf(groupName)); }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return toClsList(CDef.ItemcdlookupAvailableflg.groupOf(groupName)); }
            if (Flexpickprflg.name().equals(name())) { return toClsList(CDef.Flexpickprflg.groupOf(groupName)); }
            if (WorkmasterExp.name().equals(name())) { return toClsList(CDef.WorkmasterExp.groupOf(groupName)); }
            if (Tasktype.name().equals(name())) { return toClsList(CDef.Tasktype.groupOf(groupName)); }
            if (Tasktypedetail.name().equals(name())) { return toClsList(CDef.Tasktypedetail.groupOf(groupName)); }
            if (Yztraceshiftflg.name().equals(name())) { return toClsList(CDef.Yztraceshiftflg.groupOf(groupName)); }
            if (Workercdsearchtype.name().equals(name())) { return toClsList(CDef.Workercdsearchtype.groupOf(groupName)); }
            if (PrinterdefZ004.name().equals(name())) { return toClsList(CDef.PrinterdefZ004.groupOf(groupName)); }
            if (PrinterdefZ008.name().equals(name())) { return toClsList(CDef.PrinterdefZ008.groupOf(groupName)); }
            if (Pickdistname.name().equals(name())) { return toClsList(CDef.Pickdistname.groupOf(groupName)); }
            if (Traceswitchflg.name().equals(name())) { return toClsList(CDef.Traceswitchflg.groupOf(groupName)); }
            if (Lblkbn.name().equals(name())) { return toClsList(CDef.Lblkbn.groupOf(groupName)); }
            if (Assortkbn.name().equals(name())) { return toClsList(CDef.Assortkbn.groupOf(groupName)); }
            if (Dmycasecd.name().equals(name())) { return toClsList(CDef.Dmycasecd.groupOf(groupName)); }
            if (Baditemdelkbn.name().equals(name())) { return toClsList(CDef.Baditemdelkbn.groupOf(groupName)); }
            if (Selectlimit.name().equals(name())) { return toClsList(CDef.Selectlimit.groupOf(groupName)); }
            if (PrinterdefW001.name().equals(name())) { return toClsList(CDef.PrinterdefW001.groupOf(groupName)); }
            if (PrinterdefW002.name().equals(name())) { return toClsList(CDef.PrinterdefW002.groupOf(groupName)); }
            if (Settlementinvmonth.name().equals(name())) { return toClsList(CDef.Settlementinvmonth.groupOf(groupName)); }
            if (Flexinstructsts.name().equals(name())) { return toClsList(CDef.Flexinstructsts.groupOf(groupName)); }
            if (Compulsionflg.name().equals(name())) { return toClsList(CDef.Compulsionflg.groupOf(groupName)); }
            if (Displaymonth.name().equals(name())) { return toClsList(CDef.Displaymonth.groupOf(groupName)); }
            if (Sufferusagesearchflg.name().equals(name())) { return toClsList(CDef.Sufferusagesearchflg.groupOf(groupName)); }
            if (Fltstdinv.name().equals(name())) { return toClsList(CDef.Fltstdinv.groupOf(groupName)); }
            if (Cs3switchflg.name().equals(name())) { return toClsList(CDef.Cs3switchflg.groupOf(groupName)); }
            if (Inadequacyarea.name().equals(name())) { return toClsList(CDef.Inadequacyarea.groupOf(groupName)); }
            if (Transmitflg.name().equals(name())) { return toClsList(CDef.Transmitflg.groupOf(groupName)); }
            if (Flalterflg.name().equals(name())) { return toClsList(CDef.Flalterflg.groupOf(groupName)); }
            if (Invsts.name().equals(name())) { return toClsList(CDef.Invsts.groupOf(groupName)); }
            if (Concurrentbase.name().equals(name())) { return toClsList(CDef.Concurrentbase.groupOf(groupName)); }
            if (Concurrentname.name().equals(name())) { return toClsList(CDef.Concurrentname.groupOf(groupName)); }
            if (Caseshipstatus.name().equals(name())) { return toClsList(CDef.Caseshipstatus.groupOf(groupName)); }
            if (Ngpitemcd.name().equals(name())) { return toClsList(CDef.Ngpitemcd.groupOf(groupName)); }
            if (Fzloccd.name().equals(name())) { return toClsList(CDef.Fzloccd.groupOf(groupName)); }
            if (Whsortinvkbn.name().equals(name())) { return toClsList(CDef.Whsortinvkbn.groupOf(groupName)); }
            if (Syncreportform.name().equals(name())) { return toClsList(CDef.Syncreportform.groupOf(groupName)); }
            if (Sortwarehousecd.name().equals(name())) { return toClsList(CDef.Sortwarehousecd.groupOf(groupName)); }
            if (Hozeiwarehousecd.name().equals(name())) { return toClsList(CDef.Hozeiwarehousecd.groupOf(groupName)); }
            if (PrinterdefH002.name().equals(name())) { return toClsList(CDef.PrinterdefH002.groupOf(groupName)); }
            if (Reportformname.name().equals(name())) { return toClsList(CDef.Reportformname.groupOf(groupName)); }
            if (Taskname.name().equals(name())) { return toClsList(CDef.Taskname.groupOf(groupName)); }
            if (Whinvkbn.name().equals(name())) { return toClsList(CDef.Whinvkbn.groupOf(groupName)); }
            if (Procflg.name().equals(name())) { return toClsList(CDef.Procflg.groupOf(groupName)); }
            if (SyhnKbn.name().equals(name())) { return toClsList(CDef.SyhnKbn.groupOf(groupName)); }
            if (Pallettype.name().equals(name())) { return toClsList(CDef.Pallettype.groupOf(groupName)); }
            if (InventoryInstKbn.name().equals(name())) { return toClsList(CDef.InventoryInstKbn.groupOf(groupName)); }
            if (InventoryReport.name().equals(name())) { return toClsList(CDef.InventoryReport.groupOf(groupName)); }
            if (Completeflg.name().equals(name())) { return toClsList(CDef.Completeflg.groupOf(groupName)); }
            if (Oneitemonlyflg.name().equals(name())) { return toClsList(CDef.Oneitemonlyflg.groupOf(groupName)); }
            if (Oneowneronlyflg.name().equals(name())) { return toClsList(CDef.Oneowneronlyflg.groupOf(groupName)); }
            if (Picktype.name().equals(name())) { return toClsList(CDef.Picktype.groupOf(groupName)); }
            if (Rcvtype.name().equals(name())) { return toClsList(CDef.Rcvtype.groupOf(groupName)); }
            if (Slottype.name().equals(name())) { return toClsList(CDef.Slottype.groupOf(groupName)); }
            if (Capselect.name().equals(name())) { return toClsList(CDef.Capselect.groupOf(groupName)); }
            if (Kashikokuzeikubn.name().equals(name())) { return toClsList(CDef.Kashikokuzeikubn.groupOf(groupName)); }
            if (Instructflg.name().equals(name())) { return toClsList(CDef.Instructflg.groupOf(groupName)); }
            if (Palleteoutputtype.name().equals(name())) { return toClsList(CDef.Palleteoutputtype.groupOf(groupName)); }
            if (Palletecuttingkbn.name().equals(name())) { return toClsList(CDef.Palletecuttingkbn.groupOf(groupName)); }
            if (Frontrackcd.name().equals(name())) { return toClsList(CDef.Frontrackcd.groupOf(groupName)); }
            if (Sufferflg.name().equals(name())) { return toClsList(CDef.Sufferflg.groupOf(groupName)); }
            if (Unmatchflg.name().equals(name())) { return toClsList(CDef.Unmatchflg.groupOf(groupName)); }
            if (Alcimrsnflg.name().equals(name())) { return toClsList(CDef.Alcimrsnflg.groupOf(groupName)); }
            if (Manyfewoccurarea.name().equals(name())) { return toClsList(CDef.Manyfewoccurarea.groupOf(groupName)); }
            if (Manyfewoccurareadisp.name().equals(name())) { return toClsList(CDef.Manyfewoccurareadisp.groupOf(groupName)); }
            if (Designchg.name().equals(name())) { return toClsList(CDef.Designchg.groupOf(groupName)); }
            if (Differenceumu.name().equals(name())) { return toClsList(CDef.Differenceumu.groupOf(groupName)); }
            if (Stockdistinction.name().equals(name())) { return toClsList(CDef.Stockdistinction.groupOf(groupName)); }
            if (Workmaster.name().equals(name())) { return toClsList(CDef.Workmaster.groupOf(groupName)); }
            if (Picklisttype.name().equals(name())) { return toClsList(CDef.Picklisttype.groupOf(groupName)); }
            if (Sortzaikbn.name().equals(name())) { return toClsList(CDef.Sortzaikbn.groupOf(groupName)); }
            if (Sorttype.name().equals(name())) { return toClsList(CDef.Sorttype.groupOf(groupName)); }
            if (Exchgmethod.name().equals(name())) { return toClsList(CDef.Exchgmethod.groupOf(groupName)); }
            if (Conditionflg.name().equals(name())) { return toClsList(CDef.Conditionflg.groupOf(groupName)); }
            if (Qtyadjustflg.name().equals(name())) { return toClsList(CDef.Qtyadjustflg.groupOf(groupName)); }
            if (Inoutcode.name().equals(name())) { return toClsList(CDef.Inoutcode.groupOf(groupName)); }
            if (Inventorytype.name().equals(name())) { return toClsList(CDef.Inventorytype.groupOf(groupName)); }
            if (Attensionflg.name().equals(name())) { return toClsList(CDef.Attensionflg.groupOf(groupName)); }
            if (Formdiffflg.name().equals(name())) { return toClsList(CDef.Formdiffflg.groupOf(groupName)); }
            if (Timingtype.name().equals(name())) { return toClsList(CDef.Timingtype.groupOf(groupName)); }
            if (Fcflg.name().equals(name())) { return toClsList(CDef.Fcflg.groupOf(groupName)); }
            if (SundayFlg.name().equals(name())) { return toClsList(CDef.SundayFlg.groupOf(groupName)); }
            if (Pluralproductionkbn.name().equals(name())) { return toClsList(CDef.Pluralproductionkbn.groupOf(groupName)); }
            if (Changeflg.name().equals(name())) { return toClsList(CDef.Changeflg.groupOf(groupName)); }
            if (Rtnstatus.name().equals(name())) { return toClsList(CDef.Rtnstatus.groupOf(groupName)); }
            if (Rtninspestatus.name().equals(name())) { return toClsList(CDef.Rtninspestatus.groupOf(groupName)); }
            if (Inventoryref.name().equals(name())) { return toClsList(CDef.Inventoryref.groupOf(groupName)); }
            if (Restockflg.name().equals(name())) { return toClsList(CDef.Restockflg.groupOf(groupName)); }
            if (Validtype.name().equals(name())) { return toClsList(CDef.Validtype.groupOf(groupName)); }
            if (Rtnchangedivision.name().equals(name())) { return toClsList(CDef.Rtnchangedivision.groupOf(groupName)); }
            if (Storagearea.name().equals(name())) { return toClsList(CDef.Storagearea.groupOf(groupName)); }
            if (Maxinvflg.name().equals(name())) { return toClsList(CDef.Maxinvflg.groupOf(groupName)); }
            if (Horyukbn.name().equals(name())) { return toClsList(CDef.Horyukbn.groupOf(groupName)); }
            if (Useflg.name().equals(name())) { return toClsList(CDef.Useflg.groupOf(groupName)); }
            if (Fckokuflg.name().equals(name())) { return toClsList(CDef.Fckokuflg.groupOf(groupName)); }
            if (Bowltypeflg.name().equals(name())) { return toClsList(CDef.Bowltypeflg.groupOf(groupName)); }
            if (Inventoryrefdisp.name().equals(name())) { return toClsList(CDef.Inventoryrefdisp.groupOf(groupName)); }
            if (Flinstrstatus.name().equals(name())) { return toClsList(CDef.Flinstrstatus.groupOf(groupName)); }
            if (Flexstatus.name().equals(name())) { return toClsList(CDef.Flexstatus.groupOf(groupName)); }
            if (Distributioncd.name().equals(name())) { return toClsList(CDef.Distributioncd.groupOf(groupName)); }
            if (Stocklocation.name().equals(name())) { return toClsList(CDef.Stocklocation.groupOf(groupName)); }
            if (ResultStatus.name().equals(name())) { return toClsList(CDef.ResultStatus.groupOf(groupName)); }
            if (BoxCategory.name().equals(name())) { return toClsList(CDef.BoxCategory.groupOf(groupName)); }
            if (Storagewarehousecd.name().equals(name())) { return toClsList(CDef.Storagewarehousecd.groupOf(groupName)); }
            if (Salestype.name().equals(name())) { return toClsList(CDef.Salestype.groupOf(groupName)); }
            if (Solistkbn2.name().equals(name())) { return toClsList(CDef.Solistkbn2.groupOf(groupName)); }
            if (PickingListType.name().equals(name())) { return toClsList(CDef.PickingListType.groupOf(groupName)); }
            if (CoveredClass.name().equals(name())) { return toClsList(CDef.CoveredClass.groupOf(groupName)); }
            if (NotCoveredClass.name().equals(name())) { return toClsList(CDef.NotCoveredClass.groupOf(groupName)); }
            if (PickingWorkStatus.name().equals(name())) { return toClsList(CDef.PickingWorkStatus.groupOf(groupName)); }
            if (ReprintedFlg.name().equals(name())) { return toClsList(CDef.ReprintedFlg.groupOf(groupName)); }
            if (Cggdid.name().equals(name())) { return toClsList(CDef.Cggdid.groupOf(groupName)); }
            if (RcvPlanSts.name().equals(name())) { return toClsList(CDef.RcvPlanSts.groupOf(groupName)); }
            if (Virtuallocflg.name().equals(name())) { return toClsList(CDef.Virtuallocflg.groupOf(groupName)); }
            if (SufferUsageFlg.name().equals(name())) { return toClsList(CDef.SufferUsageFlg.groupOf(groupName)); }
            if (Thedaysortingcompleteflg.name().equals(name())) { return toClsList(CDef.Thedaysortingcompleteflg.groupOf(groupName)); }
            if (Gooditemkbn.name().equals(name())) { return toClsList(CDef.Gooditemkbn.groupOf(groupName)); }
            if (Slptyp.name().equals(name())) { return toClsList(CDef.Slptyp.groupOf(groupName)); }
            if (SostatusForserch2.name().equals(name())) { return toClsList(CDef.SostatusForserch2.groupOf(groupName)); }
            if (LineOrderKbn.name().equals(name())) { return toClsList(CDef.LineOrderKbn.groupOf(groupName)); }
            if (Consolidationflg.name().equals(name())) { return toClsList(CDef.Consolidationflg.groupOf(groupName)); }
            if (DaysOfWeek.name().equals(name())) { return toClsList(CDef.DaysOfWeek.groupOf(groupName)); }
            if (Lockbn.name().equals(name())) { return toClsList(CDef.Lockbn.groupOf(groupName)); }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return toClsList(CDef.ReplenishmentRoundedupUnit.groupOf(groupName)); }
            if (Restockkbn.name().equals(name())) { return toClsList(CDef.Restockkbn.groupOf(groupName)); }
            if (Zaikodiv.name().equals(name())) { return toClsList(CDef.Zaikodiv.groupOf(groupName)); }
            if (Openflg.name().equals(name())) { return toClsList(CDef.Openflg.groupOf(groupName)); }
            if (TodayPrintOnlyFlg.name().equals(name())) { return toClsList(CDef.TodayPrintOnlyFlg.groupOf(groupName)); }
            if (StartEnd.name().equals(name())) { return toClsList(CDef.StartEnd.groupOf(groupName)); }
            if (SyhnKbnJt.name().equals(name())) { return toClsList(CDef.SyhnKbnJt.groupOf(groupName)); }
            if (Transkbn.name().equals(name())) { return toClsList(CDef.Transkbn.groupOf(groupName)); }
            if (Carknd.name().equals(name())) { return toClsList(CDef.Carknd.groupOf(groupName)); }
            if (Cartypecmb0tdisp.name().equals(name())) { return toClsList(CDef.Cartypecmb0tdisp.groupOf(groupName)); }
            if (CenterPicListCls1.name().equals(name())) { return toClsList(CDef.CenterPicListCls1.groupOf(groupName)); }
            if (CenterPicListCls2.name().equals(name())) { return toClsList(CDef.CenterPicListCls2.groupOf(groupName)); }
            if (CenterPicListCls3.name().equals(name())) { return toClsList(CDef.CenterPicListCls3.groupOf(groupName)); }
            if (CenterSagawaDelivTz.name().equals(name())) { return toClsList(CDef.CenterSagawaDelivTz.groupOf(groupName)); }
            if (CenterTransportTypeItem.name().equals(name())) { return toClsList(CDef.CenterTransportTypeItem.groupOf(groupName)); }
            if (CenterSlipShapeCd.name().equals(name())) { return toClsList(CDef.CenterSlipShapeCd.groupOf(groupName)); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return toClsList(CDef.CenterTransportTypeSpeed.groupOf(groupName)); }
            if (CenterSealType.name().equals(name())) { return toClsList(CDef.CenterSealType.groupOf(groupName)); }
            if (CenterTagClass.name().equals(name())) { return toClsList(CDef.CenterTagClass.groupOf(groupName)); }
            if (CenterTagDataType.name().equals(name())) { return toClsList(CDef.CenterTagDataType.groupOf(groupName)); }
            if (CenterTagType.name().equals(name())) { return toClsList(CDef.CenterTagType.groupOf(groupName)); }
            if (CenterTagTypeAfter.name().equals(name())) { return toClsList(CDef.CenterTagTypeAfter.groupOf(groupName)); }
            if (CenterApiBinsyuCode.name().equals(name())) { return toClsList(CDef.CenterApiBinsyuCode.groupOf(groupName)); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiFlg.groupOf(groupName)); }
            if (CenterApiDaibikiType.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiType.groupOf(groupName)); }
            if (CenterApiEidomeFlg.name().equals(name())) { return toClsList(CDef.CenterApiEidomeFlg.groupOf(groupName)); }
            if (CenterApiWeightCd.name().equals(name())) { return toClsList(CDef.CenterApiWeightCd.groupOf(groupName)); }
            if (CenterOutputTargetFlg.name().equals(name())) { return toClsList(CDef.CenterOutputTargetFlg.groupOf(groupName)); }
            if (CenterPrintCondition.name().equals(name())) { return toClsList(CDef.CenterPrintCondition.groupOf(groupName)); }
            if (CenterDesignflg.name().equals(name())) { return toClsList(CDef.CenterDesignflg.groupOf(groupName)); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        @SuppressWarnings("unchecked")
        private List<Classification> toClsList(List<?> clsList) {
            return (List<Classification>)clsList;
        }

        public ClassificationCodeType codeType() {
            if (ProcessTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return ClassificationCodeType.String; }
            if (AfterTagOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AllcNgDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (AllcNgFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AllocSortKey.name().equals(name())) { return ClassificationCodeType.String; }
            if (AllShippingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ArrivalStoreFormat.name().equals(name())) { return ClassificationCodeType.String; }
            if (AutoEmgSetFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AutoEmgSetTgt.name().equals(name())) { return ClassificationCodeType.String; }
            if (AutoPrintTargetFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AutoShipInstFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (BarcodeType.name().equals(name())) { return ClassificationCodeType.String; }
            if (BatchProgressFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (BoxSelectSkip.name().equals(name())) { return ClassificationCodeType.String; }
            if (CancelDataDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (CasePicFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterClientCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTransitFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CharacterCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (ChargeQty0Display.name().equals(name())) { return ClassificationCodeType.String; }
            if (CheckDigit.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodeType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ColType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CommentFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CompanyFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CoolCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (CoolType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CopyTargetTable.name().equals(name())) { return ClassificationCodeType.String; }
            if (CorrectType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputCommitType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputOperationType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputProcessType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputRange.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataType.name().equals(name())) { return ClassificationCodeType.String; }
            if (Default.name().equals(name())) { return ClassificationCodeType.String; }
            if (DefaultFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DeleteDataDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (DeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DelivMatchFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DelivTz.name().equals(name())) { return ClassificationCodeType.String; }
            if (DelFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DepositFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DisplayRequired.name().equals(name())) { return ClassificationCodeType.String; }
            if (DtCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (Editable.name().equals(name())) { return ClassificationCodeType.String; }
            if (EmergencyDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (EmergencyFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ErrorFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ErrorProcessMet.name().equals(name())) { return ClassificationCodeType.String; }
            if (FixedPoint.name().equals(name())) { return ClassificationCodeType.String; }
            if (ForceFixedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ForeignFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (GiftFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (GiftStatementType.name().equals(name())) { return ClassificationCodeType.String; }
            if (HtCharReadFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ImportFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InfoFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InoutType.name().equals(name())) { return ClassificationCodeType.String; }
            if (InputType.name().equals(name())) { return ClassificationCodeType.String; }
            if (InspectionFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InventoryLocationProduct.name().equals(name())) { return ClassificationCodeType.String; }
            if (InvoiceCreateFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ItemType.name().equals(name())) { return ClassificationCodeType.String; }
            if (LastFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitDtManagFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitDtReverseFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitMessageCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (LineFeedCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (ListOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ListOutFlgDisp.name().equals(name())) { return ClassificationCodeType.String; }
            if (ListOutKbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (LoadingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LocationType.name().equals(name())) { return ClassificationCodeType.String; }
            if (Lockout.name().equals(name())) { return ClassificationCodeType.String; }
            if (LogDtlStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (LogDtlType.name().equals(name())) { return ClassificationCodeType.String; }
            if (LogStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (LotManagFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LotReverseFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (MergeCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (MergeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (MessageType.name().equals(name())) { return ClassificationCodeType.String; }
            if (MixedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (MoveInstStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (MultiPicCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (MultiPicFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Necessary.name().equals(name())) { return ClassificationCodeType.String; }
            if (NotCompletedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoAllcDisplayFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoConfirmedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoStockCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoStockOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoUpsideDownCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (OnetimeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (OverStoreNumFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingCalCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingProcessCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingShowFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PasswordReset.name().equals(name())) { return ClassificationCodeType.String; }
            if (PastStoreDtFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PhysicalDelete.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingLocationFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PicCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return ClassificationCodeType.String; }
            if (PicMthdRcmdFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PicMthdRcmdListOut.name().equals(name())) { return ClassificationCodeType.String; }
            if (PostType.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintDataType.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintErrorFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintQueueStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintResultClass.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintServiceStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PriorityFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductLabelJanBarcode.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductLabelOutUnit.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductLabelProdBarcode.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductPartPacking.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductTypeCode.name().equals(name())) { return ClassificationCodeType.String; }
            if (Qty0Display.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReasonType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveDeliveryStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishAllocCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishProductCdUnset.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishSearchCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishUnitCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReportLayoutItemType.name().equals(name())) { return ClassificationCodeType.String; }
            if (RestockType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ResultAfterProductLabel.name().equals(name())) { return ClassificationCodeType.String; }
            if (ResultAfterProductTarget.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReverseValidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (RoleControlClass.name().equals(name())) { return ClassificationCodeType.String; }
            if (Select.name().equals(name())) { return ClassificationCodeType.String; }
            if (SelectPrintServiceStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (SerialOperationType.name().equals(name())) { return ClassificationCodeType.String; }
            if (SettlementType.name().equals(name())) { return ClassificationCodeType.String; }
            if (SglRowInspAfterOutCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (SglRowPicFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SheetCollate.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingStopFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShortStockDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShpCheckCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShpCheckDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (SlipType.name().equals(name())) { return ClassificationCodeType.String; }
            if (SoundPlayFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockAdjustFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockDisplayFld.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockExistOnlyFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockMoveFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockNum0Display.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutAllocCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutAutoInstFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutInstCxlFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutInstSplitFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockQtyDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockTakingInput.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockTarget.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreDtFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreNoDivideDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreNoFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreNoMergeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SystemLogStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (SystemLogType.name().equals(name())) { return ClassificationCodeType.String; }
            if (SystemType.name().equals(name())) { return ClassificationCodeType.String; }
            if (TagDeliveryOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TakingShippingDtFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TakingShippingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TargetWindow.name().equals(name())) { return ClassificationCodeType.String; }
            if (TextAlign.name().equals(name())) { return ClassificationCodeType.String; }
            if (TotalPicFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TrackingNumberingUnit.name().equals(name())) { return ClassificationCodeType.String; }
            if (TransitDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (Unmatch.name().equals(name())) { return ClassificationCodeType.String; }
            if (Updatable.name().equals(name())) { return ClassificationCodeType.String; }
            if (UpdCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (UpdType.name().equals(name())) { return ClassificationCodeType.String; }
            if (UploadTableNm.name().equals(name())) { return ClassificationCodeType.String; }
            if (UserEditable.name().equals(name())) { return ClassificationCodeType.String; }
            if (UseHtShipFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (VendorFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Visible.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkMessageFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (YamatoDelivTz.name().equals(name())) { return ClassificationCodeType.String; }
            if (YupackDelivTz.name().equals(name())) { return ClassificationCodeType.String; }
            if (ZipFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AttendanceLeavingRest.name().equals(name())) { return ClassificationCodeType.String; }
            if (BolOutputTargetFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (BolOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CasePickFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CasePicTarget.name().equals(name())) { return ClassificationCodeType.String; }
            if (CesIntegrationFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DecimalExistFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DecimalProductPacking.name().equals(name())) { return ClassificationCodeType.String; }
            if (DoNotStackStackFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (EmReplenishShapeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (FoogFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (FreezableProtectionFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (FreightCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (GuaranteedPlusFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InsidePickupCollectFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InspectionLabelOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitedAccessPickupFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (OverSizedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PaymentTerm.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingType.name().equals(name())) { return ClassificationCodeType.String; }
            if (PoisonFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (RcmdPickingCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ResidentialDeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ResidentialPickupFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SatDeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SglRowPicTarget.name().equals(name())) { return ClassificationCodeType.String; }
            if (SignatureReleaseFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SignatureRequiredFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (UploadZipType.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkLogOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (Adjuststatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (Companygroup.name().equals(name())) { return ClassificationCodeType.String; }
            if (LocGroup.name().equals(name())) { return ClassificationCodeType.String; }
            if (Worktype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Capitemflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Palletests.name().equals(name())) { return ClassificationCodeType.String; }
            if (Usid.name().equals(name())) { return ClassificationCodeType.String; }
            if (Itemusedflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Symbolsts.name().equals(name())) { return ClassificationCodeType.String; }
            if (Solistkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Palletaddflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Productdiv.name().equals(name())) { return ClassificationCodeType.String; }
            if (Soroutediv.name().equals(name())) { return ClassificationCodeType.String; }
            if (Requesttype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Examsts.name().equals(name())) { return ClassificationCodeType.String; }
            if (Ordernoaddcd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Tracetype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Warehouseid.name().equals(name())) { return ClassificationCodeType.String; }
            if (Markettype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Reservationflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Packingtype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Productmarkptn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Productmarkptnbatj.name().equals(name())) { return ClassificationCodeType.String; }
            if (Productmarkmonth.name().equals(name())) { return ClassificationCodeType.String; }
            if (Limitdatemonth.name().equals(name())) { return ClassificationCodeType.String; }
            if (Alclimitdatemonth.name().equals(name())) { return ClassificationCodeType.String; }
            if (Labellayoutmaster.name().equals(name())) { return ClassificationCodeType.String; }
            if (Trafficpattern.name().equals(name())) { return ClassificationCodeType.String; }
            if (Cgrid.name().equals(name())) { return ClassificationCodeType.String; }
            if (Reportname.name().equals(name())) { return ClassificationCodeType.String; }
            if (Jyokenflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Imshiptocode.name().equals(name())) { return ClassificationCodeType.String; }
            if (Fileinfo.name().equals(name())) { return ClassificationCodeType.String; }
            if (Shiptocdchg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Tdwmscd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Inoutdatatype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Invmoveterm.name().equals(name())) { return ClassificationCodeType.String; }
            if (Symbolsendhulftmaster.name().equals(name())) { return ClassificationCodeType.String; }
            if (Logflag.name().equals(name())) { return ClassificationCodeType.String; }
            if (Assortmentsts.name().equals(name())) { return ClassificationCodeType.String; }
            if (Assortmentflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Aststsforsearch.name().equals(name())) { return ClassificationCodeType.String; }
            if (Firstexamsendflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Mossendflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Casecreatetype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Mosjtsendflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Batkeepwarehousecd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Batwarehousecd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Datamakeflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Rcvresultqtytype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Qualityexamflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Makercasecodefixedvalue.name().equals(name())) { return ClassificationCodeType.String; }
            if (Productmarkjttaxfree.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefS011.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefS012.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefN002.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefZ005.name().equals(name())) { return ClassificationCodeType.String; }
            if (Sortstockkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Tracetypedt.name().equals(name())) { return ClassificationCodeType.String; }
            if (Racklabelprflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefS0031.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefS0032.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefS0033.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefS0034.name().equals(name())) { return ClassificationCodeType.String; }
            if (Unknowncaselimit.name().equals(name())) { return ClassificationCodeType.String; }
            if (Sortinvkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Cloudcasenum.name().equals(name())) { return ClassificationCodeType.String; }
            if (Pulltype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Storageloc.name().equals(name())) { return ClassificationCodeType.String; }
            if (Pallettracetype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Datasendtype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Tracecreatests.name().equals(name())) { return ClassificationCodeType.String; }
            if (Sortinvtiming.name().equals(name())) { return ClassificationCodeType.String; }
            if (Casesupplytype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Importumu.name().equals(name())) { return ClassificationCodeType.String; }
            if (Traceshiftflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Shtypecd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Allocpolicy.name().equals(name())) { return ClassificationCodeType.String; }
            if (Rtncompanyname.name().equals(name())) { return ClassificationCodeType.String; }
            if (Opendiff.name().equals(name())) { return ClassificationCodeType.String; }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Flexpickprflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkmasterExp.name().equals(name())) { return ClassificationCodeType.String; }
            if (Tasktype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Tasktypedetail.name().equals(name())) { return ClassificationCodeType.String; }
            if (Yztraceshiftflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Workercdsearchtype.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefZ004.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefZ008.name().equals(name())) { return ClassificationCodeType.String; }
            if (Pickdistname.name().equals(name())) { return ClassificationCodeType.String; }
            if (Traceswitchflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Lblkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Assortkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Dmycasecd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Baditemdelkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Selectlimit.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefW001.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefW002.name().equals(name())) { return ClassificationCodeType.String; }
            if (Settlementinvmonth.name().equals(name())) { return ClassificationCodeType.String; }
            if (Flexinstructsts.name().equals(name())) { return ClassificationCodeType.String; }
            if (Compulsionflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Displaymonth.name().equals(name())) { return ClassificationCodeType.String; }
            if (Sufferusagesearchflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Fltstdinv.name().equals(name())) { return ClassificationCodeType.String; }
            if (Cs3switchflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Inadequacyarea.name().equals(name())) { return ClassificationCodeType.String; }
            if (Transmitflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Flalterflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Invsts.name().equals(name())) { return ClassificationCodeType.String; }
            if (Concurrentbase.name().equals(name())) { return ClassificationCodeType.String; }
            if (Concurrentname.name().equals(name())) { return ClassificationCodeType.String; }
            if (Caseshipstatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (Ngpitemcd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Fzloccd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Whsortinvkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Syncreportform.name().equals(name())) { return ClassificationCodeType.String; }
            if (Sortwarehousecd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Hozeiwarehousecd.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrinterdefH002.name().equals(name())) { return ClassificationCodeType.String; }
            if (Reportformname.name().equals(name())) { return ClassificationCodeType.String; }
            if (Taskname.name().equals(name())) { return ClassificationCodeType.String; }
            if (Whinvkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Procflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SyhnKbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Pallettype.name().equals(name())) { return ClassificationCodeType.String; }
            if (InventoryInstKbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (InventoryReport.name().equals(name())) { return ClassificationCodeType.String; }
            if (Completeflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Oneitemonlyflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Oneowneronlyflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Picktype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Rcvtype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Slottype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Capselect.name().equals(name())) { return ClassificationCodeType.String; }
            if (Kashikokuzeikubn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Instructflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Palleteoutputtype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Palletecuttingkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Frontrackcd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Sufferflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Unmatchflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Alcimrsnflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Manyfewoccurarea.name().equals(name())) { return ClassificationCodeType.String; }
            if (Manyfewoccurareadisp.name().equals(name())) { return ClassificationCodeType.String; }
            if (Designchg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Differenceumu.name().equals(name())) { return ClassificationCodeType.String; }
            if (Stockdistinction.name().equals(name())) { return ClassificationCodeType.String; }
            if (Workmaster.name().equals(name())) { return ClassificationCodeType.String; }
            if (Picklisttype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Sortzaikbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Sorttype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Exchgmethod.name().equals(name())) { return ClassificationCodeType.String; }
            if (Conditionflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Qtyadjustflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Inoutcode.name().equals(name())) { return ClassificationCodeType.String; }
            if (Inventorytype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Attensionflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Formdiffflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Timingtype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Fcflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SundayFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Pluralproductionkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Changeflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Rtnstatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (Rtninspestatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (Inventoryref.name().equals(name())) { return ClassificationCodeType.String; }
            if (Restockflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Validtype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Rtnchangedivision.name().equals(name())) { return ClassificationCodeType.String; }
            if (Storagearea.name().equals(name())) { return ClassificationCodeType.String; }
            if (Maxinvflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Horyukbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Useflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Fckokuflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Bowltypeflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Inventoryrefdisp.name().equals(name())) { return ClassificationCodeType.String; }
            if (Flinstrstatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (Flexstatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (Distributioncd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Stocklocation.name().equals(name())) { return ClassificationCodeType.String; }
            if (ResultStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (BoxCategory.name().equals(name())) { return ClassificationCodeType.String; }
            if (Storagewarehousecd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Salestype.name().equals(name())) { return ClassificationCodeType.String; }
            if (Solistkbn2.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingListType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CoveredClass.name().equals(name())) { return ClassificationCodeType.String; }
            if (NotCoveredClass.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingWorkStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReprintedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Cggdid.name().equals(name())) { return ClassificationCodeType.String; }
            if (RcvPlanSts.name().equals(name())) { return ClassificationCodeType.String; }
            if (Virtuallocflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SufferUsageFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Thedaysortingcompleteflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Gooditemkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Slptyp.name().equals(name())) { return ClassificationCodeType.String; }
            if (SostatusForserch2.name().equals(name())) { return ClassificationCodeType.String; }
            if (LineOrderKbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Consolidationflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DaysOfWeek.name().equals(name())) { return ClassificationCodeType.String; }
            if (Lockbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return ClassificationCodeType.String; }
            if (Restockkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Zaikodiv.name().equals(name())) { return ClassificationCodeType.String; }
            if (Openflg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TodayPrintOnlyFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StartEnd.name().equals(name())) { return ClassificationCodeType.String; }
            if (SyhnKbnJt.name().equals(name())) { return ClassificationCodeType.String; }
            if (Transkbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (Carknd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Cartypecmb0tdisp.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterPicListCls1.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterPicListCls2.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterPicListCls3.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterSagawaDelivTz.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTransportTypeItem.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterSlipShapeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTransportTypeSpeed.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterSealType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTagClass.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTagDataType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTagType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTagTypeAfter.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiBinsyuCode.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiDaibikiFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiDaibikiType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiEidomeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiWeightCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterOutputTargetFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterPrintCondition.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterDesignflg.name().equals(name())) { return ClassificationCodeType.String; }
            return ClassificationCodeType.String; // as default
        }

        public ClassificationUndefinedHandlingType undefinedHandlingType() {
            if (ProcessTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AfterTagOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AllcNgDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AllcNgFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AllocSortKey.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AllShippingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ArrivalStoreFormat.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AutoEmgSetFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AutoEmgSetTgt.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AutoPrintTargetFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AutoShipInstFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BarcodeType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BatchProgressFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BoxSelectSkip.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CancelDataDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CasePicFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterClientCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTransitFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CharacterCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ChargeQty0Display.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CheckDigit.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodeType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ColType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CommentFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CompanyFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CoolCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CoolType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CopyTargetTable.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CorrectType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputCommitType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputOperationType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputProcessType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputRange.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Default.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DefaultFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DeleteDataDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DelivMatchFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DelivTz.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DelFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DepositFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DisplayRequired.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DtCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Editable.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (EmergencyDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (EmergencyFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ErrorFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ErrorProcessMet.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FixedPoint.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ForceFixedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ForeignFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (GiftFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (GiftStatementType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HtCharReadFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ImportFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InfoFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InoutType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InputType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InspectionFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InventoryLocationProduct.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InvoiceCreateFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ItemType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LastFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitDtManagFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitDtReverseFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitMessageCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LineFeedCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ListOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ListOutFlgDisp.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ListOutKbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LoadingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LocationType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Lockout.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LogDtlStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LogDtlType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LogStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LotManagFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LotReverseFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MergeCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MergeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MessageType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MixedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MoveInstStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MultiPicCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MultiPicFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Necessary.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NotCompletedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoAllcDisplayFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoConfirmedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoStockCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoStockOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoUpsideDownCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OnetimeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OverStoreNumFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingCalCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingProcessCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingShowFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PasswordReset.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PastStoreDtFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PhysicalDelete.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingLocationFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PicCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PicMthdRcmdFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PicMthdRcmdListOut.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PostType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintDataType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintErrorFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintQueueStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintResultClass.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintServiceStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PriorityFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductLabelJanBarcode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductLabelOutUnit.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductLabelProdBarcode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductPartPacking.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductTypeCode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Qty0Display.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReasonType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveDeliveryStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishAllocCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishProductCdUnset.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishSearchCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishUnitCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReportLayoutItemType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RestockType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ResultAfterProductLabel.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ResultAfterProductTarget.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReverseValidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RoleControlClass.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Select.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SelectPrintServiceStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SerialOperationType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SettlementType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SglRowInspAfterOutCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SglRowPicFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SheetCollate.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingStopFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShortStockDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShpCheckCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShpCheckDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SlipType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SoundPlayFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockAdjustFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockDisplayFld.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockExistOnlyFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockMoveFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockNum0Display.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutAllocCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutAutoInstFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutInstCxlFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutInstSplitFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockQtyDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockTakingInput.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockTarget.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreDtFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreNoDivideDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreNoFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreNoMergeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SystemLogStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SystemLogType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SystemType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TagDeliveryOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TakingShippingDtFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TakingShippingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TargetWindow.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TextAlign.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TotalPicFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TrackingNumberingUnit.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TransitDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Unmatch.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Updatable.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UpdCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UpdType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UploadTableNm.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UserEditable.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UseHtShipFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (VendorFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Visible.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkMessageFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (YamatoDelivTz.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (YupackDelivTz.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ZipFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AttendanceLeavingRest.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BolOutputTargetFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BolOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CasePickFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CasePicTarget.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CesIntegrationFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DecimalExistFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DecimalProductPacking.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DoNotStackStackFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (EmReplenishShapeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FoogFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FreezableProtectionFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FreightCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (GuaranteedPlusFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InsidePickupCollectFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InspectionLabelOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitedAccessPickupFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OverSizedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PaymentTerm.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PoisonFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RcmdPickingCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ResidentialDeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ResidentialPickupFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SatDeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SglRowPicTarget.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SignatureReleaseFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SignatureRequiredFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UploadZipType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkLogOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Adjuststatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Companygroup.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LocGroup.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Worktype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Capitemflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Palletests.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Usid.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Itemusedflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Symbolsts.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Solistkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Palletaddflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Productdiv.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Soroutediv.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Requesttype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Examsts.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Ordernoaddcd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Tracetype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Warehouseid.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Markettype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Reservationflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Packingtype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Productmarkptn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Productmarkptnbatj.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Productmarkmonth.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Limitdatemonth.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Alclimitdatemonth.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Labellayoutmaster.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Trafficpattern.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Cgrid.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Reportname.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Jyokenflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Imshiptocode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Fileinfo.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Shiptocdchg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Tdwmscd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Inoutdatatype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Invmoveterm.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Symbolsendhulftmaster.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Logflag.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Assortmentsts.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Assortmentflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Aststsforsearch.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Firstexamsendflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Mossendflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Casecreatetype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Mosjtsendflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Batkeepwarehousecd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Batwarehousecd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Datamakeflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Rcvresultqtytype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Qualityexamflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Makercasecodefixedvalue.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Productmarkjttaxfree.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefS011.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefS012.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefN002.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefZ005.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Sortstockkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Tracetypedt.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Racklabelprflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefS0031.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefS0032.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefS0033.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefS0034.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Unknowncaselimit.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Sortinvkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Cloudcasenum.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Pulltype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Storageloc.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Pallettracetype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Datasendtype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Tracecreatests.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Sortinvtiming.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Casesupplytype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Importumu.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Traceshiftflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Shtypecd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Allocpolicy.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Rtncompanyname.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Opendiff.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ItemcdlookupAvailableflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Flexpickprflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkmasterExp.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Tasktype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Tasktypedetail.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Yztraceshiftflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Workercdsearchtype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefZ004.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefZ008.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Pickdistname.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Traceswitchflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Lblkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Assortkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Dmycasecd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Baditemdelkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Selectlimit.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefW001.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefW002.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Settlementinvmonth.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Flexinstructsts.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Compulsionflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Displaymonth.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Sufferusagesearchflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Fltstdinv.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Cs3switchflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Inadequacyarea.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Transmitflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Flalterflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Invsts.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Concurrentbase.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Concurrentname.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Caseshipstatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Ngpitemcd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Fzloccd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Whsortinvkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Syncreportform.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Sortwarehousecd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Hozeiwarehousecd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrinterdefH002.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Reportformname.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Taskname.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Whinvkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Procflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SyhnKbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Pallettype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InventoryInstKbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InventoryReport.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Completeflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Oneitemonlyflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Oneowneronlyflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Picktype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Rcvtype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Slottype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Capselect.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Kashikokuzeikubn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Instructflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Palleteoutputtype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Palletecuttingkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Frontrackcd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Sufferflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Unmatchflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Alcimrsnflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Manyfewoccurarea.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Manyfewoccurareadisp.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Designchg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Differenceumu.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Stockdistinction.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Workmaster.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Picklisttype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Sortzaikbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Sorttype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Exchgmethod.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Conditionflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Qtyadjustflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Inoutcode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Inventorytype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Attensionflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Formdiffflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Timingtype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Fcflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SundayFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Pluralproductionkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Changeflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Rtnstatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Rtninspestatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Inventoryref.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Restockflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Validtype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Rtnchangedivision.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Storagearea.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Maxinvflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Horyukbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Useflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Fckokuflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Bowltypeflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Inventoryrefdisp.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Flinstrstatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Flexstatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Distributioncd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Stocklocation.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ResultStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BoxCategory.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Storagewarehousecd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Salestype.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Solistkbn2.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingListType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CoveredClass.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NotCoveredClass.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingWorkStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReprintedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Cggdid.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RcvPlanSts.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Virtuallocflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SufferUsageFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Thedaysortingcompleteflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Gooditemkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Slptyp.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SostatusForserch2.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LineOrderKbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Consolidationflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DaysOfWeek.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Lockbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishmentRoundedupUnit.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Restockkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Zaikodiv.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Openflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TodayPrintOnlyFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StartEnd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SyhnKbnJt.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Transkbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Carknd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Cartypecmb0tdisp.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterPicListCls1.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterPicListCls2.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterPicListCls3.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterSagawaDelivTz.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTransportTypeItem.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterSlipShapeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTransportTypeSpeed.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterSealType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTagClass.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTagDataType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTagType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTagTypeAfter.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiBinsyuCode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiDaibikiFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiDaibikiType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiEidomeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiWeightCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterOutputTargetFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterPrintCondition.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterDesignflg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            return ClassificationUndefinedHandlingType.LOGGING; // as default
        }

        public static OptionalThing<CDef.DefMeta> find(String classificationName) { // instead of valueOf()
            if (classificationName == null) { throw new IllegalArgumentException("The argument 'classificationName' should not be null."); }
            if (ProcessTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProcessTypeCd); }
            if (AfterDelivSlipOutTgt.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AfterDelivSlipOutTgt); }
            if (AfterTagOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AfterTagOutFlg); }
            if (AllcNgDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AllcNgDisplay); }
            if (AllcNgFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AllcNgFlg); }
            if (AllocSortKey.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AllocSortKey); }
            if (AllShippingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AllShippingFlg); }
            if (ArrivalStoreFormat.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ArrivalStoreFormat); }
            if (AutoEmgSetFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AutoEmgSetFlg); }
            if (AutoEmgSetTgt.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AutoEmgSetTgt); }
            if (AutoPrintTargetFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AutoPrintTargetFlg); }
            if (AutoShipInstFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AutoShipInstFlg); }
            if (BarcodeType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BarcodeType); }
            if (BatchProgressFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BatchProgressFlg); }
            if (BoxSelectSkip.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BoxSelectSkip); }
            if (CancelDataDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CancelDataDisplay); }
            if (CasePicFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CasePicFlg); }
            if (CenterClientCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterClientCls); }
            if (CenterTransitFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTransitFlg); }
            if (CharacterCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CharacterCd); }
            if (ChargeQty0Display.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ChargeQty0Display); }
            if (CheckDigit.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CheckDigit); }
            if (CodeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodeFlg); }
            if (CodeType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodeType); }
            if (CodCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodCls); }
            if (CodType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodType); }
            if (ColType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ColType); }
            if (CommentFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CommentFlg); }
            if (CompanyFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CompanyFlg); }
            if (CoolCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CoolCls); }
            if (CoolType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CoolType); }
            if (CopyTargetTable.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CopyTargetTable); }
            if (CorrectType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CorrectType); }
            if (DataInputCommitType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputCommitType); }
            if (DataInputOperationType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputOperationType); }
            if (DataInputProcessType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputProcessType); }
            if (DataInputRange.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputRange); }
            if (DataInputType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputType); }
            if (DataType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataType); }
            if (Default.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Default); }
            if (DefaultFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DefaultFlg); }
            if (DeleteDataDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DeleteDataDisplay); }
            if (DeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DeliveryFlg); }
            if (DelivMatchFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DelivMatchFlg); }
            if (DelivTz.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DelivTz); }
            if (DelFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DelFlg); }
            if (DepositFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DepositFlg); }
            if (DisplayRequired.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DisplayRequired); }
            if (DtCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DtCls); }
            if (Editable.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Editable); }
            if (EmergencyDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.EmergencyDisplay); }
            if (EmergencyFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.EmergencyFlg); }
            if (ErrorFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ErrorFlg); }
            if (ErrorProcessMet.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ErrorProcessMet); }
            if (FixedPoint.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FixedPoint); }
            if (ForceFixedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ForceFixedFlg); }
            if (ForeignFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ForeignFlg); }
            if (GiftFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.GiftFlg); }
            if (GiftStatementType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.GiftStatementType); }
            if (HtCharReadFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HtCharReadFlg); }
            if (ImportFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ImportFlg); }
            if (InfoFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InfoFlg); }
            if (InoutType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InoutType); }
            if (InputType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InputType); }
            if (InspectionFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InspectionFlg); }
            if (InventoryLocationProduct.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InventoryLocationProduct); }
            if (InvoiceCreateFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InvoiceCreateFlg); }
            if (ItemType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ItemType); }
            if (LastFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LastFlg); }
            if (LimitDtManagFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitDtManagFlg); }
            if (LimitDtReverseFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitDtReverseFlg); }
            if (LimitMessageCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitMessageCd); }
            if (LineFeedCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LineFeedCd); }
            if (ListOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ListOutFlg); }
            if (ListOutFlgDisp.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ListOutFlgDisp); }
            if (ListOutKbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ListOutKbn); }
            if (LoadingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LoadingFlg); }
            if (LocationType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LocationType); }
            if (Lockout.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Lockout); }
            if (LogDtlStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LogDtlStatus); }
            if (LogDtlType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LogDtlType); }
            if (LogStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LogStatus); }
            if (LotManagFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LotManagFlg); }
            if (LotReverseFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LotReverseFlg); }
            if (MergeCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MergeCls); }
            if (MergeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MergeFlg); }
            if (MessageType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MessageType); }
            if (MixedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MixedFlg); }
            if (MoveInstStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MoveInstStatus); }
            if (MultiPicCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MultiPicCls); }
            if (MultiPicFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MultiPicFlg); }
            if (Necessary.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Necessary); }
            if (NotCompletedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NotCompletedFlg); }
            if (NoAllcDisplayFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoAllcDisplayFlg); }
            if (NoConfirmedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoConfirmedFlg); }
            if (NoStockCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoStockCls); }
            if (NoStockOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoStockOutFlg); }
            if (NoUpsideDownCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoUpsideDownCls); }
            if (OnetimeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OnetimeFlg); }
            if (OverStoreNumFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OverStoreNumFlg); }
            if (PackingCalCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingCalCls); }
            if (PackingProcessCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingProcessCls); }
            if (PackingShowFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingShowFlg); }
            if (PackingStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingStatus); }
            if (PasswordReset.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PasswordReset); }
            if (PastStoreDtFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PastStoreDtFlg); }
            if (PhysicalDelete.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PhysicalDelete); }
            if (PickingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingFlg); }
            if (PickingLocationFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingLocationFlg); }
            if (PickingStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingStatus); }
            if (PicCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PicCls); }
            if (PicMthdRcmdBreakKey.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PicMthdRcmdBreakKey); }
            if (PicMthdRcmdFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PicMthdRcmdFlg); }
            if (PicMthdRcmdListOut.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PicMthdRcmdListOut); }
            if (PostType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PostType); }
            if (PrintedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintedFlg); }
            if (PrintDataType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintDataType); }
            if (PrintErrorFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintErrorFlg); }
            if (PrintQueueStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintQueueStatus); }
            if (PrintResultClass.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintResultClass); }
            if (PrintServiceStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintServiceStatus); }
            if (PrintStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintStatus); }
            if (PriorityFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PriorityFlg); }
            if (ProductLabelJanBarcode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductLabelJanBarcode); }
            if (ProductLabelOutUnit.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductLabelOutUnit); }
            if (ProductLabelProdBarcode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductLabelProdBarcode); }
            if (ProductPartPacking.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductPartPacking); }
            if (ProductTypeCode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductTypeCode); }
            if (Qty0Display.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Qty0Display); }
            if (ReasonType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReasonType); }
            if (ReceiveDeliveryStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveDeliveryStatus); }
            if (ReceiveFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveFlg); }
            if (ReceiveStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveStatus); }
            if (ReplenishAllocCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishAllocCls); }
            if (ReplenishProductCdUnset.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishProductCdUnset); }
            if (ReplenishSearchCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishSearchCls); }
            if (ReplenishUnitCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishUnitCls); }
            if (ReportLayoutItemType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReportLayoutItemType); }
            if (RestockType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RestockType); }
            if (ResultAfterProductLabel.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ResultAfterProductLabel); }
            if (ResultAfterProductTarget.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ResultAfterProductTarget); }
            if (ReverseValidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReverseValidFlg); }
            if (RoleControlClass.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RoleControlClass); }
            if (Select.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Select); }
            if (SelectPrintServiceStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SelectPrintServiceStatus); }
            if (SerialOperationType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SerialOperationType); }
            if (SettlementType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SettlementType); }
            if (SglRowInspAfterOutCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SglRowInspAfterOutCls); }
            if (SglRowPicFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SglRowPicFlg); }
            if (SheetCollate.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SheetCollate); }
            if (ShippingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingFlg); }
            if (ShippingStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingStatus); }
            if (ShippingStopFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingStopFlg); }
            if (ShortStockDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShortStockDisplay); }
            if (ShpCheckCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShpCheckCls); }
            if (ShpCheckDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShpCheckDisplay); }
            if (SlipType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SlipType); }
            if (SoundPlayFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SoundPlayFlg); }
            if (StockAdjustFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockAdjustFlg); }
            if (StockDisplayFld.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockDisplayFld); }
            if (StockExistOnlyFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockExistOnlyFlg); }
            if (StockMoveFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockMoveFlg); }
            if (StockNum0Display.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockNum0Display); }
            if (StockOutAllocCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutAllocCls); }
            if (StockOutAutoInstFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutAutoInstFlg); }
            if (StockOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutFlg); }
            if (StockOutInstCxlFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutInstCxlFlg); }
            if (StockOutInstSplitFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutInstSplitFlg); }
            if (StockQtyDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockQtyDisplay); }
            if (StockTakingInput.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockTakingInput); }
            if (StockTarget.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockTarget); }
            if (StoreDtFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreDtFlg); }
            if (StoreFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreFlg); }
            if (StoreNoDivideDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreNoDivideDisplay); }
            if (StoreNoFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreNoFlg); }
            if (StoreNoMergeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreNoMergeFlg); }
            if (SystemLogStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SystemLogStatus); }
            if (SystemLogType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SystemLogType); }
            if (SystemType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SystemType); }
            if (TagDeliveryOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TagDeliveryOutFlg); }
            if (TakingShippingDtFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TakingShippingDtFlg); }
            if (TakingShippingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TakingShippingFlg); }
            if (TargetWindow.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TargetWindow); }
            if (TextAlign.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TextAlign); }
            if (TotalPicFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TotalPicFlg); }
            if (TrackingNumberingUnit.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TrackingNumberingUnit); }
            if (TransitDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TransitDisplay); }
            if (Unmatch.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Unmatch); }
            if (Updatable.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Updatable); }
            if (UpdCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UpdCd); }
            if (UpdType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UpdType); }
            if (UploadTableNm.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UploadTableNm); }
            if (UserEditable.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UserEditable); }
            if (UseHtShipFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UseHtShipFlg); }
            if (VendorFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.VendorFlg); }
            if (Visible.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Visible); }
            if (WorkFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkFlg); }
            if (WorkMessageFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkMessageFlg); }
            if (YamatoDelivTz.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.YamatoDelivTz); }
            if (YupackDelivTz.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.YupackDelivTz); }
            if (ZipFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ZipFlg); }
            if (AttendanceLeavingRest.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AttendanceLeavingRest); }
            if (BolOutputTargetFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BolOutputTargetFlg); }
            if (BolOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BolOutFlg); }
            if (CallBeforeDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CallBeforeDeliveryFlg); }
            if (CasePickFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CasePickFlg); }
            if (CasePicTarget.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CasePicTarget); }
            if (CesIntegrationFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CesIntegrationFlg); }
            if (CodFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodFlg); }
            if (DecimalExistFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DecimalExistFlg); }
            if (DecimalProductPacking.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DecimalProductPacking); }
            if (DoNotStackStackFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DoNotStackStackFlg); }
            if (EmReplenishShapeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.EmReplenishShapeFlg); }
            if (FoogFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FoogFlg); }
            if (FreezableProtectionFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FreezableProtectionFlg); }
            if (FreightCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FreightCls); }
            if (GuaranteedPlusFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.GuaranteedPlusFlg); }
            if (InsideDeliveryCollectFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InsideDeliveryCollectFlg); }
            if (InsideDeliveryPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InsideDeliveryPrepaidFlg); }
            if (InsidePickupCollectFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InsidePickupCollectFlg); }
            if (InsidePickupPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InsidePickupPrepaidFlg); }
            if (InspectionLabelOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InspectionLabelOutFlg); }
            if (LiftgateDeliveryCollectFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LiftgateDeliveryCollectFlg); }
            if (LiftgateDeliveryPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LiftgateDeliveryPrepaidFlg); }
            if (LiftgatePickupCollectFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LiftgatePickupCollectFlg); }
            if (LiftgatePickupPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LiftgatePickupPrepaidFlg); }
            if (LimitedAccessDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitedAccessDeliveryFlg); }
            if (LimitedAccessPickupFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitedAccessPickupFlg); }
            if (OverSizedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OverSizedFlg); }
            if (PackingSlipAutoOutputFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingSlipAutoOutputFlg); }
            if (PaymentTerm.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PaymentTerm); }
            if (PickingType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingType); }
            if (PoisonFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PoisonFlg); }
            if (RcmdPickingCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RcmdPickingCls); }
            if (ResidentialDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ResidentialDeliveryFlg); }
            if (ResidentialPickupFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ResidentialPickupFlg); }
            if (SatDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SatDeliveryFlg); }
            if (SglRowPicTarget.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SglRowPicTarget); }
            if (SignatureReleaseFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SignatureReleaseFlg); }
            if (SignatureRequiredFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SignatureRequiredFlg); }
            if (UploadZipType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UploadZipType); }
            if (WorkLogOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkLogOutFlg); }
            if (WorkStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkStatus); }
            if (Adjuststatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Adjuststatus); }
            if (Companygroup.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Companygroup); }
            if (LocGroup.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LocGroup); }
            if (Worktype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Worktype); }
            if (Capitemflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Capitemflg); }
            if (Palletests.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Palletests); }
            if (Usid.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Usid); }
            if (Itemusedflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Itemusedflg); }
            if (Symbolsts.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Symbolsts); }
            if (Solistkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Solistkbn); }
            if (Palletaddflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Palletaddflg); }
            if (Productdiv.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Productdiv); }
            if (Soroutediv.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Soroutediv); }
            if (Requesttype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Requesttype); }
            if (Examsts.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Examsts); }
            if (Ordernoaddcd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Ordernoaddcd); }
            if (Tracetype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Tracetype); }
            if (Warehouseid.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Warehouseid); }
            if (Markettype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Markettype); }
            if (Reservationflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Reservationflg); }
            if (Packingtype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Packingtype); }
            if (Productmarkptn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Productmarkptn); }
            if (Productmarkptnbatj.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Productmarkptnbatj); }
            if (Productmarkmonth.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Productmarkmonth); }
            if (Limitdatemonth.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Limitdatemonth); }
            if (Alclimitdatemonth.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Alclimitdatemonth); }
            if (Labellayoutmaster.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Labellayoutmaster); }
            if (Trafficpattern.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Trafficpattern); }
            if (Cgrid.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Cgrid); }
            if (Reportname.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Reportname); }
            if (Jyokenflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Jyokenflg); }
            if (Imshiptocode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Imshiptocode); }
            if (Fileinfo.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Fileinfo); }
            if (Shiptocdchg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Shiptocdchg); }
            if (Tdwmscd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Tdwmscd); }
            if (Inoutdatatype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Inoutdatatype); }
            if (Invmoveterm.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Invmoveterm); }
            if (Symbolsendhulftmaster.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Symbolsendhulftmaster); }
            if (Logflag.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Logflag); }
            if (Assortmentsts.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Assortmentsts); }
            if (Assortmentflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Assortmentflg); }
            if (Aststsforsearch.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Aststsforsearch); }
            if (Firstexamsendflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Firstexamsendflg); }
            if (Mossendflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Mossendflg); }
            if (Casecreatetype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Casecreatetype); }
            if (Mosjtsendflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Mosjtsendflg); }
            if (Batkeepwarehousecd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Batkeepwarehousecd); }
            if (Batwarehousecd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Batwarehousecd); }
            if (Datamakeflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Datamakeflg); }
            if (Rcvresultqtytype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Rcvresultqtytype); }
            if (Qualityexamflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Qualityexamflg); }
            if (Makercasecodefixedvalue.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Makercasecodefixedvalue); }
            if (Productmarkjttaxfree.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Productmarkjttaxfree); }
            if (PrinterdefS011.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefS011); }
            if (PrinterdefS012.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefS012); }
            if (PrinterdefN002.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefN002); }
            if (PrinterdefZ005.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefZ005); }
            if (Sortstockkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Sortstockkbn); }
            if (Tracetypedt.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Tracetypedt); }
            if (Racklabelprflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Racklabelprflg); }
            if (PrinterdefS0031.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefS0031); }
            if (PrinterdefS0032.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefS0032); }
            if (PrinterdefS0033.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefS0033); }
            if (PrinterdefS0034.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefS0034); }
            if (Unknowncaselimit.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Unknowncaselimit); }
            if (Sortinvkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Sortinvkbn); }
            if (Cloudcasenum.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Cloudcasenum); }
            if (Pulltype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Pulltype); }
            if (Storageloc.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Storageloc); }
            if (Pallettracetype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Pallettracetype); }
            if (Datasendtype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Datasendtype); }
            if (Tracecreatests.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Tracecreatests); }
            if (Sortinvtiming.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Sortinvtiming); }
            if (Casesupplytype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Casesupplytype); }
            if (Importumu.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Importumu); }
            if (Traceshiftflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Traceshiftflg); }
            if (Shtypecd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Shtypecd); }
            if (Allocpolicy.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Allocpolicy); }
            if (Rtncompanyname.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Rtncompanyname); }
            if (Opendiff.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Opendiff); }
            if (ItemcdlookupAvailableflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ItemcdlookupAvailableflg); }
            if (Flexpickprflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Flexpickprflg); }
            if (WorkmasterExp.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkmasterExp); }
            if (Tasktype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Tasktype); }
            if (Tasktypedetail.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Tasktypedetail); }
            if (Yztraceshiftflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Yztraceshiftflg); }
            if (Workercdsearchtype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Workercdsearchtype); }
            if (PrinterdefZ004.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefZ004); }
            if (PrinterdefZ008.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefZ008); }
            if (Pickdistname.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Pickdistname); }
            if (Traceswitchflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Traceswitchflg); }
            if (Lblkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Lblkbn); }
            if (Assortkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Assortkbn); }
            if (Dmycasecd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Dmycasecd); }
            if (Baditemdelkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Baditemdelkbn); }
            if (Selectlimit.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Selectlimit); }
            if (PrinterdefW001.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefW001); }
            if (PrinterdefW002.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefW002); }
            if (Settlementinvmonth.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Settlementinvmonth); }
            if (Flexinstructsts.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Flexinstructsts); }
            if (Compulsionflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Compulsionflg); }
            if (Displaymonth.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Displaymonth); }
            if (Sufferusagesearchflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Sufferusagesearchflg); }
            if (Fltstdinv.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Fltstdinv); }
            if (Cs3switchflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Cs3switchflg); }
            if (Inadequacyarea.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Inadequacyarea); }
            if (Transmitflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Transmitflg); }
            if (Flalterflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Flalterflg); }
            if (Invsts.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Invsts); }
            if (Concurrentbase.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Concurrentbase); }
            if (Concurrentname.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Concurrentname); }
            if (Caseshipstatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Caseshipstatus); }
            if (Ngpitemcd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Ngpitemcd); }
            if (Fzloccd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Fzloccd); }
            if (Whsortinvkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Whsortinvkbn); }
            if (Syncreportform.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Syncreportform); }
            if (Sortwarehousecd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Sortwarehousecd); }
            if (Hozeiwarehousecd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Hozeiwarehousecd); }
            if (PrinterdefH002.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrinterdefH002); }
            if (Reportformname.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Reportformname); }
            if (Taskname.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Taskname); }
            if (Whinvkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Whinvkbn); }
            if (Procflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Procflg); }
            if (SyhnKbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SyhnKbn); }
            if (Pallettype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Pallettype); }
            if (InventoryInstKbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InventoryInstKbn); }
            if (InventoryReport.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InventoryReport); }
            if (Completeflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Completeflg); }
            if (Oneitemonlyflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Oneitemonlyflg); }
            if (Oneowneronlyflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Oneowneronlyflg); }
            if (Picktype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Picktype); }
            if (Rcvtype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Rcvtype); }
            if (Slottype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Slottype); }
            if (Capselect.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Capselect); }
            if (Kashikokuzeikubn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Kashikokuzeikubn); }
            if (Instructflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Instructflg); }
            if (Palleteoutputtype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Palleteoutputtype); }
            if (Palletecuttingkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Palletecuttingkbn); }
            if (Frontrackcd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Frontrackcd); }
            if (Sufferflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Sufferflg); }
            if (Unmatchflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Unmatchflg); }
            if (Alcimrsnflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Alcimrsnflg); }
            if (Manyfewoccurarea.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Manyfewoccurarea); }
            if (Manyfewoccurareadisp.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Manyfewoccurareadisp); }
            if (Designchg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Designchg); }
            if (Differenceumu.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Differenceumu); }
            if (Stockdistinction.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Stockdistinction); }
            if (Workmaster.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Workmaster); }
            if (Picklisttype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Picklisttype); }
            if (Sortzaikbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Sortzaikbn); }
            if (Sorttype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Sorttype); }
            if (Exchgmethod.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Exchgmethod); }
            if (Conditionflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Conditionflg); }
            if (Qtyadjustflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Qtyadjustflg); }
            if (Inoutcode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Inoutcode); }
            if (Inventorytype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Inventorytype); }
            if (Attensionflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Attensionflg); }
            if (Formdiffflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Formdiffflg); }
            if (Timingtype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Timingtype); }
            if (Fcflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Fcflg); }
            if (SundayFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SundayFlg); }
            if (Pluralproductionkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Pluralproductionkbn); }
            if (Changeflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Changeflg); }
            if (Rtnstatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Rtnstatus); }
            if (Rtninspestatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Rtninspestatus); }
            if (Inventoryref.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Inventoryref); }
            if (Restockflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Restockflg); }
            if (Validtype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Validtype); }
            if (Rtnchangedivision.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Rtnchangedivision); }
            if (Storagearea.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Storagearea); }
            if (Maxinvflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Maxinvflg); }
            if (Horyukbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Horyukbn); }
            if (Useflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Useflg); }
            if (Fckokuflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Fckokuflg); }
            if (Bowltypeflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Bowltypeflg); }
            if (Inventoryrefdisp.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Inventoryrefdisp); }
            if (Flinstrstatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Flinstrstatus); }
            if (Flexstatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Flexstatus); }
            if (Distributioncd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Distributioncd); }
            if (Stocklocation.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Stocklocation); }
            if (ResultStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ResultStatus); }
            if (BoxCategory.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BoxCategory); }
            if (Storagewarehousecd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Storagewarehousecd); }
            if (Salestype.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Salestype); }
            if (Solistkbn2.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Solistkbn2); }
            if (PickingListType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingListType); }
            if (CoveredClass.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CoveredClass); }
            if (NotCoveredClass.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NotCoveredClass); }
            if (PickingWorkStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingWorkStatus); }
            if (ReprintedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReprintedFlg); }
            if (Cggdid.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Cggdid); }
            if (RcvPlanSts.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RcvPlanSts); }
            if (Virtuallocflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Virtuallocflg); }
            if (SufferUsageFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SufferUsageFlg); }
            if (Thedaysortingcompleteflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Thedaysortingcompleteflg); }
            if (Gooditemkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Gooditemkbn); }
            if (Slptyp.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Slptyp); }
            if (SostatusForserch2.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SostatusForserch2); }
            if (LineOrderKbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LineOrderKbn); }
            if (Consolidationflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Consolidationflg); }
            if (DaysOfWeek.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DaysOfWeek); }
            if (Lockbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Lockbn); }
            if (ReplenishmentRoundedupUnit.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishmentRoundedupUnit); }
            if (Restockkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Restockkbn); }
            if (Zaikodiv.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Zaikodiv); }
            if (Openflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Openflg); }
            if (TodayPrintOnlyFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TodayPrintOnlyFlg); }
            if (StartEnd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StartEnd); }
            if (SyhnKbnJt.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SyhnKbnJt); }
            if (Transkbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Transkbn); }
            if (Carknd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Carknd); }
            if (Cartypecmb0tdisp.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Cartypecmb0tdisp); }
            if (CenterPicListCls1.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterPicListCls1); }
            if (CenterPicListCls2.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterPicListCls2); }
            if (CenterPicListCls3.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterPicListCls3); }
            if (CenterSagawaDelivTz.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterSagawaDelivTz); }
            if (CenterTransportTypeItem.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTransportTypeItem); }
            if (CenterSlipShapeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterSlipShapeCd); }
            if (CenterTransportTypeSpeed.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTransportTypeSpeed); }
            if (CenterSealType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterSealType); }
            if (CenterTagClass.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTagClass); }
            if (CenterTagDataType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTagDataType); }
            if (CenterTagType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTagType); }
            if (CenterTagTypeAfter.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTagTypeAfter); }
            if (CenterApiBinsyuCode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiBinsyuCode); }
            if (CenterApiDaibikiFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiDaibikiFlg); }
            if (CenterApiDaibikiType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiDaibikiType); }
            if (CenterApiEidomeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiEidomeFlg); }
            if (CenterApiWeightCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiWeightCd); }
            if (CenterOutputTargetFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterOutputTargetFlg); }
            if (CenterPrintCondition.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterPrintCondition); }
            if (CenterDesignflg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterDesignflg); }
            return OptionalThing.ofNullable(null, () -> {
                throw new ClassificationNotFoundException("Unknown classification: " + classificationName);
            });
        }

        public static CDef.DefMeta meta(String classificationName) { // old style so use find(name)
            if (classificationName == null) { throw new IllegalArgumentException("The argument 'classificationName' should not be null."); }
            if (ProcessTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProcessTypeCd; }
            if (AfterDelivSlipOutTgt.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AfterDelivSlipOutTgt; }
            if (AfterTagOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AfterTagOutFlg; }
            if (AllcNgDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AllcNgDisplay; }
            if (AllcNgFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AllcNgFlg; }
            if (AllocSortKey.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AllocSortKey; }
            if (AllShippingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AllShippingFlg; }
            if (ArrivalStoreFormat.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ArrivalStoreFormat; }
            if (AutoEmgSetFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AutoEmgSetFlg; }
            if (AutoEmgSetTgt.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AutoEmgSetTgt; }
            if (AutoPrintTargetFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AutoPrintTargetFlg; }
            if (AutoShipInstFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AutoShipInstFlg; }
            if (BarcodeType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BarcodeType; }
            if (BatchProgressFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BatchProgressFlg; }
            if (BoxSelectSkip.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BoxSelectSkip; }
            if (CancelDataDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CancelDataDisplay; }
            if (CasePicFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CasePicFlg; }
            if (CenterClientCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterClientCls; }
            if (CenterTransitFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTransitFlg; }
            if (CharacterCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CharacterCd; }
            if (ChargeQty0Display.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ChargeQty0Display; }
            if (CheckDigit.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CheckDigit; }
            if (CodeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodeFlg; }
            if (CodeType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodeType; }
            if (CodCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodCls; }
            if (CodType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodType; }
            if (ColType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ColType; }
            if (CommentFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CommentFlg; }
            if (CompanyFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CompanyFlg; }
            if (CoolCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CoolCls; }
            if (CoolType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CoolType; }
            if (CopyTargetTable.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CopyTargetTable; }
            if (CorrectType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CorrectType; }
            if (DataInputCommitType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputCommitType; }
            if (DataInputOperationType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputOperationType; }
            if (DataInputProcessType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputProcessType; }
            if (DataInputRange.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputRange; }
            if (DataInputType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputType; }
            if (DataType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataType; }
            if (Default.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Default; }
            if (DefaultFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DefaultFlg; }
            if (DeleteDataDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DeleteDataDisplay; }
            if (DeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DeliveryFlg; }
            if (DelivMatchFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DelivMatchFlg; }
            if (DelivTz.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DelivTz; }
            if (DelFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DelFlg; }
            if (DepositFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DepositFlg; }
            if (DisplayRequired.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DisplayRequired; }
            if (DtCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DtCls; }
            if (Editable.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Editable; }
            if (EmergencyDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.EmergencyDisplay; }
            if (EmergencyFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.EmergencyFlg; }
            if (ErrorFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ErrorFlg; }
            if (ErrorProcessMet.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ErrorProcessMet; }
            if (FixedPoint.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FixedPoint; }
            if (ForceFixedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ForceFixedFlg; }
            if (ForeignFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ForeignFlg; }
            if (GiftFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.GiftFlg; }
            if (GiftStatementType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.GiftStatementType; }
            if (HtCharReadFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HtCharReadFlg; }
            if (ImportFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ImportFlg; }
            if (InfoFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InfoFlg; }
            if (InoutType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InoutType; }
            if (InputType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InputType; }
            if (InspectionFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InspectionFlg; }
            if (InventoryLocationProduct.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InventoryLocationProduct; }
            if (InvoiceCreateFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InvoiceCreateFlg; }
            if (ItemType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ItemType; }
            if (LastFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LastFlg; }
            if (LimitDtManagFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitDtManagFlg; }
            if (LimitDtReverseFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitDtReverseFlg; }
            if (LimitMessageCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitMessageCd; }
            if (LineFeedCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LineFeedCd; }
            if (ListOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ListOutFlg; }
            if (ListOutFlgDisp.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ListOutFlgDisp; }
            if (ListOutKbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ListOutKbn; }
            if (LoadingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LoadingFlg; }
            if (LocationType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LocationType; }
            if (Lockout.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Lockout; }
            if (LogDtlStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LogDtlStatus; }
            if (LogDtlType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LogDtlType; }
            if (LogStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LogStatus; }
            if (LotManagFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LotManagFlg; }
            if (LotReverseFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LotReverseFlg; }
            if (MergeCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MergeCls; }
            if (MergeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MergeFlg; }
            if (MessageType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MessageType; }
            if (MixedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MixedFlg; }
            if (MoveInstStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MoveInstStatus; }
            if (MultiPicCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MultiPicCls; }
            if (MultiPicFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MultiPicFlg; }
            if (Necessary.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Necessary; }
            if (NotCompletedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NotCompletedFlg; }
            if (NoAllcDisplayFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoAllcDisplayFlg; }
            if (NoConfirmedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoConfirmedFlg; }
            if (NoStockCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoStockCls; }
            if (NoStockOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoStockOutFlg; }
            if (NoUpsideDownCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoUpsideDownCls; }
            if (OnetimeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OnetimeFlg; }
            if (OverStoreNumFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OverStoreNumFlg; }
            if (PackingCalCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingCalCls; }
            if (PackingProcessCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingProcessCls; }
            if (PackingShowFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingShowFlg; }
            if (PackingStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingStatus; }
            if (PasswordReset.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PasswordReset; }
            if (PastStoreDtFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PastStoreDtFlg; }
            if (PhysicalDelete.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PhysicalDelete; }
            if (PickingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingFlg; }
            if (PickingLocationFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingLocationFlg; }
            if (PickingStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingStatus; }
            if (PicCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PicCls; }
            if (PicMthdRcmdBreakKey.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PicMthdRcmdBreakKey; }
            if (PicMthdRcmdFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PicMthdRcmdFlg; }
            if (PicMthdRcmdListOut.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PicMthdRcmdListOut; }
            if (PostType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PostType; }
            if (PrintedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintedFlg; }
            if (PrintDataType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintDataType; }
            if (PrintErrorFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintErrorFlg; }
            if (PrintQueueStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintQueueStatus; }
            if (PrintResultClass.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintResultClass; }
            if (PrintServiceStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintServiceStatus; }
            if (PrintStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintStatus; }
            if (PriorityFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PriorityFlg; }
            if (ProductLabelJanBarcode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductLabelJanBarcode; }
            if (ProductLabelOutUnit.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductLabelOutUnit; }
            if (ProductLabelProdBarcode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductLabelProdBarcode; }
            if (ProductPartPacking.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductPartPacking; }
            if (ProductTypeCode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductTypeCode; }
            if (Qty0Display.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Qty0Display; }
            if (ReasonType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReasonType; }
            if (ReceiveDeliveryStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveDeliveryStatus; }
            if (ReceiveFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveFlg; }
            if (ReceiveStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveStatus; }
            if (ReplenishAllocCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishAllocCls; }
            if (ReplenishProductCdUnset.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishProductCdUnset; }
            if (ReplenishSearchCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishSearchCls; }
            if (ReplenishUnitCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishUnitCls; }
            if (ReportLayoutItemType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReportLayoutItemType; }
            if (RestockType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RestockType; }
            if (ResultAfterProductLabel.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ResultAfterProductLabel; }
            if (ResultAfterProductTarget.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ResultAfterProductTarget; }
            if (ReverseValidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReverseValidFlg; }
            if (RoleControlClass.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RoleControlClass; }
            if (Select.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Select; }
            if (SelectPrintServiceStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SelectPrintServiceStatus; }
            if (SerialOperationType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SerialOperationType; }
            if (SettlementType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SettlementType; }
            if (SglRowInspAfterOutCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SglRowInspAfterOutCls; }
            if (SglRowPicFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SglRowPicFlg; }
            if (SheetCollate.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SheetCollate; }
            if (ShippingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingFlg; }
            if (ShippingStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingStatus; }
            if (ShippingStopFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingStopFlg; }
            if (ShortStockDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShortStockDisplay; }
            if (ShpCheckCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShpCheckCls; }
            if (ShpCheckDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShpCheckDisplay; }
            if (SlipType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SlipType; }
            if (SoundPlayFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SoundPlayFlg; }
            if (StockAdjustFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockAdjustFlg; }
            if (StockDisplayFld.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockDisplayFld; }
            if (StockExistOnlyFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockExistOnlyFlg; }
            if (StockMoveFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockMoveFlg; }
            if (StockNum0Display.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockNum0Display; }
            if (StockOutAllocCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutAllocCls; }
            if (StockOutAutoInstFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutAutoInstFlg; }
            if (StockOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutFlg; }
            if (StockOutInstCxlFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutInstCxlFlg; }
            if (StockOutInstSplitFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutInstSplitFlg; }
            if (StockQtyDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockQtyDisplay; }
            if (StockTakingInput.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockTakingInput; }
            if (StockTarget.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockTarget; }
            if (StoreDtFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreDtFlg; }
            if (StoreFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreFlg; }
            if (StoreNoDivideDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreNoDivideDisplay; }
            if (StoreNoFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreNoFlg; }
            if (StoreNoMergeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreNoMergeFlg; }
            if (SystemLogStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SystemLogStatus; }
            if (SystemLogType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SystemLogType; }
            if (SystemType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SystemType; }
            if (TagDeliveryOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TagDeliveryOutFlg; }
            if (TakingShippingDtFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TakingShippingDtFlg; }
            if (TakingShippingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TakingShippingFlg; }
            if (TargetWindow.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TargetWindow; }
            if (TextAlign.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TextAlign; }
            if (TotalPicFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TotalPicFlg; }
            if (TrackingNumberingUnit.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TrackingNumberingUnit; }
            if (TransitDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TransitDisplay; }
            if (Unmatch.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Unmatch; }
            if (Updatable.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Updatable; }
            if (UpdCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UpdCd; }
            if (UpdType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UpdType; }
            if (UploadTableNm.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UploadTableNm; }
            if (UserEditable.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UserEditable; }
            if (UseHtShipFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UseHtShipFlg; }
            if (VendorFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.VendorFlg; }
            if (Visible.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Visible; }
            if (WorkFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkFlg; }
            if (WorkMessageFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkMessageFlg; }
            if (YamatoDelivTz.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.YamatoDelivTz; }
            if (YupackDelivTz.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.YupackDelivTz; }
            if (ZipFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ZipFlg; }
            if (AttendanceLeavingRest.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AttendanceLeavingRest; }
            if (BolOutputTargetFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BolOutputTargetFlg; }
            if (BolOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BolOutFlg; }
            if (CallBeforeDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CallBeforeDeliveryFlg; }
            if (CasePickFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CasePickFlg; }
            if (CasePicTarget.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CasePicTarget; }
            if (CesIntegrationFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CesIntegrationFlg; }
            if (CodFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodFlg; }
            if (DecimalExistFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DecimalExistFlg; }
            if (DecimalProductPacking.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DecimalProductPacking; }
            if (DoNotStackStackFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DoNotStackStackFlg; }
            if (EmReplenishShapeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.EmReplenishShapeFlg; }
            if (FoogFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FoogFlg; }
            if (FreezableProtectionFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FreezableProtectionFlg; }
            if (FreightCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FreightCls; }
            if (GuaranteedPlusFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.GuaranteedPlusFlg; }
            if (InsideDeliveryCollectFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InsideDeliveryCollectFlg; }
            if (InsideDeliveryPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InsideDeliveryPrepaidFlg; }
            if (InsidePickupCollectFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InsidePickupCollectFlg; }
            if (InsidePickupPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InsidePickupPrepaidFlg; }
            if (InspectionLabelOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InspectionLabelOutFlg; }
            if (LiftgateDeliveryCollectFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LiftgateDeliveryCollectFlg; }
            if (LiftgateDeliveryPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LiftgateDeliveryPrepaidFlg; }
            if (LiftgatePickupCollectFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LiftgatePickupCollectFlg; }
            if (LiftgatePickupPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LiftgatePickupPrepaidFlg; }
            if (LimitedAccessDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitedAccessDeliveryFlg; }
            if (LimitedAccessPickupFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitedAccessPickupFlg; }
            if (OverSizedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OverSizedFlg; }
            if (PackingSlipAutoOutputFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingSlipAutoOutputFlg; }
            if (PaymentTerm.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PaymentTerm; }
            if (PickingType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingType; }
            if (PoisonFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PoisonFlg; }
            if (RcmdPickingCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RcmdPickingCls; }
            if (ResidentialDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ResidentialDeliveryFlg; }
            if (ResidentialPickupFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ResidentialPickupFlg; }
            if (SatDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SatDeliveryFlg; }
            if (SglRowPicTarget.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SglRowPicTarget; }
            if (SignatureReleaseFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SignatureReleaseFlg; }
            if (SignatureRequiredFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SignatureRequiredFlg; }
            if (UploadZipType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UploadZipType; }
            if (WorkLogOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkLogOutFlg; }
            if (WorkStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkStatus; }
            if (Adjuststatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Adjuststatus; }
            if (Companygroup.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Companygroup; }
            if (LocGroup.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LocGroup; }
            if (Worktype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Worktype; }
            if (Capitemflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Capitemflg; }
            if (Palletests.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Palletests; }
            if (Usid.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Usid; }
            if (Itemusedflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Itemusedflg; }
            if (Symbolsts.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Symbolsts; }
            if (Solistkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Solistkbn; }
            if (Palletaddflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Palletaddflg; }
            if (Productdiv.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Productdiv; }
            if (Soroutediv.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Soroutediv; }
            if (Requesttype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Requesttype; }
            if (Examsts.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Examsts; }
            if (Ordernoaddcd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Ordernoaddcd; }
            if (Tracetype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Tracetype; }
            if (Warehouseid.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Warehouseid; }
            if (Markettype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Markettype; }
            if (Reservationflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Reservationflg; }
            if (Packingtype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Packingtype; }
            if (Productmarkptn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Productmarkptn; }
            if (Productmarkptnbatj.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Productmarkptnbatj; }
            if (Productmarkmonth.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Productmarkmonth; }
            if (Limitdatemonth.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Limitdatemonth; }
            if (Alclimitdatemonth.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Alclimitdatemonth; }
            if (Labellayoutmaster.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Labellayoutmaster; }
            if (Trafficpattern.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Trafficpattern; }
            if (Cgrid.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Cgrid; }
            if (Reportname.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Reportname; }
            if (Jyokenflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Jyokenflg; }
            if (Imshiptocode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Imshiptocode; }
            if (Fileinfo.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Fileinfo; }
            if (Shiptocdchg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Shiptocdchg; }
            if (Tdwmscd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Tdwmscd; }
            if (Inoutdatatype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Inoutdatatype; }
            if (Invmoveterm.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Invmoveterm; }
            if (Symbolsendhulftmaster.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Symbolsendhulftmaster; }
            if (Logflag.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Logflag; }
            if (Assortmentsts.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Assortmentsts; }
            if (Assortmentflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Assortmentflg; }
            if (Aststsforsearch.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Aststsforsearch; }
            if (Firstexamsendflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Firstexamsendflg; }
            if (Mossendflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Mossendflg; }
            if (Casecreatetype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Casecreatetype; }
            if (Mosjtsendflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Mosjtsendflg; }
            if (Batkeepwarehousecd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Batkeepwarehousecd; }
            if (Batwarehousecd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Batwarehousecd; }
            if (Datamakeflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Datamakeflg; }
            if (Rcvresultqtytype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Rcvresultqtytype; }
            if (Qualityexamflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Qualityexamflg; }
            if (Makercasecodefixedvalue.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Makercasecodefixedvalue; }
            if (Productmarkjttaxfree.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Productmarkjttaxfree; }
            if (PrinterdefS011.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefS011; }
            if (PrinterdefS012.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefS012; }
            if (PrinterdefN002.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefN002; }
            if (PrinterdefZ005.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefZ005; }
            if (Sortstockkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Sortstockkbn; }
            if (Tracetypedt.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Tracetypedt; }
            if (Racklabelprflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Racklabelprflg; }
            if (PrinterdefS0031.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefS0031; }
            if (PrinterdefS0032.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefS0032; }
            if (PrinterdefS0033.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefS0033; }
            if (PrinterdefS0034.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefS0034; }
            if (Unknowncaselimit.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Unknowncaselimit; }
            if (Sortinvkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Sortinvkbn; }
            if (Cloudcasenum.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Cloudcasenum; }
            if (Pulltype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Pulltype; }
            if (Storageloc.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Storageloc; }
            if (Pallettracetype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Pallettracetype; }
            if (Datasendtype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Datasendtype; }
            if (Tracecreatests.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Tracecreatests; }
            if (Sortinvtiming.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Sortinvtiming; }
            if (Casesupplytype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Casesupplytype; }
            if (Importumu.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Importumu; }
            if (Traceshiftflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Traceshiftflg; }
            if (Shtypecd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Shtypecd; }
            if (Allocpolicy.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Allocpolicy; }
            if (Rtncompanyname.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Rtncompanyname; }
            if (Opendiff.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Opendiff; }
            if (ItemcdlookupAvailableflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ItemcdlookupAvailableflg; }
            if (Flexpickprflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Flexpickprflg; }
            if (WorkmasterExp.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkmasterExp; }
            if (Tasktype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Tasktype; }
            if (Tasktypedetail.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Tasktypedetail; }
            if (Yztraceshiftflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Yztraceshiftflg; }
            if (Workercdsearchtype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Workercdsearchtype; }
            if (PrinterdefZ004.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefZ004; }
            if (PrinterdefZ008.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefZ008; }
            if (Pickdistname.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Pickdistname; }
            if (Traceswitchflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Traceswitchflg; }
            if (Lblkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Lblkbn; }
            if (Assortkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Assortkbn; }
            if (Dmycasecd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Dmycasecd; }
            if (Baditemdelkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Baditemdelkbn; }
            if (Selectlimit.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Selectlimit; }
            if (PrinterdefW001.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefW001; }
            if (PrinterdefW002.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefW002; }
            if (Settlementinvmonth.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Settlementinvmonth; }
            if (Flexinstructsts.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Flexinstructsts; }
            if (Compulsionflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Compulsionflg; }
            if (Displaymonth.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Displaymonth; }
            if (Sufferusagesearchflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Sufferusagesearchflg; }
            if (Fltstdinv.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Fltstdinv; }
            if (Cs3switchflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Cs3switchflg; }
            if (Inadequacyarea.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Inadequacyarea; }
            if (Transmitflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Transmitflg; }
            if (Flalterflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Flalterflg; }
            if (Invsts.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Invsts; }
            if (Concurrentbase.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Concurrentbase; }
            if (Concurrentname.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Concurrentname; }
            if (Caseshipstatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Caseshipstatus; }
            if (Ngpitemcd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Ngpitemcd; }
            if (Fzloccd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Fzloccd; }
            if (Whsortinvkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Whsortinvkbn; }
            if (Syncreportform.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Syncreportform; }
            if (Sortwarehousecd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Sortwarehousecd; }
            if (Hozeiwarehousecd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Hozeiwarehousecd; }
            if (PrinterdefH002.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrinterdefH002; }
            if (Reportformname.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Reportformname; }
            if (Taskname.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Taskname; }
            if (Whinvkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Whinvkbn; }
            if (Procflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Procflg; }
            if (SyhnKbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SyhnKbn; }
            if (Pallettype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Pallettype; }
            if (InventoryInstKbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InventoryInstKbn; }
            if (InventoryReport.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InventoryReport; }
            if (Completeflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Completeflg; }
            if (Oneitemonlyflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Oneitemonlyflg; }
            if (Oneowneronlyflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Oneowneronlyflg; }
            if (Picktype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Picktype; }
            if (Rcvtype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Rcvtype; }
            if (Slottype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Slottype; }
            if (Capselect.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Capselect; }
            if (Kashikokuzeikubn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Kashikokuzeikubn; }
            if (Instructflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Instructflg; }
            if (Palleteoutputtype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Palleteoutputtype; }
            if (Palletecuttingkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Palletecuttingkbn; }
            if (Frontrackcd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Frontrackcd; }
            if (Sufferflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Sufferflg; }
            if (Unmatchflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Unmatchflg; }
            if (Alcimrsnflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Alcimrsnflg; }
            if (Manyfewoccurarea.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Manyfewoccurarea; }
            if (Manyfewoccurareadisp.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Manyfewoccurareadisp; }
            if (Designchg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Designchg; }
            if (Differenceumu.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Differenceumu; }
            if (Stockdistinction.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Stockdistinction; }
            if (Workmaster.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Workmaster; }
            if (Picklisttype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Picklisttype; }
            if (Sortzaikbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Sortzaikbn; }
            if (Sorttype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Sorttype; }
            if (Exchgmethod.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Exchgmethod; }
            if (Conditionflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Conditionflg; }
            if (Qtyadjustflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Qtyadjustflg; }
            if (Inoutcode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Inoutcode; }
            if (Inventorytype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Inventorytype; }
            if (Attensionflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Attensionflg; }
            if (Formdiffflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Formdiffflg; }
            if (Timingtype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Timingtype; }
            if (Fcflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Fcflg; }
            if (SundayFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SundayFlg; }
            if (Pluralproductionkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Pluralproductionkbn; }
            if (Changeflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Changeflg; }
            if (Rtnstatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Rtnstatus; }
            if (Rtninspestatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Rtninspestatus; }
            if (Inventoryref.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Inventoryref; }
            if (Restockflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Restockflg; }
            if (Validtype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Validtype; }
            if (Rtnchangedivision.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Rtnchangedivision; }
            if (Storagearea.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Storagearea; }
            if (Maxinvflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Maxinvflg; }
            if (Horyukbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Horyukbn; }
            if (Useflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Useflg; }
            if (Fckokuflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Fckokuflg; }
            if (Bowltypeflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Bowltypeflg; }
            if (Inventoryrefdisp.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Inventoryrefdisp; }
            if (Flinstrstatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Flinstrstatus; }
            if (Flexstatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Flexstatus; }
            if (Distributioncd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Distributioncd; }
            if (Stocklocation.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Stocklocation; }
            if (ResultStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ResultStatus; }
            if (BoxCategory.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BoxCategory; }
            if (Storagewarehousecd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Storagewarehousecd; }
            if (Salestype.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Salestype; }
            if (Solistkbn2.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Solistkbn2; }
            if (PickingListType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingListType; }
            if (CoveredClass.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CoveredClass; }
            if (NotCoveredClass.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NotCoveredClass; }
            if (PickingWorkStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingWorkStatus; }
            if (ReprintedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReprintedFlg; }
            if (Cggdid.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Cggdid; }
            if (RcvPlanSts.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RcvPlanSts; }
            if (Virtuallocflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Virtuallocflg; }
            if (SufferUsageFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SufferUsageFlg; }
            if (Thedaysortingcompleteflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Thedaysortingcompleteflg; }
            if (Gooditemkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Gooditemkbn; }
            if (Slptyp.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Slptyp; }
            if (SostatusForserch2.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SostatusForserch2; }
            if (LineOrderKbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LineOrderKbn; }
            if (Consolidationflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Consolidationflg; }
            if (DaysOfWeek.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DaysOfWeek; }
            if (Lockbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Lockbn; }
            if (ReplenishmentRoundedupUnit.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishmentRoundedupUnit; }
            if (Restockkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Restockkbn; }
            if (Zaikodiv.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Zaikodiv; }
            if (Openflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Openflg; }
            if (TodayPrintOnlyFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TodayPrintOnlyFlg; }
            if (StartEnd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StartEnd; }
            if (SyhnKbnJt.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SyhnKbnJt; }
            if (Transkbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Transkbn; }
            if (Carknd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Carknd; }
            if (Cartypecmb0tdisp.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Cartypecmb0tdisp; }
            if (CenterPicListCls1.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterPicListCls1; }
            if (CenterPicListCls2.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterPicListCls2; }
            if (CenterPicListCls3.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterPicListCls3; }
            if (CenterSagawaDelivTz.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterSagawaDelivTz; }
            if (CenterTransportTypeItem.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTransportTypeItem; }
            if (CenterSlipShapeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterSlipShapeCd; }
            if (CenterTransportTypeSpeed.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTransportTypeSpeed; }
            if (CenterSealType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterSealType; }
            if (CenterTagClass.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTagClass; }
            if (CenterTagDataType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTagDataType; }
            if (CenterTagType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTagType; }
            if (CenterTagTypeAfter.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTagTypeAfter; }
            if (CenterApiBinsyuCode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiBinsyuCode; }
            if (CenterApiDaibikiFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiDaibikiFlg; }
            if (CenterApiDaibikiType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiDaibikiType; }
            if (CenterApiEidomeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiEidomeFlg; }
            if (CenterApiWeightCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiWeightCd; }
            if (CenterOutputTargetFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterOutputTargetFlg; }
            if (CenterPrintCondition.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterPrintCondition; }
            if (CenterDesignflg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterDesignflg; }
            throw new IllegalStateException("Unknown classification: " + classificationName);
        }

        @SuppressWarnings("unused")
        private String[] xinternalEmptyString() {
            return emptyStrings(); // to suppress 'unused' warning of import statement
        }
    }
}
